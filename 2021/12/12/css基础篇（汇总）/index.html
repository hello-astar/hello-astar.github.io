<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>css基础篇（汇总） | Astar's Blog</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Astar"><meta name="designer" content="minfive"><meta name="keywords" content="astar, astar blog, 前端, 前端开发, 全栈开发, javascript, node.js, 程序员, web"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="canonical" href="http://example.com/2021/12/12/css%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89/index.html"><link rel="icon" type="image/png" href="/img/avatar.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Astar" type="application/atom+xml"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 5.3.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Astar" alt="Astar"><img src="/img/avatar.jpg" alt="Astar"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"></div><header class="post__info"><h1 class="post__title">css基础篇（汇总）</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="https://github.com/hello-astar">Astar</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2021-12-12</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/css/">Css</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h3 id="1-css选择器"><a href="#1-css选择器" class="headerlink" title="1. css选择器"></a>1. css选择器</h3><p>一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。<br>!important &gt; 行内样式 &gt; id &gt; 属性 &gt; 伪类 &gt; 类 &gt; 标签 &gt; 伪元素 &gt; 组合选择器 &gt; 通配符(*)。</p><h4 id="1-1-css选择器之组合选择器"><a href="#1-1-css选择器之组合选择器" class="headerlink" title="1.1 css选择器之组合选择器"></a>1.1 css选择器之组合选择器</h4><table><thead><tr><th>选择器</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>E,F</td><td>多元素选择器</td><td>同时匹配元素E或元素F</td></tr><tr><td>E F</td><td>后代选择器</td><td>匹配E元素所有的后代（不只是子元素、子元素向下<code>递归</code>）元素F</td></tr><tr><td>E&gt;F</td><td>子元素选择器</td><td>匹配E元素的所有<code>直接</code>子元素</td></tr><tr><td>E+F</td><td><code>直接相邻</code>选择器</td><td>匹配E元素之后的相邻的同级元素F</td></tr><tr><td>E~F</td><td>普通相邻选择器（弟弟选择器）</td><td>匹配E元素之后的同级元素F（<code>无论直接相邻与否</code>)</td></tr></tbody></table><h4 id="1-2-css选择器之伪类选择器"><a href="#1-2-css选择器之伪类选择器" class="headerlink" title="1.2 css选择器之伪类选择器"></a>1.2 css选择器之伪类选择器</h4><blockquote><p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。</p></blockquote><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:focus</td><td>input:focus</td><td>选择元素输入后具有焦点</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择所有选中的表单元素</td></tr><tr><td>:read-only</td><td>input:read-only</td><td>选择只读属性的元素属性</td></tr><tr><td>:read-write</td><td>input:read-write</td><td>选择没有只读属性的元素属性</td></tr><tr><td>:disabled</td><td>input:checked</td><td>选择所有禁用的表单元素</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择所有启用的表单元素</td></tr><tr><td>:in-range</td><td>input:in-range</td><td>选择元素指定范围内的值</td></tr><tr><td>:out-of-range</td><td>input:out-of-range</td><td>选择指定范围以外的值的元素属性</td></tr><tr><td>:valid</td><td>input:valid</td><td>选择所有有效值的属性</td></tr><tr><td>:invalid</td><td>input:invalid</td><td>选择所有无效的元素</td></tr><tr><td>:required</td><td>input:required</td><td>选择有”required”属性指定的元素属性</td></tr><tr><td>:optional</td><td>input:optional</td><td>选择没有”required”的元素属性</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择所有没有子元素的p元素</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择每个父元素是p元素的第一个p子元素</td></tr><tr><td>:last-of-type</td><td>p:first-of-type</td><td>选择每个p元素是其父元素的最后一个p元素</td></tr><tr><td>:first-child</td><td>p:first-child</td><td>匹配第一个p元素</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>匹配最后一个p元素</td></tr><tr><td>:not</td><td><code>:not(p)</code></td><td>选择所有p以外的元素</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择所有仅有一个子元素的p元素</td></tr><tr><td>:nth-child</td><td>p:nth-child(2)</td><td>选择所有p元素的第二个子元素</td></tr><tr><td>:nth-last-child</td><td>p:nth-last-child(2)</td><td>选择所有p元素倒数的第二个子元素</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择所有仅有一个子元素为p的元素</td></tr><tr><td>:nth-of-type</td><td>p:nth-of-type(2)</td><td>选择所有p元素第二个为p的子元素</td></tr><tr><td>:nth-last-of-type</td><td>p:nth-last-of-type(2)</td><td>选择所有p元素倒数的第二个为p的子元素</td></tr><tr><td>:link</td><td>a:link</td><td>选择所有未访问链接</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有访问过的链接</td></tr><tr><td>:hover</td><td>a:hover</td><td>把鼠标放在链接上的状态</td></tr><tr><td>:active</td><td>a:active</td><td>选择正在活动链接</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动#news元素(点击URL包含锚的名字)</td></tr><tr><td>:root</td><td>root</td><td>选择文档的根元素</td></tr><tr><td>:lang</td><td>q:lang(no){quotes: “<del>“ “</del>“}</td><td>为不同的语言匹配特殊的规则</td></tr></tbody></table><h4 id="1-3-css选择器之伪元素选择器"><a href="#1-3-css选择器之伪元素选择器" class="headerlink" title="1.3 css选择器之伪元素选择器"></a>1.3 css选择器之伪元素选择器</h4><table><thead><tr><th>选择器</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>::before/:before</td><td>在被选元素前插入内容。</td><td>需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</td></tr><tr><td>::after/:after</td><td>在选被元素后插入内容</td><td>其用法和特性与:before相似。</td></tr><tr><td>::first-letter/:first-letter</td><td>匹配元素中文本的首字母。</td><td>被修饰的首字母不在文档树中。</td></tr><tr><td>::first-line/:first-line</td><td>匹配元素中第一行的文本。</td><td>这个伪元素只能用在块元素中，不能用在内联元素中。</td></tr><tr><td>::selection</td><td>::selection匹配用户被用户选中或者处于高亮状态的部分</td><td>在火狐浏览器使用时需要添加-moz前缀。该伪元素只支持双冒号的形式。</td></tr><tr><td>::placeholder</td><td>::placeholder匹配占位符的文本，只有元素设置了placeholder属性时，该伪元素才能生效。</td><td>该伪元素不是CSS的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（IE10和Firefox18及其以下版本）会使用单冒号的形式。</td></tr><tr><td>::backdrop(处于试验阶段)</td><td>::backdrop用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色</td><td>该伪元素只支持双冒号的形式</td></tr></tbody></table><h4 id="1-4-css选择器之属性选择器"><a href="#1-4-css选择器之属性选择器" class="headerlink" title="1.4 css选择器之属性选择器"></a>1.4 css选择器之属性选择器</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>[attribute]</td><td>a[target]</td><td>用于选择具有指定属性的元素</td></tr><tr><td>[attribute=”value”]</td><td>a[target=”_blank”]</td><td>用于选择具有指定属性和值的元素</td></tr><tr><td>[attribute~=”value”]</td><td>[title~=”flower”]</td><td>于选择包含指定单词的属性值的元素</td></tr><tr><td>[attribute|=”value”]</td><td>[class|=”top”]</td><td>用于选取带有以指定值(此处<code>top-</code>)开头的属性值的元素</td></tr><tr><td>[attribute^=”value”]</td><td>[class^=”top”]</td><td>用于选择属性值以指定值(此处<code>top</code>)<code>开始</code>的元素</td></tr><tr><td>[attribute$=”value”]</td><td>[class$=”test”]</td><td>用于选择属性值以指定值结束的元素</td></tr><tr><td>[attribute*=”value”]</td><td>[class*=”te”]</td><td>用于选择属性值包含指定值的元素</td></tr></tbody></table><h3 id="2-清除浮动（代码示例）"><a href="#2-清除浮动（代码示例）" class="headerlink" title="2. 清除浮动（代码示例）"></a>2. 清除浮动（<a target="_blank" rel="noopener" href="https://github.com/hello-astar/js/blob/master/clear-float.html">代码示例</a>）</h3><p>父元素没有设置高度，子元素浮动会导致父元素坍塌，此时内容会溢出容器外导致布局受影响。这种现象称为浮动。</p><ul><li><p>父级 div 定义 height<br>原理：父级 div 手动定义 height，就解决了父级 div 无法自动获取到高度的问题。<br>优点：简单、代码少、容易掌握<br>缺点：只适合高度固定的布局</p></li><li><p>在浮动元素后添加一个空标签<code>&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</code>，并且在CSS中设置.clear{clear:both;}，即可清理浮动。<br>官方对clear属性解释：“元素盒子的边不能和前面的浮动元素相邻”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。<br><img src="1-clear-float.png" alt="这里写图片描述"><br>原理：添加一个空标签，利用CSS提高的clear:both清除浮动，让父元素可以自动获取到高度<br>优点：简单，代码少，兼容所有浏览器<br>缺点：增加页面的标签，造成结构的混乱<br>建议：不推荐使用，此方法已经过时</p></li><li><p><strong>:after伪元素</strong><br><img src="2-clear-float.png" alt="这里写图片描述"><br>原理：通过CSS伪元素在容器的内部元素之后添加一个看不见的空格“\20”或点“.” ，并且设置clear属性清除浮动。IE8 以上和非 IE 浏览器才支持:after，原理和方法 2 有点类似，<code>*zoom</code>(IE 专有属性，IE版本的BFC（Layout），可通过 <code>*zoom:1</code> 触发)可解决ie6，ie7 浮动问题 ，推荐使用，建议定义公共类，以减少 CSS 代码<br>优点：浏览器支持较好<br>缺点：clearfix这个class需要添加<code>*zoom: 1</code>（触发haslayout,当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位），才能支持IE6和IE7浏览器<br>建议：推荐使用，设置公共类，减少CSS代码</p></li><li><p>父级元素定义：<code>overflow:auto/hidden; *zoom:1</code>，触发BFC特性。</p></li></ul><h3 id="3-盒子模型"><a href="#3-盒子模型" class="headerlink" title="3. 盒子模型"></a>3. 盒子模型</h3><ul><li>标准盒子模型（width和height属性只包含content）<br>宽度 = 内容的宽度（content）+ border + padding + margin<br>高度 = 内容的高度（content）+ border + padding + margin</li><li>低版本IE盒子模型（width和height属性包含了content、border、padding）<br>宽度 = 内容宽度（content + border + padding）+ margin<br>高度 = 内容高度（content + border + padding）+ margin</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型</p><ul><li>box-sizeing: content-box 表示标准盒模型（默认值）</li><li>box-sizeing: border-box 表示IE盒模型（怪异盒模型）</li></ul><h3 id="4-css中可以继承的样式"><a href="#4-css中可以继承的样式" class="headerlink" title="4. css中可以继承的样式"></a>4. css中可以继承的样式</h3><p>可继承的属性：font-size, font-family, color<br>不可继承的属性：border, padding, margin, width, height</p><h3 id="5-BFC（块级格式化上下文）"><a href="#5-BFC（块级格式化上下文）" class="headerlink" title="5. BFC（块级格式化上下文）"></a>5. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25321647">BFC（块级格式化上下文）</a></h3><blockquote><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p></blockquote><blockquote><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul></blockquote><blockquote><p>BFC的特点：</p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul></blockquote><h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><ul><li><p>解决margin的重叠问题（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a7ead28910f4">margin合并</a>）<br>毗邻元素处于同一BFC中，将会发生外边距合并。</p><blockquote><p>In this specification, the expression collapsing margins means that adjoining margins (no non-empty content, padding or border areas or clearance separate them) of two or more boxes (which may be next to one another or nested) combine to form a single margin. 所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套的盒元素，并且它们之间没有非空内容、Padding或Border分隔。</p></blockquote><p><a target="_blank" rel="noopener" href="https://github.com/hello-astar/js/blob/master/merge-margin.html">示例代码</a></p></li><li><p>解决高度塌陷的问题（父元素设置overflow: auto/hidden）<br>原理：计算BFC的高度时，需要计算浮动元素的高度</p></li><li><p>创建自适应两栏布局（左侧固定宽度，右侧自适应）<br>原理：BFC区域不会与浮动的容器发生重叠<br>实现方法：左侧浮动，右侧变为BFC。</p></li></ul><h3 id="6-两栏布局和三栏布局实现"><a href="#6-两栏布局和三栏布局实现" class="headerlink" title="6. 两栏布局和三栏布局实现"></a>6. 两栏布局和三栏布局实现</h3><h4 id="6-1-两栏布局"><a href="#6-1-两栏布局" class="headerlink" title="6.1 两栏布局"></a>6.1 两栏布局</h4><ul><li>左侧浮动，右侧magin-left</li><li>左侧浮动，右侧bfc(overflow: hidden)</li><li>左侧绝对定位，右侧magin-left</li><li>右侧绝对定位left: 200px</li><li>flex: 1</li></ul><h4 id="6-2-三栏布局"><a href="#6-2-三栏布局" class="headerlink" title="6.2 三栏布局"></a>6.2 三栏布局</h4><ul><li>左右侧绝对定位，中间margin</li><li>利用浮动</li><li>flex: 1</li><li>利用负margin（<a target="_blank" rel="noopener" href="https://blog.csdn.net/Tracy_frog/article/details/77509450">css布局——双飞翼布局和圣杯布局</a>）</li><li>calc</li></ul><p><a target="_blank" rel="noopener" href="https://github.com/hello-astar/js/blob/master/position.html">示例代码</a></p><h3 id="7-居中布局的实现"><a href="#7-居中布局的实现" class="headerlink" title="7. 居中布局的实现"></a>7. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/coco1s/p/4444383.html">居中布局的实现</a></h3><p>以下为简单总结：</p><ul><li>行内元素水平居中 <code>text-align: center;</code></li><li>块状元素水平居中<code>margin: 0 auto;</code></li><li>多个块状元素水平居中<br><code>1. display: inline-block; 和text-align: center;配合使用</code><br><code>2. flex布局</code></li><li>已知高度宽度元素水平垂直居中<br><code>1. 绝对定位与负margin方法</code><br><code>2. display: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;</code></li><li>未知宽度高度元素水平垂直居中<br><code>1. 将子元素改为inline或inline-block，然后设置父元素display: table-cell; text-align: center; vertical-align: middle;</code><br><code>2. translate -50%方法</code><br><code>3. flex布局</code></li></ul><h3 id="8-postion几个属性的作用？"><a href="#8-postion几个属性的作用？" class="headerlink" title="8. postion几个属性的作用？"></a>8. postion几个属性的作用？</h3><p>position 的常见四个属性值： relative，absolute，fixed，static。一般都要配合”left”、”top”、”right”以及 “bottom” 属性使用。<br>1）Static静态定位：<code>默认位置</code>，设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。一般不常用。<br>2）Relative相对定位：位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，意思就是如果设置了 relative 值，那么，它偏移的 top，right，bottom，left 的值都以它原来的位置为基准偏移，而不管其他元素会怎么样。<code>注意 relative 移动后的元素在原来的位置仍占据空间</code>。<br>3）Absolute绝对定位：位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。意思就是如果它的父容器设置了 position 属性，并且 position 的属性值为 absolute 或者relative，那么就会依据父容器进行偏移。<code>如果其父容器没有设置 position 属性，那么偏移是以 body 为依据</code>。<code>注意设置 absolute 属性的元素在标准流中不占位置</code>。<br>4）Fixed固定定位：位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。不论窗口滚动与否，元素都会留在那个位置。它始终是以 body 为依据的。 <code>注意设置 fixed 属性的元素在标准流中不占位置</code>。</p><h3 id="9-对Flex布局的理解及其使用场景"><a href="#9-对Flex布局的理解及其使用场景" class="headerlink" title="9. 对Flex布局的理解及其使用场景"></a>9. 对Flex布局的理解及其使用场景</h3><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a></p><h3 id="10-display-none与visibility：hidden的区别？"><a href="#10-display-none与visibility：hidden的区别？" class="headerlink" title="10. display:none与visibility：hidden的区别？"></a>10. display:none与visibility：hidden的区别？</h3><p>display：none 不显示对应的元素，在文档布局中不再分配空间（重排+重绘）<br>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><h3 id="11-当margin-top、padding-top的值是百分比时，分别是如何计算的？"><a href="#11-当margin-top、padding-top的值是百分比时，分别是如何计算的？" class="headerlink" title="11. 当margin-top、padding-top的值是百分比时，分别是如何计算的？"></a>11. 当margin-top、padding-top的值是百分比时，分别是如何计算的？</h3><p>对元素的margin设置百分数，是相对于<code>父元素</code>的<code>width</code>计算的，不管是margin-top/margin-bottom/margin-left还是margin-right。（padding同理）</p><h3 id="12-重排和重绘"><a href="#12-重排和重绘" class="headerlink" title="12. 重排和重绘"></a>12. 重排和重绘</h3><p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。<br>重排是更明显的一种改变，可以理解为渲染树需要重新计算。下面是常见的触发重排的操作：<br>1）DOM 元素的几何属性变化<br>2）DOM 树的结构变化<br>3）获取某些属性<br>4）此外，改变元素的一些样式，调整浏览器窗口大小等等也都将触发重排。<br>注：重排对性能有很大的影响。</p><h3 id="13-css3-html5-es6的新特性"><a href="#13-css3-html5-es6的新特性" class="headerlink" title="13. css3,html5,es6的新特性"></a>13. css3,html5,es6的新特性</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d61bf4f36235">css3新特性</a><br><a target="_blank" rel="noopener" href="https://github.com/2320390964/notes/issues/2">html5的新特性</a><br><a target="_blank" rel="noopener" href="http://imweb.io/topic/55e330d6771670e207a16bbb">es6的新特性</a><br>let/const、class、扩展运算符、rest参数、模板字符串、Set、变量的解构赋值、Symbol（一种新的原始数据类型，表示独一无二的ID，它通过Symbol函数生成）</p><h3 id="14-CSS优化、提高性能的方法有哪些？"><a href="#14-CSS优化、提高性能的方法有哪些？" class="headerlink" title="14. CSS优化、提高性能的方法有哪些？"></a>14. CSS优化、提高性能的方法有哪些？</h3><h4 id="14-1-加载性能"><a href="#14-1-加载性能" class="headerlink" title="14.1 加载性能"></a>14.1 加载性能</h4><ul><li>css包压缩，减小文件体积</li><li>css单一样式，当需要下边距和左边距的时候，很多时候会选择使用<code>margin:top 0 bottom 0;</code> 但<code>margin-bottom:bottom;margin-left:left;</code>执行效率会更高。</li><li>减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ul><h4 id="14-2-选择器性能"><a href="#14-2-选择器性能" class="headerlink" title="14.2 选择器性能"></a>14.2 选择器性能</h4><ul><li>CSS选择符是从右到左进行匹配的，所以选择器最后面部分为最关键部分，如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）</li><li>避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</li><li>尽量少的去对标签进行选择，而是用class。</li><li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则</li></ul><h4 id="14-3-渲染性能"><a href="#14-3-渲染性能" class="headerlink" title="14.3 渲染性能"></a>14.3 渲染性能</h4><ul><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li></ul><h4 id="14-4-可维护性、健壮性"><a href="#14-4-可维护性、健壮性" class="headerlink" title="14.4 可维护性、健壮性"></a>14.4 可维护性、健壮性</h4><ul><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ul><h3 id="15-link和-import的区别"><a href="#15-link和-import的区别" class="headerlink" title="15. link和@import的区别"></a>15. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="16-对-CSS-Sprites-的理解"><a href="#16-对-CSS-Sprites-的理解" class="headerlink" title="16. 对 CSS Sprites 的理解"></a>16. 对 CSS Sprites 的理解</h3><p>CSS Sprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；<br>CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；<br>CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。</p><h4 id="维护方面："><a href="#维护方面：" class="headerlink" title="维护方面："></a>维护方面：</h4><p>CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。</p><h3 id="17-px，em，rem-的区别？"><a href="#17-px，em，rem-的区别？" class="headerlink" title="17. px，em，rem 的区别？"></a>17. px，em，rem 的区别？</h3><p>1）px 像素（Pixel）。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度 DPI。<br>2）em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。<br>3）rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。<br>4）区别：IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。</p><h3 id="18-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#18-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="18. 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>18. 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h3><p>响应式网站设计(Responsive Web design)是<strong>一个网站能够兼容多个终端</strong>，而不是为每一个终端做一个特定的版本。</p><p>实现方法：@media + viewport</p><ul><li>媒体查询（@media），基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。pc端和移动端使用同一个项目，使用媒体查询实现响应式。缺点是要写很多样式，十分复杂。<br>下面简单使用媒体查询，使两栏布局在小屏设备下隐藏左侧。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 屏幕大小小于768px时候，隐藏左侧</span><br><span class="line">.left &#123;</span><br><span class="line">	display: none;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123; &#x2F;&#x2F; 屏幕大小大于等于768px时候，展示左侧</span><br><span class="line">	.left &#123;</span><br><span class="line">		display: block;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>网格和媒体查询结合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* For mobile phones: *&#x2F;</span><br><span class="line">[class*&#x3D;&quot;col-&quot;] &#123;</span><br><span class="line">	width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123;</span><br><span class="line">	&#x2F;* For desktop: *&#x2F;</span><br><span class="line">	.col-1 &#123;width: 8.33%;&#125;</span><br><span class="line">	.col-2 &#123;width: 16.66%;&#125;</span><br><span class="line">	.col-3 &#123;width: 25%;&#125;</span><br><span class="line">	.col-4 &#123;width: 33.33%;&#125;</span><br><span class="line">	.col-5 &#123;width: 41.66%;&#125;</span><br><span class="line">	.col-6 &#123;width: 50%;&#125;</span><br><span class="line">	.col-7 &#123;width: 58.33%;&#125;</span><br><span class="line">	.col-8 &#123;width: 66.66%;&#125;</span><br><span class="line">	.col-9 &#123;width: 75%;&#125;</span><br><span class="line">	.col-10 &#123;width: 83.33%;&#125;</span><br><span class="line">	.col-11 &#123;width: 91.66%;&#125;</span><br><span class="line">	.col-12 &#123;width: 100%;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>创建适应不同设备的方向(横屏landscape、竖屏portrait等)的布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果是竖屏背景将是浅蓝色：</span><br><span class="line">@media only screen and (orientation: landscape) &#123;</span><br><span class="line">	body &#123;</span><br><span class="line">		background-color: lightblue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>响应式网页设计之<strong>viewport</strong><br>Viewport 是用户网页的可视区域。<br>Viewport 随设备而异，在移动手机上比在电脑屏幕上要小。<br>在平板电脑和移动手机之前，网页只为电脑屏幕设计，网页的静态设计和固定大小是很常见的。<br>然后，当我们开始使用平板电脑和手机上网的时候，固定大小的网页太大了，不适合观看。为了解决这个问题，这些设备上的浏览器<code>缩小了整个网页</code>以适应屏幕。<br>这并不完美！但可快速修复。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0, maximum-scale&#x3D;1,user-scalable&#x3D;no&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>&lt;meta&gt; 窗口元素为浏览器提供了如何控制页面尺寸和缩放的说明。<br>width=device-width 部分将页面的宽度设置为跟随设备的屏幕宽度（其将根据设备变化而变化）。<br>initial-scale=1.0 部分设置浏览器首次加载页面时的初始缩放级别。</li></ul><h3 id="19-根据设计稿进行移动端web页面适配的方案"><a href="#19-根据设计稿进行移动端web页面适配的方案" class="headerlink" title="19. 根据设计稿进行移动端web页面适配的方案"></a>19. 根据设计稿进行移动端web页面适配的方案</h3><p>移动端适配主要有两个维度：</p><ul><li>适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li>适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>实现方案：</p><ul><li>媒体查询</li><li>flex弹性布局</li><li>rem 只用rem可以实现适配不同屏幕大小，但不能适配不同像素密度。<br>原理：<ul><li>htmlFontSize = 100 * clientWidth / baseWidth + ‘px’，则设计稿上的100px是页面上的1rem</li></ul></li><li>rem + viewport （<a target="_blank" rel="noopener" href="https://github.com/hello-astar/js/tree/master/mobileAdaptation">示例代码</a>）<br><img src="3-viewport-rem.png"><br>原理：<ul><li>viewport设置scale = 1 / dpr，页面缩小到1个css像素由1个设备像素来显示，此时clientWidth = screenWidth * dpr。</li><li>rem设置clientWidth(屏幕宽度) / baseWidth(设计稿宽度)，相当于增加css像素数量，占满设备屏幕。</li><li>字体最好使用px，考虑到使用rem会随着屏幕大小改变字体的大小，我们希望在不同屏幕上看到字体大小是一样的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	width: 1rem; </span><br><span class="line">	height: 0.4rem;</span><br><span class="line">	font-size: 12px; &#x2F;&#x2F; 默认写上dpr为1的fontSize</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr&#x3D;&quot;2&quot;] div &#123;</span><br><span class="line">		font-size: 24px;</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr&#x3D;&quot;3&quot;] div &#123;</span><br><span class="line">		font-size: 36px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>封装一个sass混合宏，提高开发效率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@mixin font-dpr($font-size)&#123;</span><br><span class="line">	font-size: $font-size;</span><br><span class="line">	[data-dpr&#x3D;&quot;2&quot;] &amp; &#123;</span><br><span class="line">		font-size: $font-size * 2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[data-dpr&#x3D;&quot;3&quot;] &amp; &#123;</span><br><span class="line">		font-size: $font-size * 3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@include font-dpr(16px);</span><br></pre></td></tr></table></figure>参考</li></ul></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/2050/p/3877280.html">移动前端开发之viewport的深入理解</a></li><li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008767416">移动端Web页面适配方案</a></li><li><a target="_blank" rel="noopener" href="http://caibaojian.com/flexible-js.html">flexible.js 布局详解</a></li></ul><h3 id="20-1px边框问题（示例代码）"><a href="#20-1px边框问题（示例代码）" class="headerlink" title="20. 1px边框问题（示例代码）"></a>20. 1px边框问题（<a target="_blank" rel="noopener" href="https://github.com/hello-astar/js/blob/master/1pxborder.html">示例代码</a>）</h3><ul><li>直接把 1px 改成 1/dpr 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</li><li>利用伪元素 + <code>transform: scale(0.5)</code>实现</li><li><code>box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);</code></li><li><code>linear-gradient</code></li><li>viewport将1px处理成物理像素大小</li></ul><h3 id="21-设置小于12px的字体"><a href="#21-设置小于12px的字体" class="headerlink" title="21. 设置小于12px的字体"></a>21. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。<br>解决办法：</p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="22-z-index属性"><a href="#22-z-index属性" class="headerlink" title="22. z-index属性"></a>22. z-index属性</h3><blockquote><p>z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指<code>同级元素</code>间的堆叠，如果两个对象的此属 性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系 的，一定是子级在上父级在下。<br>Note：使用static定位或无position定位的元素z-index属性是无效的。</p></blockquote><h3 id="23-对requestAnimationframe的理解"><a href="#23-对requestAnimationframe的理解" class="headerlink" title="23. 对requestAnimationframe的理解"></a>23. 对requestAnimationframe的理解</h3><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。<br>MDN对该方法的描述：</p><blockquote><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p></blockquote><p>语法： window.requestAnimationFrame(callback); 其中，callback是下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于宏任务，所以会在执行完微任务之后再去执行。<br>取消动画： 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p><p>优势：</p><ul><li>CPU节能：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li><li>函数节流：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li><li>减少DOM操作：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li></ul><p>setTimeout执行动画的缺点：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p><ul><li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li><li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li></ul><h3 id="24-常见的图片格式及使用场景"><a href="#24-常见的图片格式及使用场景" class="headerlink" title="24. 常见的图片格式及使用场景"></a>24. 常见的图片格式及使用场景</h3><p>（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。<br>（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。<br>（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。<br>（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。<br>（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。<br>（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。<br>（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><p>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；<br>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；<br>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</p><h3 id="25-实现宽高自适应的正方形"><a href="#25-实现宽高自适应的正方形" class="headerlink" title="25. 实现宽高自适应的正方形"></a>25. 实现宽高自适应的正方形</h3><ol><li>利用padding-top百分比是相对于父元素的width<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.square &#123;</span><br><span class="line">  width: 20%; &#x2F;&#x2F; 等于父元素width * 20%</span><br><span class="line">  height: 0;</span><br><span class="line">  padding-top: 20%; &#x2F;&#x2F; 等于父元素width * 20%</span><br><span class="line">  background: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用子元素margin-top百分比是相对于父元素的width<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.square &#123;</span><br><span class="line">  width: 30%; &#x2F;&#x2F; 等于父元素width * 30%</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  background: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.square::after &#123;</span><br><span class="line">  content: &#39;&#39;;</span><br><span class="line">  display: block;</span><br><span class="line">  margin-top: 100%; &#x2F;&#x2F; 等于父元素width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><div class="post-announce">感谢您的阅读，本文由 <a href="http://example.com">Astar</a> 版权所有。如若转载，请注明出处：Astar（<a href="http://example.com/2021/12/12/css%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89/">http://example.com/2021/12/12/css%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2021/12/12/%E6%80%9D%E8%80%83%EF%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8C%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/" title="思考：在浏览器中，输入URL回车后发生了什么？"><i class="iconfont icon-prev"></i>思考：在浏览器中，输入URL回车后发生了什么？</a></div><div class="post__prev post__prev--right"><a href="/2021/12/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="前端性能优化">前端性能优化<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="回车搜索"> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">问题排查</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%A7%84%E8%8C%83%E5%8C%96/">规范化</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">浏览器和计算机网络</a><span class="block-list-count">7</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/">微前端</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">建站</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/js/">js</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/css/">css</a><span class="block-list-count">3</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2022/02/24/css%E6%A0%B7%E5%BC%8F%E6%B2%A1%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" title="css样式没生效问题排查"><div class="item__cover"><img src="https://img2.baidu.com/it/u=3330810392,2639354941&fm=253&fmt=auto&app=138&f=JPEG?w=887&h=500" alt="css样式没生效问题排查"></div><div class="item__info"><h3 class="item__title">css样式没生效问题排查</h3><span class="item__text">2022-02-24</span></div></a></li><li class="latest-post-item"><a href="/2022/01/19/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/" title="图片懒加载的两种实现方案"><div class="item__cover"><img src="https://img2.baidu.com/it/u=4193472195,2353099366&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="图片懒加载的两种实现方案"></div><div class="item__info"><h3 class="item__title">图片懒加载的两种实现方案</h3><span class="item__text">2022-01-19</span></div></a></li><li class="latest-post-item"><a href="/2022/01/17/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90CHANGELOG%E6%8C%87%E5%8D%97/" title="前端生成CHANGELOG指南"><div class="item__cover"><img src="https://img1.baidu.com/it/u=1869297395,2506210818&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=281" alt="前端生成CHANGELOG指南"></div><div class="item__info"><h3 class="item__title">前端生成CHANGELOG指南</h3><span class="item__text">2022-01-17</span></div></a></li><li class="latest-post-item"><a href="/2022/01/14/%E4%BB%8E%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B%E6%8E%A2%E7%B4%A2JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/" title="从常见案例探索JS正则表达式用法"><div class="item__cover"><img src="https://img2.baidu.com/it/u=3493367202,2508310982&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500" alt="从常见案例探索JS正则表达式用法"></div><div class="item__info"><h3 class="item__title">从常见案例探索JS正则表达式用法</h3><span class="item__text">2022-01-14</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/css/">css</a></li><li class="tag-item"><a class="tag-link" href="/tags/js%E5%9F%BA%E7%A1%80/">js基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-item"><a class="tag-link" href="/tags/nginx/">nginx</a></li><li class="tag-item"><a class="tag-link" href="/tags/qiankun/">qiankun</a></li><li class="tag-item"><a class="tag-link" href="/tags/shell/">shell</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%85%BC%E5%AE%B9ie/">兼容ie</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">平衡二叉树</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/">最长无重复子串</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0js/">模拟实现js</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/">渲染机制</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/">自动部署</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%A7%84%E8%8C%83%E5%8C%96/">规范化</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%B7%A8%E5%9F%9F/">跨域</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">问题排查</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于Hexo搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>ShenZhen, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>2320390964@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/qrcode.jpg" alt="logo" title="Astar"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["css"],gitalk=new Gitalk({clientID:"f75b0e86fdac67670255",clientSecret:"ec0d30e74282751b50189f8554788c36de21c86a",repo:"hello-astar.github.io",owner:"hello-astar",admin:["hello-astar"],labels:tags,id:new Date(1639318693e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>