<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>javascript基础篇（汇总） | Astar's Blog</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Astar"><meta name="designer" content="minfive"><meta name="keywords" content="astar, astar blog, 前端, 前端开发, 全栈开发, javascript, node.js, 程序员, web"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="canonical" href="http://example.com/2021/12/12/javascript%E5%9F%BA%E7%A1%80%E7%AF%87/index.html"><link rel="icon" type="image/png" href="/img/avatar.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Astar" type="application/atom+xml"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 5.3.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Astar" alt="Astar"><img src="/img/avatar.jpg" alt="Astar"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"></div><header class="post__info"><h1 class="post__title">javascript基础篇（汇总）</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="https://github.com/hello-astar">Astar</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2021-12-12</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/js%E5%9F%BA%E7%A1%80/">Js基础</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><ol><li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ea85cd730b62">for … in … 和hasOwnProperty</a></p></li><li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000005654451">事件冒泡和事件捕获</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;s1&quot;&gt;s1</span><br><span class="line">    &lt;div id&#x3D;&quot;s2&quot;&gt;s2&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">s1.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">        console.log(&quot;s1 冒泡事件&quot;);         </span><br><span class="line">&#125;,false);</span><br><span class="line">s2.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">        console.log(&quot;s2 冒泡事件&quot;);</span><br><span class="line">&#125;,false);</span><br><span class="line">        </span><br><span class="line">s1.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">        console.log(&quot;s1 捕获事件&quot;);</span><br><span class="line">&#125;,true);</span><br><span class="line">        </span><br><span class="line">s2.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">        console.log(&quot;s2 捕获事件&quot;);</span><br><span class="line">&#125;,true);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>当我们点击s2的时候,执行结果如下:<br>s1捕获事件-&gt; s2冒泡事件 -&gt; s2捕获事件 -&gt; s1冒泡事件</p><p>这里大体分析下执行结果</p><ol><li>点击s2，click事件从document-&gt;html-&gt;body-&gt;s1-&gt;s2(捕获前进)<br>这里在s1上发现了捕获注册事件，则输出”s1 捕获事件”</li><li>到达s2，已经到达目的节点，s2上注册了冒泡和捕获事件，先注册的冒泡后注册的捕获，则先执行冒泡，输出”s2 冒泡事件”</li><li>再在s2上执行后注册的事件，即捕获事件，输出”s2 捕获事件”</li><li>下面进入冒泡阶段，按照s2-&gt;s1-&gt;body-&gt;html-&gt;documen(冒泡前进),在s1上发现了冒泡事件，则输出”s1 冒泡事件”</li></ol></li><li><p><strong>事件委托</strong><br>利用事件冒泡和事件捕获的特点，我们可以使用事件委托减少事件处理函数的绑定数量。<br>好处： 1. 减少事件注册；2. 新增子对象无需再次绑定事件，对我们动态增加子元素的时候很友好。<br>用法：利用事件冒泡原理 =&gt; 父元素进行事件响应=&gt; 通过e.target可以找到子元素<br>假设有以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul id&#x3D;&quot;s1&quot; style&#x3D;&quot;background: red; padding: 20px;&quot;&gt;</span><br><span class="line">      &lt;li&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 分别点击item获取其value</span><br><span class="line">var list &#x3D; document.getElementById(&#39;s1&#39;).getElementsByTagName(&#39;li&#39;);</span><br><span class="line">Array.prototype.forEach.call(list, element &#x3D;&gt; &#123;</span><br><span class="line">  element.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.target.innerText)</span><br><span class="line">&#125;, true)</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>我们可以使用事件代理进行优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul id&#x3D;&quot;s1&quot; style&#x3D;&quot;background: red; padding: 20px;&quot;&gt;</span><br><span class="line">      &lt;li data-index&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li data-index&#x3D;&quot;2&quot;&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li data-index&#x3D;&quot;3&quot;&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 分别点击item获取其value</span><br><span class="line">var s1 &#x3D; document.getElementById(&#39;s1&#39;);</span><br><span class="line">s1.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  if (e.target.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;) &#123;</span><br><span class="line">    console.log(e.target.innerText, e.target.dataset.index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。</p></blockquote></li><li><p><strong>节流throttle和防抖debounce</strong></p></li></ol><ul><li>节流：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。<br>常用场景：监听滚动事件判断滚动是否到底部，若不使用节流，则会触发很多次判断，我们使用节流，每500ms只触发一次判断，极大优化性能。</li><li>防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</li><li>常用场景：输入框监听用户输入，获取用户输入内容调用后台接口。若直接使用input事件，用户还没打完字就多次调用接口，造成服务器压力过大。使用防抖，用户输入后500ms再次触发input事件，则再等500ms，直到500ms内无新输入，发送数据至服务器端。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function debounce (fn, delay &#x3D; 300) &#123;</span><br><span class="line">  var timeout &#x3D; 0;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    timeout &#x3D; setTimeout(fn.bind(this, ...arguments), delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throttle (fn, delay &#x3D; 300) &#123;</span><br><span class="line">  var last &#x3D; 0;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var now &#x3D; +new Date();</span><br><span class="line">    if (!last || now &gt;&#x3D; last + delay) &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">      last &#x3D; now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>throttle优化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function throttle (fn, delay &#x3D; 300) &#123;</span><br><span class="line">  var last &#x3D; 0;</span><br><span class="line">  var timeout &#x3D; 0</span><br><span class="line">  return function () &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    var now &#x3D; +new Date();</span><br><span class="line">    if (!last || now &gt;&#x3D; last + delay) &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">      last &#x3D; now;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timeout &#x3D; setTimeout(fn.bind(this, ...arguments), delay); &#x2F;&#x2F; 确保最后再调用一次函数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/caizhenbo/p/6679478.html">DOMContentLoaded和load的区别</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuhe688/p/5891273.html">变量和函数提升（函数声明的优先级最高）</a></p></li><li><p><strong>定义函数时用 var foo = function () {} 和 function foo() 有什么区别？</strong><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19878052">https://www.zhihu.com/question/19878052</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coco1s/p/3959927.html">https://www.cnblogs.com/coco1s/p/3959927.html</a></p></li><li><p><strong>延长作用域链（with、try-catch）</strong><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a9e3a605f4ab">https://www.jianshu.com/p/a9e3a605f4ab</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868200385680e8cf932dba9433ea367de9aba2b4784000">面向对象思想（OOP）</a></p><blockquote><p>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student：<br>所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。<br>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法</p></blockquote></li></ol><ol start="10"><li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphinX/p/3280876.html">作用域链</a><br>作用： 保证对执行环境有权访问的所有变量和函数的<strong>有序</strong>访问。（标识符解析是沿着作用域链一级一级地搜索标识符的过程）</p></li><li><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">闭包</a><br>意义：1.从函数外部读取函数内部声明的变量。</p></li><li><p>让被读取的变量的值始终保持在<strong>内存</strong>中。（由于闭包会使得函数中的变量都被保存在内存中，<strong>内存消耗很大</strong>，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致<strong>内存泄露</strong>。解决方法是，在退出函数之前，将不使用的局部变量全部删除。）<br>实现方法：在函数内部再定义一个函数然后return出去！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	　function f1()&#123;</span><br><span class="line">	　　　　var n&#x3D;999;</span><br><span class="line">	　　　　function f2()&#123;</span><br><span class="line">	　　　　　　alert(n); </span><br><span class="line">	　　　　&#125;</span><br><span class="line">	　　　　return f2;</span><br><span class="line">	　　&#125;</span><br><span class="line">	　　var result&#x3D;f1();</span><br><span class="line">	　　result(); &#x2F;&#x2F; 999</span><br></pre></td></tr></table></figure><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	　function f1()&#123;</span><br><span class="line">	</span><br><span class="line">	　　　　var n&#x3D;999;</span><br><span class="line">	</span><br><span class="line">	　　　　nAdd&#x3D;function()&#123;n+&#x3D;1&#125;</span><br><span class="line">	</span><br><span class="line">	　　　　function f2()&#123;</span><br><span class="line">	　　　　　　alert(n);</span><br><span class="line">	　　　　&#125;</span><br><span class="line">	</span><br><span class="line">	　　　　return f2;</span><br><span class="line">	</span><br><span class="line">	　　&#125;</span><br><span class="line">	</span><br><span class="line">	　　var result&#x3D;f1();</span><br><span class="line">	</span><br><span class="line">	　　result(); &#x2F;&#x2F; 999</span><br><span class="line">	</span><br><span class="line">	　　nAdd();</span><br><span class="line">	</span><br><span class="line">	　　result(); &#x2F;&#x2F; 1000</span><br></pre></td></tr></table></figure><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在<strong>内存</strong>中，并没有在f1调用后被自动清除。<br>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。<br>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p></li><li><p><strong>使用闭包定义私有变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function ProV () &#123;</span><br><span class="line">	var name;</span><br><span class="line"> </span><br><span class="line">	this.setName &#x3D; function (value) &#123;</span><br><span class="line">		name &#x3D; value;</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">	this.getName &#x3D; function () &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var p &#x3D; new ProV(); &#x2F;&#x2F;定义ProV的实例对象</span><br><span class="line">p.setName(&quot;Tom&quot;);</span><br><span class="line"> </span><br><span class="line">console.log(p.name); &#x2F;&#x2F;undefined 对象p的name是私有变量，不能直接访问。</span><br><span class="line">console.log(p.getName()); &#x2F;&#x2F;Tom</span><br></pre></td></tr></table></figure></li><li><p><strong>setTimeout函数之循环和闭包</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/huakaiwuxing/article/details/78968642">https://blog.csdn.net/huakaiwuxing/article/details/78968642</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e5225ba4a025">https://www.jianshu.com/p/e5225ba4a025</a></p></li><li><p><strong>call、apply和bind的区别</strong></p></li></ol><ul><li>call和apply是为了改变函数运行时的上下文而存在的，不同的是使用apply时函数参数以数组形式传参，而使用call时函数参数以单独形式传参。注意call和apply方法都会使函数立即执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func.call(this, arg1,arg2,...)</span><br><span class="line">func.apply(this, [arg1,arg2,...])</span><br></pre></td></tr></table></figure><a target="_blank" rel="noopener" href="https://github.com/lin-xin/blog/issues/7">https://github.com/lin-xin/blog/issues/7</a></li><li>bind()方法会创建一个新函数，称为绑定函数，传入this可以修改该函数的上下文，原函数的上下文没有改变，多次调用bind()方法是无效的。<br>bind()本身可以带函数参数，而调用绑定函数时候带的参数则是在 <strong>bind 中参数的基础上再往后排</strong>。</li><li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代理console.log</span><br><span class="line">function log() &#123;</span><br><span class="line">	console.log.apply(console, arguments)</span><br><span class="line">	&#125;</span><br><span class="line">log(1,2) &#x2F;&#x2F; 1,2</span><br><span class="line">log(1) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure></li></ul><ol start="15"><li><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5903018cac502e0063d92127">arguments对象</a></p><blockquote><p>ES6中的箭头函数没有自己的 arguments 对象，不过在大多数情形下，rest参数可以给出一个解决方案：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">const fn &#x3D; () &#x3D;&gt; Array.prototype.slice.call(arguments);</span><br><span class="line">a &#x3D; fn(1, 2); &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/72a590f59f4f">arguments.callee</a><br>好处: 自己调用自己的时候去除函数名的耦合性。</p><blockquote><p>现在已经不推荐使用arguments.callee(),访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。</p></blockquote></li><li><p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/11">call和apply的模拟实现</a></p></li><li><p><strong>apply实现bind</strong><br>ie8不兼容bind，但兼容apply和call<br>准备知识：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ae57baecc57d">关于[ ].slice.call()</a></p></li></ol><p><strong>简单版</strong>=&gt;实现改变this指向以及传参<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; function(context)&#123;</span><br><span class="line">    &#x2F;&#x2F;保存this，也就是调用bind的那个函数</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);&#x2F;&#x2F; arguments没有数组的slice方法，此方法可以把传进来的参数变为数组 &#x2F;&#x2F; 第二个参数为1，剔除context</span><br><span class="line">    return function()&#123;</span><br><span class="line">        &#x2F;&#x2F;将第一次的参数与此次传入的参数合并，调用self函数</span><br><span class="line">        return self.apply(context,args.concat([].slice.call(arguments)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59093b1fa0bb9f006517b906#comment">从简单版进阶到优化版</a><p></p><ol start="18"><li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013911763">JavaScript之this指向</a><br>当一个函数作为函数而不是方法来调用的时候，this指向的是全局对象</p></li><li><p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/2">原型和原型链</a></p><blockquote><p>在读取对象的属性时候，首先查找自身的属性。如果没有找到，则会进一步查找构造函数的prototype对象的属性。这就是原型链的基本原理。这样一来，在通过构造函数生成的对象之间就实现了对其prototype对象的<strong>属性的共享</strong>。<br>这种共享用面向对象的术语来说就是继承。通过继承可以生成具有同样执行方式的对象，不过请注意，如果修改构造函数的prototype，<strong>已经生成的对象</strong>也会发生相应的改变。</p></blockquote></li></ol><p><a target="_blank" rel="noopener" href="http://zencode.in/2.Javascript%E5%8E%9F%E5%9E%8B%E9%93%BE.html">Javascript 原型链</a><br><img src="https://img-blog.csdnimg.cn/img_convert/ab4674a4df3a390fc87200ab4cb0ba92.png" alt="扩展版"></p><ol start="20"><li><p>输出顺序-考察变量提升、原型链、运算符优先级<br>答案是 2 4 1 1 2 3 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line"> getName &#x3D; function () &#123; console.log(1); &#125;;</span><br><span class="line"> return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function () &#123; console.log(2);&#125;;</span><br><span class="line">Foo.prototype.getName &#x3D; function () &#123; console.log(3);&#125;;</span><br><span class="line">var getName &#x3D; function () &#123; console.log(4);&#125;;</span><br><span class="line">function getName() &#123; console.log(5);&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请写出以下输出结果：</span><br><span class="line">Foo.getName();  &#x2F;&#x2F; 函数属性</span><br><span class="line">getName();  &#x2F;&#x2F; 变量提升</span><br><span class="line">Foo().getName();  &#x2F;&#x2F; 调用Foo时， window上的getName变成1</span><br><span class="line">getName(); </span><br><span class="line">new Foo.getName(); </span><br><span class="line">new Foo().getName(); &#x2F;&#x2F; new的时候返回实例，查找到原型链上有getName </span><br><span class="line">new new Foo().getName();  &#x2F;&#x2F; .运算符的优先级大于new</span><br></pre></td></tr></table></figure></li><li><p><strong>instance运算与isPrototypeOf方法</strong>虽然也可以用constructor属性来判断对象类型，不过更为常见的做法是使用instanceof运算来进行判断。对于通过原型链进行派生继承的情况，instanceof运算也是有效的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; new Date()</span><br><span class="line">d instanceof Date &#x2F;&#x2F; true</span><br><span class="line">d instanceof Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">function Derived() &#123;&#125;</span><br><span class="line">function Base() &#123;&#125;</span><br><span class="line">Derived.prototype &#x3D; new Base()</span><br><span class="line">var obj &#x3D; new Derived()</span><br><span class="line">obj instanceof Derived &#x2F;&#x2F; true</span><br><span class="line">obj instanceof Base &#x2F;&#x2F; true</span><br><span class="line">obj instanceof Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">Derived.prototype.isPrototypeOf(obj) &#x2F;&#x2F; true</span><br><span class="line">Base.prototype.isPrototypeOf(obj) &#x2F;&#x2F; true</span><br><span class="line">Object.prototype.isPrototypeOf(obj) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么在JavaScript中“Object instanceof Function”和“Function instanceof Object”都返回true？</strong><br><a target="_blank" rel="noopener" href="https://codeday.me/bug/20171204/102055.html">https://codeday.me/bug/20171204/102055.html</a><br>instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的<strong>原型链上</strong>（<code>__proto__</code>）即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; AAA.prototype</span><br><span class="line">Object.getPrototypeOf(Object.getPrototypeOf(obj)) &#x3D;&#x3D;&#x3D; AAA.prototype</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;一直到原型链尽头</span><br></pre></td></tr></table></figure></li><li><p><strong>关于constructor</strong><br>可以通过constructor属性来从对象处获取其构造函数，constructor不是对象的直接属性，而是通过原型链查找到的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">function B() &#123;&#125;</span><br><span class="line">A.prototype &#x3D; new B()</span><br><span class="line">var obj &#x3D; new A()</span><br><span class="line">obj.constructor &#x2F;&#x2F; function B()&#123;&#125;</span><br><span class="line">A.prototype.constructor &#x3D; A</span><br><span class="line">obj.constructor &#x2F;&#x2F; function A() &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>js实现继承的几种方式以及优缺点</strong><br><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/16">JavaScript深入之继承的多种方式和优缺点</a></p></li><li><p><strong>js创建对象的7种方式及其优缺点</strong><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/58291447128fe1005cd41c52">JavaScript 创建对象的 7 种方法</a></p></li><li><p><strong>new创建对象过程发生了什么</strong><br>创建新对象person={}<br>新对象的__proto__属性指向构造函数的原型对象<br>构造函数的this指向新对象<br>执行构造函数内部代码，给person（this）添加属性<br>返回新对象person</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function new2 (func, ...rest) &#123;</span><br><span class="line">	var o&#x3D; &#123;&#125;;</span><br><span class="line">	o._proto_ &#x3D; Person.prototype; &#x2F;&#x2F;引用构造函数的原型对象</span><br><span class="line">	func.apply(person, rest);</span><br><span class="line">	return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/h15882065951/article/details/69913881">https://blog.csdn.net/h15882065951/article/details/69913881</a></p></li><li><p><strong>判断变量类型</strong></p></li></ol><ul><li>typeof<br>typeof 可以判断number, string, object, boolean, function, undefined, symbol 这七种类型，但是，很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; new String(&#39;abc&#39;);</span><br><span class="line">typeof s &#x3D;&#x3D;&#x3D; &#39;object&#39;&#x2F;&#x2F; true</span><br><span class="line">s instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li>instanceof<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 缺点</span><br><span class="line">[] instanceof Array &#x2F;&#x2F; true</span><br><span class="line">[] instanceof Object &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li>Object.prototype.toString.call可以比较准确判断类型<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b0b9b9051882515773ae714">https://juejin.im/post/5b0b9b9051882515773ae714</a></li></ul><ol start="28"><li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aa2b26b518825556020873f">关于Ajax</a></p></li><li><p><strong>js数组常见方法</strong><br>slice(生成新数组)、splice（在原数组上操作）、concat（新数组）、shift（从原数组删除第一个元素）、unshift（从原数组头部增加元素）、pop（删除最后一个元素）、map（遍历，return的数值组成新数组）、reduce（遍历，return的数值参与到遍历中，最后返回结果）、filter（return值为true时加入新数组）、join（转为字符串）<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/picaso/archive/2012/05/24/2517100.html">slice和splice的区别</a></p></li><li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5949d85f61ff4b006c0de98b#heading-7">数组去重</a><br>object键值对+filter<br>考虑键值对的key为字符串类型，object[typeof item + item]=true<br>object[‘1’] 和 object[1]相同，使用typeof区分。</p></li><li><p><strong>DOM操作</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22944825/article/details/78047070">https://blog.csdn.net/qq_22944825/article/details/78047070</a><br>parentElement、children（数组）、removeChild、innerHTML、firstElementChild、lastElementChild、nextElementSibling、previousElementSibling等等</p></li><li><p><strong>跨域处理</strong><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111669476">图像ping</a></p><blockquote><p>相类似的，由于img标签也是不受跨域约束。但是需要注意的是图像PING和JSONP的区别。<br>图像ping的数据是通过查询字符串的形式发送的，而响应可以是任意内容，而通常是图或者204响应。通过图像ping，浏览器得不到任何具体的数据，但可以通过侦听onload和error事件知道响应是什么时候接收到的，利用这一特性，图像ping非常适合跟踪用户点击或动态广告曝光次数.</p></blockquote><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html">JSONP</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jian_xi/article/details/66472870">JSONP优缺点</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jian_xi/article/details/66474717">JSONP安全防范</a>-decodeURIComponent防止XSS漏洞<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/joyhen/article/details/21631833">前端解决跨域问题的8种方案（最新最全）</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012469713#articleHeader11">ajax跨域，这应该是最全的解决方案了</a></p></li><li><p><strong>箭头函数的this指向</strong><br>“箭头函数”的this，总是指向定义时所在的对象，而不是运行时所在的对象。“箭头函数”的this，总是指向定义时所在的对象，而不是运行时所在的对象。（封闭词法上下文）<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015087728">https://segmentfault.com/a/1190000015087728</a><br>不能做构造函数：因为没有自己的this<br>call和apply无效<br>没有prototype<br>不适用于作为对象的方法</p></li><li><p><strong>异步同步加载javascript(堵塞和非堵塞)</strong><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/055b0ea0d03c">https://www.jianshu.com/p/055b0ea0d03c</a></p><blockquote><p>异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。</p></blockquote></li><li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39579242/article/details/81509661">匿名函数</a></p><blockquote><p>匿名函数，仅在调用时，才临时创建函数对象和作用域链对象；调用完，立即释放，所以匿名函数比非匿名函数更节省内存空间</p></blockquote></li><li><p><strong>关于es6</strong><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59c8aec0f265da065c5e965e">https://juejin.im/post/59c8aec0f265da065c5e965e</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengxiongZz/p/8191503.html">https://www.cnblogs.com/fengxiongZz/p/8191503.html</a></p></li><li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNzQ2ODEyMQ==&mid=2247486440&idx=1&sn=913290153adb600e063fc8a6efc57c24&chksm=9b7ceedeac0b67c888e25c8ca0f1de69d79bf82b88fad5075b32e90c3d27ab6003472fee1a68&mpshare=1&scene=24&srcid=0903fa2akeYTzpiKt3v3nugR&sharer_sharetime=1599094364860&sharer_shareid=fbf943ecb6bb30f0acd02fd096061a3a#rd">实现一个promise</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">const PENDING &#x3D; &#39;pending&#39;;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Promiseh (fn) &#123;</span><br><span class="line">  let self &#x3D; this;</span><br><span class="line">  self.value &#x3D; null;</span><br><span class="line">  self.error &#x3D; null;</span><br><span class="line">  self.status &#x3D; PENDING;</span><br><span class="line">  self.onFulfilled &#x3D; [];</span><br><span class="line">  self.onRejected &#x3D; [];</span><br><span class="line"></span><br><span class="line">  function resolve (value) &#123;</span><br><span class="line">    if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        self.status &#x3D; FULFILLED;</span><br><span class="line">        self.value &#x3D; value;</span><br><span class="line">        self.onFulfilled.forEach(onFulfilled &#x3D;&gt; &#123;</span><br><span class="line">          onFulfilled(self.value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject (error) &#123;</span><br><span class="line">    if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        self.status &#x3D; REJECTED;</span><br><span class="line">        self.error &#x3D; error;</span><br><span class="line">        self.onRejected.forEach(onRejected &#x3D;&gt; &#123;</span><br><span class="line">          onRejected(self.error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promiseh.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    let self &#x3D; this;</span><br><span class="line">    let bridgePromise &#x3D; null;</span><br><span class="line">    onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : value &#x3D;&gt; value</span><br><span class="line">    onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : error &#x3D;&gt; &#123; throw error; &#125;</span><br><span class="line"></span><br><span class="line">    if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      return bridgePromise &#x3D; new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        self.onFulfilled.push((value) &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let x &#x3D; onFulfilled(value);</span><br><span class="line">            resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        self.onRejected.push(error &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let x &#x3D; onRejected(error);</span><br><span class="line">            resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else if (self.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;</span><br><span class="line">      return bridgePromise &#x3D; new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; onFulfilled(self.value);</span><br><span class="line">          resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line"></span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return bridgePromise &#x3D; new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; onRejected(self.error);</span><br><span class="line">          resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Promiseh.prototype.catch &#x3D; function (onRejected) &#123;</span><br><span class="line">  return this.then(null, onRejected);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 一直到promise调用的最后一个才返回</span><br><span class="line">function resolvePromise (bridgePromise, x, resolve, reject) &#123;</span><br><span class="line">  if (x instanceof Promiseh) &#123; &#x2F;&#x2F; 函数返回值为promise</span><br><span class="line">    if (x.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      x.then(y &#x3D;&gt; &#123;</span><br><span class="line">        resolvePromise(bridgePromise, y, resolve, reject);</span><br><span class="line">      &#125;, error &#x3D;&gt; &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      x.then(resolve, reject); &#x2F;&#x2F; 执行结束直接把resolve和reject传进去</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;88&#39;);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;).then(aa &#x3D;&gt; &#123;</span><br><span class="line">  console.log(aa, &#39;hhhh&#39;)</span><br><span class="line">  return 99</span><br><span class="line">&#125;).then(bb &#x3D;&gt; &#123;</span><br><span class="line">  console.log(bb, &#39;hhhh&#39;)</span><br><span class="line">  return new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      reject(100);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(d &#x3D;&gt; &#123;</span><br><span class="line">  console.log(d ,&#39;kkk&#39;)</span><br><span class="line">&#125;, d &#x3D;&gt; &#123;</span><br><span class="line">  console.log(d, dd)</span><br><span class="line">&#125;).catch(e &#x3D;&gt; &#123;</span><br><span class="line">  console.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903968292749319#heading-0">事件循环eventLoop</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&#39;script start&#39;)</span><br><span class="line">  new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;promise1&#39;)</span><br><span class="line">  &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;promise1 then&#39;)</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;settimeout4&#39;)</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(&#39;script will end&#39;)</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;settimeout1&#39;)</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;settimeout3&#39;)</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&#39;script end&#39;)</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;settimeout2&#39;)</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&#39;last script&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>解析</code><br>script标签属于宏任务，所以当前队列三个宏任务</p><ol><li>执行第一个宏任务script，输出—<code>script start</code>, 存储一个微任务then</li><li>输出—<code>script will end</code>, 存储两个宏任务settimeout1和settimeout3</li><li>下一个宏任务script执行前，必须清空微任务队列，输出—<code>promise1 then</code>, 存储宏任务settimeout4</li><li>没有微任务了，查看宏任务队列，排在前面的是第二个script标签，输出—<code>script end</code>, 存储宏任务settimeout2</li><li>执行下一个宏任务，输出—<code>last script</code></li><li>依次执行剩下的宏任务，输出<code>settimeout1</code>、<code>settimeout3</code>、<code>ettimeout4</code>、<code>settimeout2</code></li></ol></li></ol><p><strong>node.js的事件循环</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">  &#125;);</span><br><span class="line">  new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(7);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(8);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(6);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(9);</span><br><span class="line">  process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(10);</span><br><span class="line">  &#125;);</span><br><span class="line">  new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(12);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>答案 node &lt;11:1 7 6 8 2 4 9 11 3 10 5 12 node&gt;=11:1 7 6 8 2 4 3 5 9 11 10 12</code></p><p>解析<br><strong>宏任务和微任务</strong><br>宏任务：macrotask,包括setTimeout、setInerVal、setImmediate(node独有)、requestAnimationFrame(浏览器独有)、I/O、UI rendering(浏览器独有)<br>微任务：microtask,包括process.nextTick(Node独有)、Promise.then()、Object.observe、MutationObserver<br>Promise构造函数中的代码是同步执行的，new Promise()构造函数中的代码是同步代码，并不是微任务</p><p><strong>Node.js中的EventLoop执行宏队列的回调任务有6个阶段</strong><br>1.timers阶段：这个阶段执行setTimeout和setInterval预定的callback<br>2.I/O callback阶段：执行除了close事件的callbacks、被timers设定的callbacks、setImmediate()设定的callbacks这些之外的callbacks<br>3.idle, prepare阶段：仅node内部使用<br>4.poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里<br>5.check阶段：执行setImmediate()设定的callbacks<br>6.close callbacks阶段：执行socket.on(‘close’, ….)这些callbacks<br><strong>NodeJs中宏队列主要有4个</strong><br>1.Timers Queue<br>2.IO Callbacks Queue<br>3.Check Queue<br>4.Close Callbacks Queue<br>这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。<br><strong>NodeJS中微队列主要有2个</strong><br>1.Next Tick Queue：是放置process.nextTick(callback)的回调任务的<br>2.Other Micro Queue：放置其他microtask，比如Promise等<br>在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。<br><strong>Node.js中的EventLoop过程</strong><br>1.执行全局Script的同步代码<br>2.执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务<br>3.开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，<strong>每一个阶段的macrotask任务</strong>执行完毕后，开始执行微任务，也就是步骤2<br>4.Timers Queue -&gt; 步骤2 -&gt; I/O Queue -&gt; 步骤2 -&gt; Check Queue -&gt; 步骤2 -&gt; Close Callback Queue -&gt; 步骤2 -&gt; Timers Queue ……<br>5.这就是Node的Event Loop<br><strong>Node 11.x新变化</strong><br>现在node11在timer阶段的setTimeout,setInterval…和在check阶段的immediate都在node11里面都修改为一旦<strong>执行一个阶段里的一个任务就立刻执行微任务队列</strong>。为了和浏览器更加趋同.</p><ol start="39"><li><strong>indexedDB（数据库，大部分浏览器不支持）、userData（只有ie支持）、flash cookie、 http cookie（cookie）、session storage（浏览器会话）、local storage（永久）</strong><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004743454#articleHeader2">cookie篇</a><blockquote><p>document.cookie = “name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]”</p></blockquote></li></ol><blockquote><p>我们知道 cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，浏览器就会在本地硬盘上查找与该 URL 相关联的 Cookie。如果该 Cookie 存在，浏览器就将它添加到request header的Cookie字段中，与http请求一起发送到该站点。</p></blockquote><blockquote><p>当然，用户也可以通过expries设置删除时间。这个值是个GMT格式的日期，类似例三中的Sat, 04 Nov 2017 16:00:00 GMT，这表明这个 cookie 将在2017-11-04的16时整失效，在此期间浏览器关闭后此cookie仍会保存在用户的机器中。GMT格式可以通过 toGMTString() 和 toUTCString() 获得。如果设置的失效时间是个以前的时间，则 cookie 会被立即删除，这也是用来删除 cookie 的方法。<br>在新的http协议中已经使用 max-age 属性来取代 expries。expries 表示的是失效时间，准确讲是「时刻」，max-age表示的是生效的「时间段」，以「秒」为单位。若 max-age 为正值，则表示 cookie 会在 max-age 秒后失效。如例四中设置”max-age=10800;”，也就是生效时间是3个小时，那么 cookie 将在三小时后失效。若 max-age 为负值，则cookie将在浏览器会话结束后失效，即 session，max-age的默认值为-1。若 max-age 为0，则表示删除cookie。</p></blockquote><ol start="40"><li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903929705136141">如何写出一个惊艳面试官的深拷贝?</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cfd0fa90b4d1">离线应用</a></p></li><li><p><strong>其他</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/SinceroTu/article/details/78055278">js前端面试题总结及答案</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xixi880928/article/details/78842689">腾讯面试题集锦</a></p></li></ol><div class="post-announce">感谢您的阅读，本文由 <a href="http://example.com">Astar</a> 版权所有。如若转载，请注明出处：Astar（<a href="http://example.com/2021/12/12/javascript%E5%9F%BA%E7%A1%80%E7%AF%87/">http://example.com/2021/12/12/javascript%E5%9F%BA%E7%A1%80%E7%AF%87/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2021/12/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="排序算法"><i class="iconfont icon-prev"></i>排序算法</a></div><div class="post__prev post__prev--right"><a href="/2021/12/12/%E6%80%9D%E8%80%83%EF%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8C%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/" title="思考：在浏览器中，输入URL回车后发生了什么？">思考：在浏览器中，输入URL回车后发生了什么？<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="回车搜索"> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">问题排查</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%A7%84%E8%8C%83%E5%8C%96/">规范化</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">浏览器和计算机网络</a><span class="block-list-count">7</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/">微前端</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">建站</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/js/">js</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/css/">css</a><span class="block-list-count">3</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2022/03/25/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/" title="常用git命令"><div class="item__cover"><img src="https://tse1-mm.cn.bing.net/th/id/R-C.47f1d668ae1c74d288e0cb0e822be203?rik=5R%2fXOkoiMWDLKA&riu=http%3a%2f%2fn.sinaimg.cn%2fsinakd20210215ac%2f790%2fw1539h851%2f20210215%2f8e28-kkciesq4857453.png&ehk=6LzXs%2fY4r%2bPpUrQQzgdKSNCNkTFwWg%2bMIRjlJ9BH1Ik%3d&risl=&pid=ImgRaw&r=0" alt="常用git命令"></div><div class="item__info"><h3 class="item__title">常用git命令</h3><span class="item__text">2022-03-25</span></div></a></li><li class="latest-post-item"><a href="/2022/02/24/css%E6%A0%B7%E5%BC%8F%E6%B2%A1%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" title="css样式没生效问题排查"><div class="item__cover"><img src="https://img2.baidu.com/it/u=3330810392,2639354941&fm=253&fmt=auto&app=138&f=JPEG?w=887&h=500" alt="css样式没生效问题排查"></div><div class="item__info"><h3 class="item__title">css样式没生效问题排查</h3><span class="item__text">2022-02-24</span></div></a></li><li class="latest-post-item"><a href="/2022/01/19/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/" title="图片懒加载的两种实现方案"><div class="item__cover"><img src="https://img2.baidu.com/it/u=4193472195,2353099366&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="图片懒加载的两种实现方案"></div><div class="item__info"><h3 class="item__title">图片懒加载的两种实现方案</h3><span class="item__text">2022-01-19</span></div></a></li><li class="latest-post-item"><a href="/2022/01/17/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90CHANGELOG%E6%8C%87%E5%8D%97/" title="前端生成CHANGELOG指南"><div class="item__cover"><img src="https://img1.baidu.com/it/u=1869297395,2506210818&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=281" alt="前端生成CHANGELOG指南"></div><div class="item__info"><h3 class="item__title">前端生成CHANGELOG指南</h3><span class="item__text">2022-01-17</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/css/">css</a></li><li class="tag-item"><a class="tag-link" href="/tags/git/">git</a></li><li class="tag-item"><a class="tag-link" href="/tags/js%E5%9F%BA%E7%A1%80/">js基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-item"><a class="tag-link" href="/tags/nginx/">nginx</a></li><li class="tag-item"><a class="tag-link" href="/tags/qiankun/">qiankun</a></li><li class="tag-item"><a class="tag-link" href="/tags/shell/">shell</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%85%BC%E5%AE%B9ie/">兼容ie</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">平衡二叉树</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/">最长无重复子串</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0js/">模拟实现js</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/">渲染机制</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/">自动部署</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%A7%84%E8%8C%83%E5%8C%96/">规范化</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%B7%A8%E5%9F%9F/">跨域</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">问题排查</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于Hexo搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>ShenZhen, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>2320390964@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/qrcode.jpg" alt="logo" title="Astar"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["js基础"],gitalk=new Gitalk({clientID:"f75b0e86fdac67670255",clientSecret:"ec0d30e74282751b50189f8554788c36de21c86a",repo:"hello-astar.github.io",owner:"hello-astar",admin:["hello-astar"],labels:tags,id:new Date(163931342e4).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>