<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>前端性能优化 | Astar's Blog</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Astar"><meta name="designer" content="minfive"><meta name="keywords" content="astar, astar blog, 前端, 前端开发, 全栈开发, javascript, node.js, 程序员, web"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="canonical" href="http://example.com/2021/12/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html"><link rel="icon" type="image/png" href="/img/avatar.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Astar" type="application/atom+xml"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 5.3.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Astar" alt="Astar"><img src="/img/avatar.jpg" alt="Astar"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"></div><header class="post__info"><h1 class="post__title">前端性能优化</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="https://github.com/hello-astar">Astar</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2021-12-29</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol><li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li><li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li></ol><p>总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。</p><h2 id="途径"><a href="#途径" class="headerlink" title="途径"></a>途径</h2><p>前端优化的途径有很多，按粒度大致可以分为两类。</p><ul><li><strong>页面级别的优化</strong>，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;</li><li><strong>代码级别的优化</strong>，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。</li></ul><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="一、页面级优化"><a href="#一、页面级优化" class="headerlink" title="一、页面级优化"></a>一、页面级优化</h3><ol><li><strong>DNS优化</strong></li></ol><ul><li><code>减少DNS请求次数</code>。最理想的方法就是将所有的内容资源（页面、脚本、样式表、图片等）都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。</li><li><code>DNS预获取</code>。DOM还没开始，浏览器预解析地址，把解析好的地址放在本地缓存里面，DOM树生成完，要加载图片类的发现DNS已经解析好了，再发送请求。主要用于图片资源等。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&#39;dns-prefetch&#39; href&#x3D;&#39;&#x2F;&#x2F;dfns.tanx.com&#39;&gt; &#x2F;&#x2F; 此代码预获取dfns.tanx.com这个域名的IP地址</span><br></pre></td></tr></table></figure></li><li>利用<code>DNS负载均衡</code>技术。一个网站如果只有一个服务器，访问量过大时很容易挂掉。DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器会根据每台机器的负载量、与用户的距离等情况返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。该技术常见的应用是CDN（Content Delivery Network）。</li></ul><ol start="2"><li><strong>优化HTTP请求</strong></li></ol><ul><li><code>preload和prefetch</code></li><li><code>合理设置HTTP缓存</code><br>怎样才算合理设置？原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires/max-age设置一个很长的过期头；变化不频繁而又可能会变的资源可以使用Last-Modifed/etag来做请求验证。尽可能的让资源能够在缓存中待得更久。</li><li><code>使用http2</code><br>http2有多路复用、头部压缩等功能，能极大的减少http(s)的请求开销，不过需要在https下使用。</li><li><code>资源合并与压缩</code><br>如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#开启和关闭gzip模式</span><br><span class="line">gzip on;</span><br><span class="line">#gizp压缩起点，文件大于1k才进行压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"># gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"># 进行压缩的文件类型。</span><br><span class="line">gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript ;</span><br><span class="line">#nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩</span><br><span class="line">gzip_static on</span><br><span class="line"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class="line">gzip_vary on;</span><br><span class="line"># 设置gzip压缩针对的HTTP协议版本</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure></li><li><code>CSS Sprites</code><br>　　合并 CSS图片，减少请求数的又一个好办法。</li><li><code>Inline Images</code><br>　　使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。</li><li><code>图片懒加载</code><br>这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。</li></ul><ol start="3"><li><p><strong>将外部脚本置底，将css放在HEAD中</strong><br><br>js的下载和执行会阻塞dom解析，也就是会阻塞页面的渲染，css也有可能会阻塞页面的渲染（因为js执行前会下载css）。<br>如果把CSS放在文档的最后面加载执行，CSS不会阻塞DOM的生成，但是浏览器在解析完DOM后，要花费额外时间来解析CSS，而不是在解析DOM的时候，并行解析CSS。<br>并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。<br>所以应该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行，从而使页面尽快的渲染完成。</p></li><li><p><strong>异步执行脚本</strong></p></li></ol><ul><li>defer和async</li><li>setTimeout等</li><li>Web Workers</li></ul><ol start="5"><li><p><strong>Lazy Load Javascript</strong><br><br>随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。YUI 则使用了第二种方式，在 YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。</p></li><li><p><strong>减少不必要的 HTTP跳转</strong><br><br>对于以目录形式访问的HTTP链接，很多人都会忽略链接最后是否带 ‘/‘，假如你的服务器对此是区别对待的话，那么你也需要注意，这其中很可能隐藏了301跳转，增加了多余请求。具体参见下图，其中第一个链接是以无’/‘结尾的方式访问的，于是服务器有了一次跳转。</p></li><li><p><strong>避免重复的资源请求</strong><br><br>这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求</p></li></ol><h3 id="二、代码级优化"><a href="#二、代码级优化" class="headerlink" title="二、代码级优化"></a>二、代码级优化</h3><ol><li><strong>Javascript</strong></li></ol><ul><li><p><code>DOM</code><br><br>DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。如果脚本中包含了大量的 DOM操作则需要注意以下几点：</p><ul><li>a. HTML Collection（HTML收集器，返回的是一个数组内容信息）<br><br>　　在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的 “访问集合” 包括读取集合的 length属性、访问集合中的元素。因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。</li><li>b. Reflow &amp; Repaint<br><br>　　除了上面一点之外， DOM操作还需要考虑浏览器的 Reflow和Repaint ，因为这些都是需要消耗资源的。</li></ul></li><li><p><code>慎用 with</code><br><br>with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。<br>　　因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。</p></li><li><p><code>避免使用 eval和 Function</code><br>　　每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。<br>　　eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。<br>　　Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。<br>　　此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。</p></li><li><p><code>减少作用域链查找</code>（这方面设计到一些内容的相关问题）<br>　　前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">　　低效率的写法：</span><br><span class="line">&#x2F;&#x2F; 全局变量 </span><br><span class="line">var globalVar &#x3D; 1; </span><br><span class="line">function myCallback(info)&#123; </span><br><span class="line">    for( var i &#x3D; 100000; i--;)&#123; </span><br><span class="line">    &#x2F;&#x2F;每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次 </span><br><span class="line">        globalVar +&#x3D; i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">　　更高效的写法：</span><br><span class="line">&#x2F;&#x2F; 全局变量 </span><br><span class="line">var globalVar &#x3D; 1; </span><br><span class="line">function myCallback(info)&#123; </span><br><span class="line">    &#x2F;&#x2F; 局部变量缓存全局变量 </span><br><span class="line">    var localVar &#x3D; globalVar; </span><br><span class="line">    for( var i &#x3D; 100000; i--;)&#123; </span><br><span class="line">    &#x2F;&#x2F;访问局部变量是最快的 </span><br><span class="line">    localVar +&#x3D; i; </span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 本例中只需要访问 2次全局变量</span><br><span class="line">在函数中只需要将 globalVar中内容的值赋给localVar 中区</span><br><span class="line">    globalVar &#x3D; localVar; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，要减少作用域链查找还应该减少闭包的使用。</p></li><li><p><code>数据访问</code><br><br>Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量：</p><ul><li>a. 对任何对象属性的访问超过 1次</li><li>b. 对任何数组成员的访问次数超过 1次<br>另外，还应当尽可能的减少对对象以及数组深度查找。</li></ul></li><li><p><code>利用防抖和节流函数</code><br><br>降低事件监听回调频率</p></li></ul><ol start="2"><li><strong>CSS</strong></li></ol><ul><li><p><code>css选择符</code><br>在大多数人的观念中，都觉得浏览器对CSS选择符的解析式从左往右进行的，例如#toc A { color: #444; }这样一个选择符，如果是式从左往右解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是<strong>从右往左</strong>进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项，有人已经一一列举了， 详情参考此处。</p></li><li><p><code>减少重绘和重排</code><br>特别是重排，因为重排一定会触发重绘。具体如:</p><ul><li>基于vue/react等框架开发（虚拟dom和diff算法减少了重绘和重排）；</li><li>样式集中改变（利用当代浏览器的渲染队列机制将修改样式的代码写在一起，代码中间不要穿插无关样式修改的代码）；样式批量修改（如使用classname改变样式，或者box.style.cssText）；</li><li>样式读写分开；利用document.createDocumentFragment生成文档碎片批量插入dom元素或利用document.innerHTML插入多个dom string；</li><li>动画效果应用到position属性为absolute/fixed元素上（脱离文档流，减少对其他元素的影响）；</li><li>利用css3硬件加速（transform、opacity、filters，触发硬件加速，不触发重绘重排）；尽量避免table布局（不好计算位置和大小）等等</li></ul></li></ul><p>【参考】</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coober/p/8078847.html">前端性能优化方案都有哪些？</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903789388890119">我是如何让公司后台管理系统焕然一新的(上) -性能优化</a></p><div class="post-announce">感谢您的阅读，本文由 <a href="http://example.com">Astar</a> 版权所有。如若转载，请注明出处：Astar（<a href="http://example.com/2021/12/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">http://example.com/2021/12/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2021/12/12/css%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89/" title="css基础篇（汇总）"><i class="iconfont icon-prev"></i>css基础篇（汇总）</a></div><div class="post__prev post__prev--right"><a href="/2021/12/29/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/" title="自动部署hexo博客">自动部署hexo博客<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="回车搜索"> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">问题排查</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%A7%84%E8%8C%83%E5%8C%96/">规范化</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">浏览器和计算机网络</a><span class="block-list-count">7</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/">微前端</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">建站</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/js/">js</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/css/">css</a><span class="block-list-count">3</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2022/03/25/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/" title="常用git命令"><div class="item__cover"><img src="https://tse1-mm.cn.bing.net/th/id/R-C.47f1d668ae1c74d288e0cb0e822be203?rik=5R%2fXOkoiMWDLKA&riu=http%3a%2f%2fn.sinaimg.cn%2fsinakd20210215ac%2f790%2fw1539h851%2f20210215%2f8e28-kkciesq4857453.png&ehk=6LzXs%2fY4r%2bPpUrQQzgdKSNCNkTFwWg%2bMIRjlJ9BH1Ik%3d&risl=&pid=ImgRaw&r=0" alt="常用git命令"></div><div class="item__info"><h3 class="item__title">常用git命令</h3><span class="item__text">2022-03-25</span></div></a></li><li class="latest-post-item"><a href="/2022/02/24/css%E6%A0%B7%E5%BC%8F%E6%B2%A1%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" title="css样式没生效问题排查"><div class="item__cover"><img src="https://img2.baidu.com/it/u=3330810392,2639354941&fm=253&fmt=auto&app=138&f=JPEG?w=887&h=500" alt="css样式没生效问题排查"></div><div class="item__info"><h3 class="item__title">css样式没生效问题排查</h3><span class="item__text">2022-02-24</span></div></a></li><li class="latest-post-item"><a href="/2022/01/19/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/" title="图片懒加载的两种实现方案"><div class="item__cover"><img src="https://img2.baidu.com/it/u=4193472195,2353099366&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="图片懒加载的两种实现方案"></div><div class="item__info"><h3 class="item__title">图片懒加载的两种实现方案</h3><span class="item__text">2022-01-19</span></div></a></li><li class="latest-post-item"><a href="/2022/01/17/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90CHANGELOG%E6%8C%87%E5%8D%97/" title="前端生成CHANGELOG指南"><div class="item__cover"><img src="https://img1.baidu.com/it/u=1869297395,2506210818&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=281" alt="前端生成CHANGELOG指南"></div><div class="item__info"><h3 class="item__title">前端生成CHANGELOG指南</h3><span class="item__text">2022-01-17</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/css/">css</a></li><li class="tag-item"><a class="tag-link" href="/tags/git/">git</a></li><li class="tag-item"><a class="tag-link" href="/tags/js%E5%9F%BA%E7%A1%80/">js基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-item"><a class="tag-link" href="/tags/nginx/">nginx</a></li><li class="tag-item"><a class="tag-link" href="/tags/qiankun/">qiankun</a></li><li class="tag-item"><a class="tag-link" href="/tags/shell/">shell</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%85%BC%E5%AE%B9ie/">兼容ie</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">平衡二叉树</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/">最长无重复子串</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0js/">模拟实现js</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/">渲染机制</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/">自动部署</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%A7%84%E8%8C%83%E5%8C%96/">规范化</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%B7%A8%E5%9F%9F/">跨域</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">问题排查</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于Hexo搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>ShenZhen, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>2320390964@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/qrcode.jpg" alt="logo" title="Astar"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["性能优化"],gitalk=new Gitalk({clientID:"f75b0e86fdac67670255",clientSecret:"ec0d30e74282751b50189f8554788c36de21c86a",repo:"hello-astar.github.io",owner:"hello-astar",admin:["hello-astar"],labels:tags,id:new Date(1640769143e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>