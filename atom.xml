<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Astar</title>
  
  <subtitle>Astar&#39;s Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-25T08:40:38.059Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用git命令</title>
    <link href="http://example.com/2022/03/25/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/03/25/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-25T08:33:45.000Z</published>
    <updated>2022-03-25T08:40:38.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h3><ol><li>查看状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li>勾选文件</li></ol><ul><li>指定路径的话可以勾选修改和新增的（不在版本库中的）文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README.md src&#x2F;js&#x2F;test.js</span><br></pre></td></tr></table></figure></li><li>在当前目录及其下级目录内勾选文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li>勾选所有修改和新增的文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A &#x2F; git add --all</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>提交<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#39;init&#39;</span><br></pre></td></tr></table></figure>如果只有修改文件，没有新增文件，可以将勾选和提交合并到一起操作，不推荐使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &#39;init&#39;</span><br></pre></td></tr></table></figure></li><li>拉取<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li>推送<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li><li>放弃更改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout READM.md</span><br></pre></td></tr></table></figure></li><li>版本回退</li></ol><ul><li>git reset: 如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log &#x2F;&#x2F; 查看版本号列表</span><br><span class="line">git reset --hard 【目标版本号】</span><br><span class="line">git log &#x2F;&#x2F; 查看当前版本指向</span><br><span class="line">git push -f &#x2F;&#x2F; 提交更改</span><br></pre></td></tr></table></figure>如果想保留之前的内容，可以使用<code>--soft</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^ &#x2F;&#x2F; 回退到前一个版本，保留文件</span><br><span class="line">git reset --soft 【目标版本号】 &#x2F;&#x2F; 回退到目标版本，保留文件</span><br></pre></td></tr></table></figure></li><li>git revert: 将某次的版本回退，它之后的版本会被保留。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git revert -n 【目标版本号】</span><br><span class="line">git commit -m &#39;revert add text.txt&#39; &#x2F;&#x2F; 将修改提交</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li>修改commit注释<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend &#x2F;&#x2F; 此时会进入默认vim编辑器，修改注释完毕后保存就好了</span><br></pre></td></tr></table></figure></li><li>清除不在版本库内的新增文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f -d</span><br></pre></td></tr></table></figure></li><li>分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature&#x2F;test &#x2F;&#x2F; 本地新增分支feature&#x2F;test</span><br><span class="line">git checkout feature&#x2F;test &#x2F;&#x2F; 切换到分支feature&#x2F;test</span><br><span class="line">git checkout --track origin&#x2F;master &#x2F;&#x2F; 检出远程分支</span><br><span class="line">git merge A &#x2F;&#x2F; 将A分支合并到当前分支</span><br></pre></td></tr></table></figure></li><li>查看差异</li></ol><ul><li>比较工作区和暂存区test.js的差异<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff test.js</span><br></pre></td></tr></table></figure></li><li>对比两次提交（分支、标签）的修改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff develop..master</span><br></pre></td></tr></table></figure></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol><li><p>配置提交者信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config -global user.name a</span><br><span class="line">git config -global user.email xxx@qq.com</span><br></pre></td></tr></table></figure><p>如果想为不同项目配置不同的信息，可以不加<code>global</code>，在该项目下执行上述语句。</p></li><li><p>为已提交的版本修改committer和author<br>假设之前commit时候author和committer为”a”，改为”b”，邮箱改为”<a href="mailto:&#x78;&#x78;&#x78;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x78;&#x78;&#x78;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a>“</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter &#39;</span><br><span class="line"></span><br><span class="line">an&#x3D;&quot;$GIT_AUTHOR_NAME&quot;</span><br><span class="line">am&#x3D;&quot;$GIT_AUTHOR_EMAIL&quot;</span><br><span class="line">cn&#x3D;&quot;$GIT_COMMITTER_NAME&quot;</span><br><span class="line">cm&#x3D;&quot;$GIT_COMMITTER_EMAIL&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$GIT_COMMITTER_NAME&quot; &#x3D; &quot;a&quot; ]</span><br><span class="line">then</span><br><span class="line">    cn&#x3D;&quot;b&quot;</span><br><span class="line">    cm&#x3D;&quot;xxx@qq.com&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_NAME&quot; &#x3D; &quot;a&quot; ]</span><br><span class="line">then</span><br><span class="line">    an&#x3D;&quot;b&quot;</span><br><span class="line">    am&#x3D;&quot;xxx@qq.com&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export GIT_AUTHOR_NAME&#x3D;&quot;$an&quot;</span><br><span class="line">export GIT_AUTHOR_EMAIL&#x3D;&quot;$am&quot;</span><br><span class="line">export GIT_COMMITTER_NAME&#x3D;&quot;$cn&quot;</span><br><span class="line">export GIT_COMMITTER_EMAIL&#x3D;&quot;$cm&quot;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure><p>推送到所有版本上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force --tags origin &#39;refs&#x2F;heads&#x2F;*&#39;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;常用git命令&quot;&gt;&lt;a href=&quot;#常用git命令&quot; class=&quot;headerlink&quot; title=&quot;常用git命令&quot;&gt;&lt;/a&gt;常用git命令&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;查看状态&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    <category term="规范化" scheme="http://example.com/categories/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
    
    <category term="规范化" scheme="http://example.com/tags/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>css样式没生效问题排查</title>
    <link href="http://example.com/2022/02/24/css%E6%A0%B7%E5%BC%8F%E6%B2%A1%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://example.com/2022/02/24/css%E6%A0%B7%E5%BC%8F%E6%B2%A1%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2022-02-24T10:07:43.000Z</published>
    <updated>2022-03-17T09:26:56.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司的php老项目，clone下来后，配置php运行环境，安装glup，配置host文件和nginx代理，成功运行后，打开网页却发现样式没有生效。</p><h2 id="问题排查过程"><a href="#问题排查过程" class="headerlink" title="问题排查过程"></a>问题排查过程</h2><ul><li>打开控制台-网络-css，发现css文件是有加载的（加载的css文件也在本地，通过配置host和nginx访问），也就说明link标签引用的css路径是没有错的。</li><li>由于css内容较复杂，直接修改其中一个css文件内容为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>重新加载页面，发现网页body元素的<code>background-color</code>没有修改为<code>red</code>。</li><li>我们知道，网页渲染过程是dom解析 + css解析后，将解析结果合并（<a href="https://hello-astar.asia/blogs/2021/12/12/%E6%80%9D%E8%80%83%EF%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8C%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">详细过程</a>），那么是否css解析出了问题，或者合并过程出了问题呢。在控制台输入<code>document.styleSheets</code>，发现加载的css文件并没有被成功解析出来（rules为空），考虑是否文件编码问题导致文件无法正确解析。查看控制台内请求到的css文件内容，对比其他网站的css文件内容，发现正常css文件颜色丰富（类名、属性名、属性值等颜色不同），非正常css文件只有黑色的文字。看来果然有可能是文件编码问题。<br><img src="1.PNG" alt="正常css文件"><br><img src="2.PNG" alt="非正常css文件"></li><li>修改文件编码：将文件使用utf-8编码另存，刷新网页，样式依旧加载失败；在link标签中增加<code>charset=&quot;utf-8&quot;</code>，还是失败。</li><li>查看文件请求的请求头和响应头，发现响应头<code>Content-Type: application/octet-stream</code>，按常理来说css文件应该是<code>text/css</code>类型。</li><li>查看nginx配置，找到元凶<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这时我还想不修改nginx来解决，做了最后的挣扎。尝试在link标签内增加<code>type=&quot;text/css&quot;</code>，失败。</li><li>最后，老老实实修改nginx，对css文件进行处理。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  ...</span><br><span class="line">    include  mime.types; # 将不同文件的类型和响应的content-type做映射</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>mime.types文件如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">types &#123;</span><br><span class="line">    text&#x2F;html                                        html htm shtml;</span><br><span class="line">    text&#x2F;css                                         css;</span><br><span class="line">    text&#x2F;xml                                         xml;</span><br><span class="line">    image&#x2F;gif                                        gif;</span><br><span class="line">    image&#x2F;jpeg                                       jpeg jpg;</span><br><span class="line">    application&#x2F;javascript                           js;</span><br><span class="line">    application&#x2F;atom+xml                             atom;</span><br><span class="line">    application&#x2F;rss+xml                              rss;</span><br><span class="line"></span><br><span class="line">    text&#x2F;mathml                                      mml;</span><br><span class="line">    text&#x2F;plain                                       txt;</span><br><span class="line">    text&#x2F;vnd.sun.j2me.app-descriptor                 jad;</span><br><span class="line">    text&#x2F;vnd.wap.wml                                 wml;</span><br><span class="line">    text&#x2F;x-component                                 htc;</span><br><span class="line"></span><br><span class="line">    image&#x2F;png                                        png;</span><br><span class="line">    image&#x2F;svg+xml                                    svg svgz;</span><br><span class="line">    image&#x2F;tiff                                       tif tiff;</span><br><span class="line">    image&#x2F;vnd.wap.wbmp                               wbmp;</span><br><span class="line">    image&#x2F;webp                                       webp;</span><br><span class="line">    image&#x2F;x-icon                                     ico;</span><br><span class="line">    image&#x2F;x-jng                                      jng;</span><br><span class="line">    image&#x2F;x-ms-bmp                                   bmp;</span><br><span class="line"></span><br><span class="line">    font&#x2F;woff                                        woff;</span><br><span class="line">    font&#x2F;woff2                                       woff2;</span><br><span class="line"></span><br><span class="line">    application&#x2F;java-archive                         jar war ear;</span><br><span class="line">    application&#x2F;json                                 json;</span><br><span class="line">    application&#x2F;mac-binhex40                         hqx;</span><br><span class="line">    application&#x2F;msword                               doc;</span><br><span class="line">    application&#x2F;pdf                                  pdf;</span><br><span class="line">    application&#x2F;postscript                           ps eps ai;</span><br><span class="line">    application&#x2F;rtf                                  rtf;</span><br><span class="line">    application&#x2F;vnd.apple.mpegurl                    m3u8;</span><br><span class="line">    application&#x2F;vnd.google-earth.kml+xml             kml;</span><br><span class="line">    application&#x2F;vnd.google-earth.kmz                 kmz;</span><br><span class="line">    application&#x2F;vnd.ms-excel                         xls;</span><br><span class="line">    application&#x2F;vnd.ms-fontobject                    eot;</span><br><span class="line">    application&#x2F;vnd.ms-powerpoint                    ppt;</span><br><span class="line">    application&#x2F;vnd.oasis.opendocument.graphics      odg;</span><br><span class="line">    application&#x2F;vnd.oasis.opendocument.presentation  odp;</span><br><span class="line">    application&#x2F;vnd.oasis.opendocument.spreadsheet   ods;</span><br><span class="line">    application&#x2F;vnd.oasis.opendocument.text          odt;</span><br><span class="line">    application&#x2F;vnd.openxmlformats-officedocument.presentationml.presentation</span><br><span class="line">                                                     pptx;</span><br><span class="line">    application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet</span><br><span class="line">                                                     xlsx;</span><br><span class="line">    application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.document</span><br><span class="line">                                                     docx;</span><br><span class="line">    application&#x2F;vnd.wap.wmlc                         wmlc;</span><br><span class="line">    application&#x2F;x-7z-compressed                      7z;</span><br><span class="line">    application&#x2F;x-cocoa                              cco;</span><br><span class="line">    application&#x2F;x-java-archive-diff                  jardiff;</span><br><span class="line">    application&#x2F;x-java-jnlp-file                     jnlp;</span><br><span class="line">    application&#x2F;x-makeself                           run;</span><br><span class="line">    application&#x2F;x-perl                               pl pm;</span><br><span class="line">    application&#x2F;x-pilot                              prc pdb;</span><br><span class="line">    application&#x2F;x-rar-compressed                     rar;</span><br><span class="line">    application&#x2F;x-redhat-package-manager             rpm;</span><br><span class="line">    application&#x2F;x-sea                                sea;</span><br><span class="line">    application&#x2F;x-shockwave-flash                    swf;</span><br><span class="line">    application&#x2F;x-stuffit                            sit;</span><br><span class="line">    application&#x2F;x-tcl                                tcl tk;</span><br><span class="line">    application&#x2F;x-x509-ca-cert                       der pem crt;</span><br><span class="line">    application&#x2F;x-xpinstall                          xpi;</span><br><span class="line">    application&#x2F;xhtml+xml                            xhtml;</span><br><span class="line">    application&#x2F;xspf+xml                             xspf;</span><br><span class="line">    application&#x2F;zip                                  zip;</span><br><span class="line"></span><br><span class="line">    application&#x2F;octet-stream                         bin exe dll;</span><br><span class="line">    application&#x2F;octet-stream                         deb;</span><br><span class="line">    application&#x2F;octet-stream                         dmg;</span><br><span class="line">    application&#x2F;octet-stream                         iso img;</span><br><span class="line">    application&#x2F;octet-stream                         msi msp msm;</span><br><span class="line"></span><br><span class="line">    audio&#x2F;midi                                       mid midi kar;</span><br><span class="line">    audio&#x2F;mpeg                                       mp3;</span><br><span class="line">    audio&#x2F;ogg                                        ogg;</span><br><span class="line">    audio&#x2F;x-m4a                                      m4a;</span><br><span class="line">    audio&#x2F;x-realaudio                                ra;</span><br><span class="line"></span><br><span class="line">    video&#x2F;3gpp                                       3gpp 3gp;</span><br><span class="line">    video&#x2F;mp2t                                       ts;</span><br><span class="line">    video&#x2F;mp4                                        mp4;</span><br><span class="line">    video&#x2F;mpeg                                       mpeg mpg;</span><br><span class="line">    video&#x2F;quicktime                                  mov;</span><br><span class="line">    video&#x2F;webm                                       webm;</span><br><span class="line">    video&#x2F;x-flv                                      flv;</span><br><span class="line">    video&#x2F;x-m4v                                      m4v;</span><br><span class="line">    video&#x2F;x-mng                                      mng;</span><br><span class="line">    video&#x2F;x-ms-asf                                   asx asf;</span><br><span class="line">    video&#x2F;x-ms-wmv                                   wmv;</span><br><span class="line">    video&#x2F;x-msvideo                                  avi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>or<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.css &#123;</span><br><span class="line">  default_type  text&#x2F;css; # 单独对css文件做处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司的php老项目，clone下来后，配置php运行环境，安装glup，配置host文件和nginx代理，成功运行后，打开网页却发现样式没有</summary>
      
    
    
    
    <category term="问题排查" scheme="http://example.com/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="问题排查" scheme="http://example.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
    <category term="渲染机制" scheme="http://example.com/tags/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载的两种实现方案</title>
    <link href="http://example.com/2022/01/19/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2022/01/19/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</id>
    <published>2022-01-19T09:51:50.000Z</published>
    <updated>2022-03-17T09:26:56.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h2><p>监听scroll事件，判断图片是否在可视区域内（通过getBoundingClientRect获取图片位置信息）</p><p>缺点：scroll事件十分频繁，计算量大，容易造成性能问题，可以通过节流处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const viewHeight &#x3D; window.innerHeight || document.documentElement.clientHeight</span><br><span class="line">const imgs &#x3D; document.querySelectorAll(&#39;img&#39;)</span><br><span class="line">let threshold &#x3D; 100</span><br><span class="line">window.onload &#x3D; lazyLoad</span><br><span class="line">document.addEventListener(&#39;scroll&#39;, function (e) &#123;</span><br><span class="line">  lazyLoad()</span><br><span class="line">&#125;)</span><br><span class="line">function lazyLoad () &#123;</span><br><span class="line">  imgs.forEach(img &#x3D;&gt; &#123;</span><br><span class="line">    let &#123; top &#125; &#x3D; img.getBoundingClientRect()</span><br><span class="line">    if (img.dataset.src &amp;&amp; top - viewHeight &lt; threshold) &#123;</span><br><span class="line">      img.src &#x3D; img.dataset.src;</span><br><span class="line">      img.removeAttribute(&#39;data-src&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/hello-astar/js/blob/master/lazy-load-img/a.html">源码</a></p><h2 id="利用IntersectionObserver-API实现的方案"><a href="#利用IntersectionObserver-API实现的方案" class="headerlink" title="利用IntersectionObserver API实现的方案"></a>利用IntersectionObserver API实现的方案</h2><p>关于IntersectionObserver的使用方法，可以参考阮一峰的文章<a href="https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html">IntersectionObserver API 使用教程</a></p><p>这种方案是去生成一个观察者，判断它观察的dom元素是否在视口之内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">let imgs &#x3D; document.querySelectorAll(&#39;img&#39;)</span><br><span class="line">let imgsLen &#x3D; imgs.length</span><br><span class="line">let count &#x3D; 0</span><br><span class="line">let eachRetryTimes &#x3D; 3 &#x2F;&#x2F; 每张图片可以重试三次</span><br><span class="line">&#x2F;&#x2F; 加载后的处理</span><br><span class="line">function addOneSuccess (observer, target) &#123;</span><br><span class="line">  target.removeAttribute(&#39;data-src&#39;)</span><br><span class="line">  target.removeAttribute(&#39;data-retry&#39;)</span><br><span class="line">  observer.unobserve(target)</span><br><span class="line">  if (count &#x3D;&#x3D;&#x3D; imgsLen) &#123; &#x2F;&#x2F; 全都加载完毕，可以关闭观察器</span><br><span class="line">    observer.disconnect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 目标元素的可见性变化时，就会调用观察器的回调函数callback。</span><br><span class="line">&#x2F;&#x2F; callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</span><br><span class="line">let observer &#x3D; new IntersectionObserver((entries) &#x3D;&gt; &#123;</span><br><span class="line">  entries.forEach(e &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</span><br><span class="line">  &#x2F;&#x2F; intersectionRatio表示目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0</span><br><span class="line">    if (e.intersectionRatio &gt; 0 &amp;&amp; e.target.dataset.src) &#123; &#x2F;&#x2F; 可见</span><br><span class="line">      e.target.src &#x3D; e.target.dataset.src</span><br><span class="line">      let retry &#x3D; Number(e.target.dataset.retry || 0)</span><br><span class="line">      e.target.setAttribute(&#39;data-retry&#39;, ++retry)</span><br><span class="line">      e.target.onload &#x3D; function () &#123;</span><br><span class="line">        addOneSuccess(observer, this)</span><br><span class="line">      &#125;</span><br><span class="line">      e.target.onerror &#x3D; function () &#123;</span><br><span class="line">        let retry &#x3D; this.dataset.retry &#x2F;&#x2F; 重试次数</span><br><span class="line">        if (Number(retry) &#x3D;&#x3D;&#x3D; eachRetryTimes) &#123;</span><br><span class="line">          addOneSuccess(observer, this)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">imgs.forEach(img &#x3D;&gt; &#123;</span><br><span class="line">  observer.observe(img)</span><br><span class="line">&#125;)</span><br><span class="line">imgs &#x3D; null</span><br></pre></td></tr></table></figure><p><a href="https://github.com/hello-astar/js/blob/master/lazy-load-img/b.html">源码</a></p><p>【参考】</p><p><a href="https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html">IntersectionObserver API 使用教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;传统方案&quot;&gt;&lt;a href=&quot;#传统方案&quot; class=&quot;headerlink&quot; title=&quot;传统方案&quot;&gt;&lt;/a&gt;传统方案&lt;/h2&gt;&lt;p&gt;监听scroll事件，判断图片是否在可视区域内（通过getBoundingClientRect获取图片位置信息）&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端生成CHANGELOG指南</title>
    <link href="http://example.com/2022/01/17/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90CHANGELOG%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2022/01/17/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90CHANGELOG%E6%8C%87%E5%8D%97/</id>
    <published>2022-01-17T11:19:46.000Z</published>
    <updated>2022-03-17T09:30:03.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>多人协作项目中规范化commit，提取关键信息。</p><h2 id="Angular-规范"><a href="#Angular-规范" class="headerlink" title="Angular 规范"></a>Angular 规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type, 必填&gt;(&lt;scope，可省略&gt;): &lt;subject，必填&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body，可省略&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer，可省略&gt;</span><br></pre></td></tr></table></figure><h3 id="标识-type"><a href="#标识-type" class="headerlink" title="标识 - type"></a>标识 - type</h3><table><thead><tr><th>CHANGELOG 标识名</th><th>说明</th><th>是否会出现在CHANGELOG中</th></tr></thead><tbody><tr><td>feat</td><td>新功能（feature）</td><td>会</td></tr><tr><td>fix</td><td>修补bug</td><td>会</td></tr><tr><td>docs</td><td>文档（documentation）</td><td>自行决定</td></tr><tr><td>style</td><td>格式（不影响代码运行的变动）</td><td>自行决定</td></tr><tr><td>refactor</td><td>重构（即不是新增功能，也不是修改bug的代码变动）</td><td>自行决定</td></tr><tr><td>test</td><td>增加测试</td><td>自行决定</td></tr><tr><td>chore</td><td>构建过程或辅助工具的变动</td><td>自行决定</td></tr></tbody></table><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>scope用于说明 commit 影响的范围，比如某个模块、某个功能。</p><h3 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h3><p>subject是 commit 目的的简短描述，不超过50个字符。</p><h3 id="body"><a href="#body" class="headerlink" title="body"></a>body</h3><p>body部分是对本次 commit 的详细描述，可以分成多行。</p><h3 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h3><p>footer部分只用于两种情况：不兼容变动、关闭 Issue。</p><h2 id="利用conventional-changelog-cli"><a href="#利用conventional-changelog-cli" class="headerlink" title="利用conventional-changelog-cli"></a>利用conventional-changelog-cli</h2><ol><li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure></li><li>package.json增加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;version&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li>发版前利用npm version升版本号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># From 1.0.0 -&gt; 1.0.1</span><br><span class="line">npm version patch</span><br><span class="line"> </span><br><span class="line"># From 1.0.1 -&gt; 1.1.0</span><br><span class="line">npm version minor</span><br><span class="line"> </span><br><span class="line"># From 1.1.0 -&gt; 2.0.0</span><br><span class="line">npm version major</span><br></pre></td></tr></table></figure>升版本并提交<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm version minor -m &#39;docs(CHANGELOG): [tag]&#39;</span><br></pre></td></tr></table></figure>【参考】</li></ol><p><a href="https://godbasin.github.io/2019/11/10/change-log/">前端 CHANGELOG 生成指南</a></p><p><a href="https://www.jianshu.com/p/002e2130b042">终于可以不用手动去改npm版本号了！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;多人协作项目中规范化commit，提取关键信息。&lt;/p&gt;
&lt;h2 id=&quot;Angular-规范&quot;&gt;&lt;a href=&quot;#Angular-规范&quot;</summary>
      
    
    
    
    <category term="规范化" scheme="http://example.com/categories/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
    
    <category term="规范化" scheme="http://example.com/tags/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>从常见案例探索JS正则表达式用法</title>
    <link href="http://example.com/2022/01/14/%E4%BB%8E%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B%E6%8E%A2%E7%B4%A2JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/01/14/%E4%BB%8E%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B%E6%8E%A2%E7%B4%A2JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/</id>
    <published>2022-01-14T11:59:03.000Z</published>
    <updated>2022-03-17T09:26:56.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何写一个正则表达式"><a href="#如何写一个正则表达式" class="headerlink" title="如何写一个正则表达式"></a>如何写一个正则表达式</h1><p>拆成（取值范围+量词）这样的组合，例如qq号码验证：号码数字5-15位，并且不以0开头</p><ul><li>拆分（1位：1-9的数字）(4-14位：0-9的数字)</li><li>初步获得<code>pattern = /[1-9][0-9]&#123;4,14&#125;/</code></li><li>上述模式是正确的吗？我们可以做个测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let pattern &#x3D; &#x2F;[1-9][0-9]&#123;4,14&#125;&#x2F;</span><br><span class="line">console.log(pattern.test(&#39;555555555555555555&#39;)) &#x2F;&#x2F; 18位</span><br></pre></td></tr></table></figure>看样子pattern是错误的，它可以匹配超过15位的号码。即只要字符串中有符合该pattern的子串，就会匹配。（比如a123456b就会匹配）</li><li>修改 =&gt; 加入元字符<code>^</code>和<code>$</code>表示字符串的开始和结束 =&gt;  <code>pattern = /^[1-9][0-9]&#123;4,14&#125;$/</code></li></ul><h1 id="常见使用方法以及案例"><a href="#常见使用方法以及案例" class="headerlink" title="常见使用方法以及案例"></a>常见使用方法以及案例</h1><h2 id="1-移除className-元字符-b"><a href="#1-移除className-元字符-b" class="headerlink" title="1. 移除className - 元字符\b"></a>1. 移除className - 元字符<code>\b</code></h2><p>使用元字符<code>\b</code>（<code>\b</code>匹配单词的开始或结束）匹配要移除的className</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;*要求将下面这个元素中的unabled类移除掉*&#x2F;</span><br><span class="line">    &lt;div class&#x3D;&quot;confirm-btn unabled mb-10&quot; id&#x3D;&quot;j_confirm_btn&quot;&gt;提交&lt;&#x2F;div&gt;</span><br><span class="line">    var classname &#x3D; document.getElementById(&quot;j_confirm_btn&quot;).className;</span><br><span class="line">    &#x2F;&#x2F; \b表示单词的开头或结尾</span><br><span class="line">    var newClassName &#x3D; classname.replace(&#x2F;\bunabled\b&#x2F;,&quot;&quot;);</span><br><span class="line">    document.getElementById(&quot;j_confirm_btn&quot;).className &#x3D; newClassName;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="2-找句子中hi后面不远处跟着一个Lucy那一段-元字符-b"><a href="#2-找句子中hi后面不远处跟着一个Lucy那一段-元字符-b" class="headerlink" title="2. 找句子中hi后面不远处跟着一个Lucy那一段 - 元字符\b"></a>2. 找句子中hi后面不远处跟着一个Lucy那一段 - 元字符<code>\b</code></h2><p><code>.</code>匹配除换行符以外的任意字符，<code>*</code>表示重复零次或多次，那么<code>.*</code>表示单词hi和单词Lucy中间有0个或多个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\bhi\b.*\bLucy\b</span><br></pre></td></tr></table></figure><h2 id="3-把一串数字表示成千位分隔形式-正向预查a-b"><a href="#3-把一串数字表示成千位分隔形式-正向预查a-b" class="headerlink" title="3. 把一串数字表示成千位分隔形式 - 正向预查a(?=b)"></a>3. 把一串数字表示成千位分隔形式 - 正向预查a(?=b)</h2><ul><li>从后往前匹配三个数字 <code>pattern = /(\B\d&#123;3&#125;)+$/g</code></li><li>利用正向预查匹配前面的空格 <code>pattern = /(?=(\B\d&#123;3&#125;)+$)/g</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; 100000000</span><br><span class="line">&#x2F;&#x2F; \B匹配不是单词开头或结束的位置</span><br><span class="line">console.log(num.toString().replace(&#x2F;(?&#x3D;(\B\d&#123;3&#125;)+$)&#x2F;g, &#39;,&#39;))</span><br></pre></td></tr></table></figure>可以利用replace的第二个参数查看具体匹配详情<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; 100000000</span><br><span class="line">&#x2F;&#x2F; \B匹配不是单词开头或结束的位置</span><br><span class="line">console.log(num.toString().replace(&#x2F;(?&#x3D;(\B\d&#123;3&#125;)+$)&#x2F;g, function (...params) &#123;</span><br><span class="line">    console.log(params)</span><br><span class="line">    return &#39;,&#39;</span><br><span class="line">  &#125;</span><br><span class="line">))</span><br><span class="line">&#x2F;&#x2F; 可以看到输出两次</span><br></pre></td></tr></table></figure><a href="https://juejin.cn/post/6844903584031571975">把一串数字表示成千位分隔形式</a></li></ul><p><a href="https://www.jianshu.com/p/35fdaafc7362">正则的正向预查和反向引用</a></p><h2 id="4-国内电话号码验证-分支条件"><a href="#4-国内电话号码验证-分支条件" class="headerlink" title="4. 国内电话号码验证 - 分支条件|"></a>4. 国内电话号码验证 - 分支条件|</h2><ul><li>验证国内电话号码，例如0555-6581752、021-86128488<br>拆分： <ul><li>0开头</li><li>后接<code>3个数字+‘-’+7个数字(非0开头)</code>或者<code>2个数字+‘-’ +8个数字（非0开头）</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern &#x3D; &#x2F;(^0[0-9]&#123;3&#125;-[1-9][0-9]&#123;6&#125;$)|(^0[0-9]&#123;2&#125;-[1-9][0-9]&#123;7&#125;$)&#x2F;</span><br></pre></td></tr></table></figure>使用\d代表[0-9]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern &#x3D; &#x2F;(^0\d&#123;3&#125;-[1-9]\d&#123;6&#125;$)|(^0\d&#123;2&#125;-[1-9]\d&#123;7&#125;$)&#x2F;</span><br></pre></td></tr></table></figure><h2 id="5-分组与捕获"><a href="#5-分组与捕获" class="headerlink" title="5. 分组与捕获"></a>5. 分组与捕获</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配abab</span><br><span class="line">console.log(&#x2F;(ab)&#123;2&#125;&#x2F;.test(&#39;ababcc&#39;)) &#x2F;&#x2F; 此处将ab重复两次</span><br><span class="line">&#x2F;&#x2F; 匹配所有js与css文件</span><br><span class="line">&#x2F;&#x2F; 限定分支</span><br><span class="line">console.log(&#x2F;.*\.(js|css)$&#x2F;.test(&#39;hello.js&#39;))</span><br><span class="line">&#x2F;&#x2F; 获取js或css文件名</span><br><span class="line">console.log(&#39;hello.js&#39;.replace(&#x2F;(.*)\.(js|css)$&#x2F;, &#39;$1&#39;))</span><br></pre></td></tr></table></figure><h2 id="6-获取链接https-www-baidu-com-name-astar-amp-age-200中name的值"><a href="#6-获取链接https-www-baidu-com-name-astar-amp-age-200中name的值" class="headerlink" title="6. 获取链接https://www.baidu.com?name=astar&amp;age=200中name的值"></a>6. 获取链接<a href="https://www.baidu.com/?name=astar&amp;age=200%E4%B8%ADname%E7%9A%84%E5%80%BC">https://www.baidu.com?name=astar&amp;age=200中name的值</a></h2></li></ul></li><li>[^x]匹配除了x以外的任意字符</li><li>[^aeiou]匹配除了aeiou这几个字母以外的任意字符，<code>&lt;a[^&gt;]+&gt;</code> 匹配用尖括号括起来的以a开头的字符串，例如<code>&lt;as&gt;</code></li><li>()代表分组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> function getParam(attr) &#123;</span><br><span class="line">    &#x2F;&#x2F; window.location.search &#x3D;&gt; ?name&#x3D;astar&amp;age&#x3D;100</span><br><span class="line">    let pattern &#x3D; new RegExp(&#96;[?&amp;]$&#123;attr&#125;&#x3D;([^&amp;]*)&#96;)</span><br><span class="line">    let match &#x3D; pattern.exec(window.location.search)</span><br><span class="line">    return match &amp;&amp; decodeURIComponent(match[1])</span><br><span class="line">&#125;</span><br><span class="line">console.log(getParam(&#39;name&#39;))</span><br></pre></td></tr></table></figure>ps： decodeURIComponent() 函数可对 encodeURIComponent() 函数编码的 URI 进行解码。</li></ul><p><img src="https://img-blog.csdnimg.cn/20190320161515385.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="7-获取url中的所有参数"><a href="#7-获取url中的所有参数" class="headerlink" title="7. 获取url中的所有参数"></a>7. 获取url中的所有参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getParams (url) &#123;</span><br><span class="line">  let reg &#x3D; new RegExp(&#x2F;[?&amp;]([^&amp;]*)&#x3D;([^&amp;]*)&#x2F;, &#39;g&#39;)</span><br><span class="line">  let res &#x3D; &#123;&#125;</span><br><span class="line">  url.replace(reg, function (str, a, b) &#123;</span><br><span class="line">    res[decodeURIComponent(a)] &#x3D; decodeURIComponent(b)</span><br><span class="line">    return str</span><br><span class="line">  &#125;)</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line">let url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com?name&#x3D;astar&amp;age&#x3D;200&#39;</span><br><span class="line">console.log(getParams(url))</span><br></pre></td></tr></table></figure><h2 id="8-正则从2018-10-07T11-48-47-Asia-zh-cn-提取出来结果-2018-10-07-11-48-47"><a href="#8-正则从2018-10-07T11-48-47-Asia-zh-cn-提取出来结果-2018-10-07-11-48-47" class="headerlink" title="8. 正则从2018-10-07T11:48:47 Asia/zh-cn 提取出来结果[2018,10,07,11,48,47]"></a>8. 正则从2018-10-07T11:48:47 Asia/zh-cn 提取出来结果[2018,10,07,11,48,47]</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.match(&#x2F;\d&#123;1,&#125;&#x2F;g)</span><br><span class="line">str.match(&#x2F;\d+&#x2F;g)</span><br></pre></td></tr></table></figure><h2 id="9-反向引用"><a href="#9-反向引用" class="headerlink" title="9. 反向引用"></a>9. 反向引用</h2><p><code>\number</code> 或 <code>\k</code>，使用方法不同，效果一致。</p><ul><li><code>\b(\w+)\b\s+\1\b</code>可以用来匹配重复的单词，像go go, 或者kitty kitty(\1表示分组1匹配的文本)</li><li><code>\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b</code>自定义分组名为Word</li></ul><h2 id="10-变量名转为驼峰法"><a href="#10-变量名转为驼峰法" class="headerlink" title="10. 变量名转为驼峰法"></a>10. 变量名转为驼峰法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function toCamel (s) &#123;</span><br><span class="line">    return s.replace(&#x2F;-\w&#x2F;g, function(x) &#123;</span><br><span class="line">        return x.slice(1).toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-其他练习题集锦"><a href="#11-其他练习题集锦" class="headerlink" title="11. 其他练习题集锦"></a>11. 其他练习题集锦</h2><p><a href="https://juejin.im/post/5ac1f1106fb9a028be362731">面试中会遇到的正则题</a></p><h1 id="各类符号及其含义"><a href="#各类符号及其含义" class="headerlink" title="各类符号及其含义"></a>各类符号及其含义</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字 [a-zA-Z0-9_]</td></tr><tr><td>\s</td><td>匹配任意的空白符 [\r\n\t\f]</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><h2 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h2><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h2 id="标志符号"><a href="#标志符号" class="headerlink" title="标志符号"></a>标志符号</h2><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>g</td><td>全局模式</td></tr><tr><td>i</td><td>不区分大小写</td></tr><tr><td>m</td><td>多行模式</td></tr></tbody></table><h2 id="常见分组语法"><a href="#常见分组语法" class="headerlink" title="常见分组语法"></a>常见分组语法</h2><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td>捕获</td><td>(?<name>exp)</td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td></tr><tr><td>捕获</td><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>零宽断言</td><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td>零宽断言</td><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td></tr><tr><td>零宽断言</td><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td></tr><tr><td>零宽断言</td><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr><tr><td>注释</td><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><h2 id="懒惰限定符"><a href="#懒惰限定符" class="headerlink" title="懒惰限定符"></a>懒惰限定符</h2><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h1 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h1><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><p>该方法是专门为捕获组设计的。</p><blockquote><p>接收字符串参数，返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。<br>即使正则表达式设置了全局，每次也只会返回一个匹配项，需要多次调用exec()方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &#39;mom and dad and baby&#39;</span><br><span class="line">var pattern &#x3D; &#x2F;mom (and dad (and baby)?)?&#x2F;gi</span><br><span class="line">var matches &#x3D; pattern.exec(text)</span><br><span class="line">console.log(matches)</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;  &#39;mom and dad and baby&#39;,</span><br><span class="line">&#x2F;&#x2F;  &#39;and dad and baby&#39;,</span><br><span class="line">&#x2F;&#x2F;  &#39;and baby&#39;,</span><br><span class="line">&#x2F;&#x2F;  index: 0,</span><br><span class="line">&#x2F;&#x2F;  input: &#39;mom and dad and baby&#39;,</span><br><span class="line">&#x2F;&#x2F;  groups: undefined</span><br><span class="line">&#x2F;&#x2F;]</span><br></pre></td></tr></table></figure><h2 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h2><p>返回true或false</p><blockquote><p>接收字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。<br>test方法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于他为什么无效就无关紧要了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &#39;000-00-0000&#39;</span><br><span class="line">var pattern &#x3D; &#x2F;\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;&#x2F;</span><br><span class="line">var matches &#x3D; pattern.test(text)</span><br><span class="line">console.log(matches) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h1 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h1><h2 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h2><p>返回匹配的内容组成的数组，失败返回null</p><h2 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h2><p>返回第一个匹配成功的字符串片段开始的位置，失败则返回-1</p><h2 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h2><p>替换与正则表达式匹配的子串，并返回替换后的字符串，若不设置全局g，只会替换第一个匹配成功的字符串片段。</p><h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><p>把一个字符串分割成数组</p><p>【参考】</p><p><a href="https://fex-team.github.io/fis-site/docs/more/regex.html">不完全正则指南</a></p><p><a href="https://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html">正则表达式30分钟入门教程</a></p><p><a href="https://segmentfault.com/a/1190000018173355">javascript replace高级用法</a></p><p><a href="https://juejin.im/post/5965943ff265da6c30653879">JS正则表达式完整教程（略长）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何写一个正则表达式&quot;&gt;&lt;a href=&quot;#如何写一个正则表达式&quot; class=&quot;headerlink&quot; title=&quot;如何写一个正则表达式&quot;&gt;&lt;/a&gt;如何写一个正则表达式&lt;/h1&gt;&lt;p&gt;拆成（取值范围+量词）这样的组合，例如qq号码验证：号码数字5-15位，并且</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现call、apply和bind</title>
    <link href="http://example.com/2022/01/09/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E3%80%81apply%E5%92%8Cbind/"/>
    <id>http://example.com/2022/01/09/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E3%80%81apply%E5%92%8Cbind/</id>
    <published>2022-01-09T13:30:44.000Z</published>
    <updated>2022-03-17T09:26:57.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>对象的方法调用时this指向是指向该对象的，利用此原理我们可以模拟实现call\bind\apply</p><h2 id="1-实现call"><a href="#1-实现call" class="headerlink" title="1. 实现call"></a>1. 实现call</h2><h3 id="版本v1"><a href="#版本v1" class="headerlink" title="版本v1"></a>版本v1</h3><p>利用基本原理我们可以实现版本1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 &#x3D; function (ctx, ...rest) &#123;</span><br><span class="line">    ctx.fn &#x3D; this</span><br><span class="line">    let result &#x3D; ctx.fn(...rest)</span><br><span class="line">    delete ctx.fn</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本v2"><a href="#版本v2" class="headerlink" title="版本v2"></a>版本v2</h3><p>版本1的缺点是fn属性可能已经存在于ctx中了，我们这样写可能会导致原fn属性被删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 &#x3D; function (ctx, ...rest) &#123;</span><br><span class="line">    let key &#x3D; Symbol(&#39;function&#39;)</span><br><span class="line">    ctx[key] &#x3D; this</span><br><span class="line">    let result &#x3D; ctx[key](...rest)</span><br><span class="line">    delete ctx[key]</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本v3"><a href="#版本v3" class="headerlink" title="版本v3"></a>版本v3</h3><p>上面的版本还忽略了一个问题，当传入的ctx为null或undefined时候，this指向window；当传入的ctx为其他基本数据类型时候，会改为Object类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 &#x3D; function (ctx, ...rest) &#123;</span><br><span class="line">  if (ctx &#x3D;&#x3D;&#x3D; null || ctx &#x3D;&#x3D;&#x3D; undefined) ctx &#x3D; window</span><br><span class="line">  if (typeof ctx !&#x3D;&#x3D; &#39;object&#39;) ctx &#x3D; new Object(ctx)</span><br><span class="line">  let key &#x3D; Symbol(&#39;function&#39;)</span><br><span class="line">  ctx[key] &#x3D; this</span><br><span class="line">  let result &#x3D; ctx[key](...rest)</span><br><span class="line">  delete ctx[key]</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加分版"><a href="#加分版" class="headerlink" title="加分版"></a>加分版</h3><p>上面所有的版本我们都使用了es6的方法，如果不依赖es6的方法，将如何实现呢？</p><ul><li>let改为var</li><li>Symbol使用时间戳代替，利用<code>hasOwnProperty</code>判断该值是否为对象的原有属性</li><li>使用eval运行函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 &#x3D; function () &#123;</span><br><span class="line">  var ctx &#x3D; arguments[0]</span><br><span class="line">  var key &#x3D; &#39;&#39;</span><br><span class="line">  var args &#x3D; []</span><br><span class="line">  if (ctx &#x3D;&#x3D;&#x3D; null || ctx &#x3D;&#x3D;&#x3D; undefined) ctx &#x3D; window</span><br><span class="line">  if (typeof ctx !&#x3D;&#x3D; &#39;object&#39;) ctx &#x3D; new Object(ctx)</span><br><span class="line">  while (!key || ctx.hasOwnProperty(key)) &#123;</span><br><span class="line">    key &#x3D; &#39;fn_&#39; + new Date().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  ctx[key] &#x3D; this</span><br><span class="line">  &#x2F;&#x2F; 参数数组</span><br><span class="line">  for (var i &#x3D; 1, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(&#39;arguments[&#39; + i + &#39;]&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 字符串拼接会直接调用数组的toString方法 [1,2].toString() &#x3D;&#x3D;&#x3D; &#39;1,2&#39;</span><br><span class="line">  &#x2F;&#x2F; 此处变为 eval(&#39;ctx[key](arguments[1], arguments[2],...)&#39;)</span><br><span class="line">  var result &#x3D; eval(&#39;ctx[key](&#39; + args + &#39;)&#39;)</span><br><span class="line">  delete ctx[key]</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-实现apply"><a href="#2-实现apply" class="headerlink" title="2. 实现apply"></a>2. 实现apply</h2>与模拟实现call原理一致，我们直接修改call模拟实现的加分版<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.apply2 &#x3D; function (ctx, args) &#123;</span><br><span class="line">  var key &#x3D; &#39;&#39;</span><br><span class="line">  var argsStr &#x3D; []</span><br><span class="line">  if (ctx &#x3D;&#x3D;&#x3D; null || ctx &#x3D;&#x3D;&#x3D; undefined) ctx &#x3D; window</span><br><span class="line">  if (args &#x3D;&#x3D;&#x3D; null || args &#x3D;&#x3D;&#x3D; undefined) args &#x3D; []</span><br><span class="line">  if (typeof ctx !&#x3D;&#x3D; &#39;object&#39;) ctx &#x3D; new Object(ctx)</span><br><span class="line">  if (!(args instanceof Object)) &#123;</span><br><span class="line">    throw new Error(&#39;TypeError: CreateListFromArrayLike called on non-object&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  while (!key || ctx.hasOwnProperty(key)) &#123;</span><br><span class="line">    key &#x3D; &#39;fn_&#39; + new Date().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  ctx[key] &#x3D; this</span><br><span class="line">  &#x2F;&#x2F; 参数数组</span><br><span class="line">  for (var i &#x3D; 0, len &#x3D; args.length; i &lt; len; i++) &#123;</span><br><span class="line">    argsStr.push(&#39;args[&#39; + i + &#39;]&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 字符串拼接会直接调用数组的toString方法 [1,2].toString() &#x3D;&#x3D;&#x3D; &#39;1,2&#39;,因为[[1,2],3].toString() &#x3D;&#x3D;&#x3D; &#39;1,2,3&#39;，数组参数会被拍平，所以借助argsStr</span><br><span class="line">  var result &#x3D; eval(&#39;ctx[key](&#39; + argsStr + &#39;)&#39;)</span><br><span class="line">  delete ctx[key]</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果不想使用eval，可以使用new Function()根据字符串生成函数来调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; eval(&#39;ctx[key](&#39; + argsStr + &#39;)&#39;)</span><br></pre></td></tr></table></figure>改为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; new Function([&#39;ctx&#39;, &#39;key&#39;, &#39;args&#39;], &#39;return ctx[key](&#39; + argsStr + &#39;)&#39;)(ctx, key, args)</span><br></pre></td></tr></table></figure><h2 id="3-实现bind"><a href="#3-实现bind" class="headerlink" title="3. 实现bind"></a>3. 实现bind</h2><h3 id="v1版本，沿用之前的思想，封装函数返回"><a href="#v1版本，沿用之前的思想，封装函数返回" class="headerlink" title="v1版本，沿用之前的思想，封装函数返回"></a>v1版本，沿用之前的思想，封装函数返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function () &#123;</span><br><span class="line">  var ctx &#x3D; arguments[0]</span><br><span class="line">  var args &#x3D; []</span><br><span class="line">  var _this &#x3D; this</span><br><span class="line">  if (ctx &#x3D;&#x3D;&#x3D; null || ctx &#x3D;&#x3D;&#x3D; undefined) ctx &#x3D; window</span><br><span class="line">  if (typeof ctx !&#x3D;&#x3D; &#39;object&#39;) ctx &#x3D; new Object(ctx)</span><br><span class="line">  for (var i &#x3D; 1, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(arguments[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var key &#x3D; &#39;&#39;</span><br><span class="line">    while (!key || ctx.hasOwnProperty(key)) &#123;</span><br><span class="line">      key &#x3D; &#39;fn_&#39; + new Date().getTime()</span><br><span class="line">    &#125;</span><br><span class="line">    ctx[key] &#x3D; _this</span><br><span class="line">    for (var i &#x3D; 0, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(arguments[i])</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i &#x3D; 0, len &#x3D; args.length, argsStr &#x3D; []; i &lt; len; i++) &#123;</span><br><span class="line">      argsStr.push(&#39;args[&#39; + i + &#39;]&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    var result &#x3D; eval(&#39;ctx[key](&#39; + argsStr + &#39;)&#39;)</span><br><span class="line">    delete ctx[key]</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v2版本，利用之前实现的call或apply"><a href="#v2版本，利用之前实现的call或apply" class="headerlink" title="v2版本，利用之前实现的call或apply"></a>v2版本，利用之前实现的call或apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function () &#123;</span><br><span class="line">  var ctx &#x3D; arguments[0]</span><br><span class="line">  var args &#x3D; []</span><br><span class="line">  var self &#x3D; this</span><br><span class="line">  for (var i &#x3D; 1, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(arguments[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    for (var i &#x3D; 0, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(arguments[i])</span><br><span class="line">    &#125;</span><br><span class="line">    return self.apply2(ctx, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v3版本，考虑生成的函数作为构造函数的情况"><a href="#v3版本，考虑生成的函数作为构造函数的情况" class="headerlink" title="v3版本，考虑生成的函数作为构造函数的情况"></a>v3版本，考虑生成的函数作为构造函数的情况</h3></li><li>生成的函数应该继承原函数的原型链上的属性</li><li>bind后的函数作为构造函数调用时，this指向new创建的实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function () &#123;</span><br><span class="line">  var ctx &#x3D; arguments[0]</span><br><span class="line">  var args &#x3D; []</span><br><span class="line">  var self &#x3D; this</span><br><span class="line">  for (var i &#x3D; 1, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(arguments[i])</span><br><span class="line">  &#125;</span><br><span class="line">  var F &#x3D; function () &#123;</span><br><span class="line">    for (var i &#x3D; 0, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(arguments[i])</span><br><span class="line">    &#125;</span><br><span class="line">    return self.apply2(this instanceof F ? this : ctx, args)</span><br><span class="line">  &#125;</span><br><span class="line">  var FNOP &#x3D; function () &#123;&#125;</span><br><span class="line">  FNOP.prototype &#x3D; self.prototype</span><br><span class="line">  F.prototype &#x3D; new FNOP()</span><br><span class="line">  return F</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>【参考】</li></ul><p><a href="https://github.com/mqyqingfeng/Blog/issues/11">JavaScript深入之call和apply的模拟实现</a></p><p><a href="https://juejin.cn/post/6844903728147857415">面试官问：能否模拟实现JS的call和apply方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;对象的方法调用时this指向是指向该对象的，利用此原理我们可以模拟实现call\bind\apply&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="模拟实现js" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0js/"/>
    
  </entry>
  
  <entry>
    <title>自动部署hexo博客</title>
    <link href="http://example.com/2021/12/29/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2021/12/29/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-12-29T11:40:26.000Z</published>
    <updated>2022-03-17T09:26:57.006Z</updated>
    
    <content type="html"><![CDATA[<ol><li>本地生成密钥<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></li><li>复制公钥至服务器/.ssh/authorized_keys文件，私钥存放在本地~/.ssh文件夹中（deploy文件）</li><li>重启ssh服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li>项目下新建deploy.sh文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Start build!&quot;</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line"># 删除服务器旧博客内容</span><br><span class="line">ssh -i ~&#x2F;.ssh&#x2F;deploy root@xxx.xxx.xxx.xxx &quot;rm -rf &#x2F;root&#x2F;astar.asia&#x2F;blogs&#x2F;*&quot;</span><br><span class="line"># 将新构建的博客内容移动到服务器</span><br><span class="line">scp -r -i ~&#x2F;.ssh&#x2F;deploy .&#x2F;public&#x2F;* root@xxx.xxx.xxx.xxx:&#x2F;root&#x2F;astar.asia&#x2F;blogs</span><br></pre></td></tr></table></figure></li><li>运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;deploy.sh</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;本地生成密钥&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;</summary>
      
    
    
    
    <category term="建站" scheme="http://example.com/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="自动部署" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://example.com/2021/12/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/12/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-12-29T09:12:23.000Z</published>
    <updated>2022-03-17T09:26:56.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol><li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li><li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li></ol><p>总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。</p><h2 id="途径"><a href="#途径" class="headerlink" title="途径"></a>途径</h2><p>前端优化的途径有很多，按粒度大致可以分为两类。</p><ul><li><strong>页面级别的优化</strong>，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;</li><li><strong>代码级别的优化</strong>，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。</li></ul><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="一、页面级优化"><a href="#一、页面级优化" class="headerlink" title="一、页面级优化"></a>一、页面级优化</h3><ol><li><strong>DNS优化</strong></li></ol><ul><li><code>减少DNS请求次数</code>。最理想的方法就是将所有的内容资源（页面、脚本、样式表、图片等）都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。</li><li><code>DNS预获取</code>。DOM还没开始，浏览器预解析地址，把解析好的地址放在本地缓存里面，DOM树生成完，要加载图片类的发现DNS已经解析好了，再发送请求。主要用于图片资源等。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&#39;dns-prefetch&#39; href&#x3D;&#39;&#x2F;&#x2F;dfns.tanx.com&#39;&gt; &#x2F;&#x2F; 此代码预获取dfns.tanx.com这个域名的IP地址</span><br></pre></td></tr></table></figure></li><li>利用<code>DNS负载均衡</code>技术。一个网站如果只有一个服务器，访问量过大时很容易挂掉。DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器会根据每台机器的负载量、与用户的距离等情况返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。该技术常见的应用是CDN（Content Delivery Network）。</li></ul><ol start="2"><li><strong>优化HTTP请求</strong></li></ol><ul><li><code>preload和prefetch</code></li><li><code>合理设置HTTP缓存</code><br>怎样才算合理设置？原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires/max-age设置一个很长的过期头；变化不频繁而又可能会变的资源可以使用Last-Modifed/etag来做请求验证。尽可能的让资源能够在缓存中待得更久。</li><li><code>使用http2</code><br>http2有多路复用、头部压缩等功能，能极大的减少http(s)的请求开销，不过需要在https下使用。</li><li><code>资源合并与压缩</code><br>如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#开启和关闭gzip模式</span><br><span class="line">gzip on;</span><br><span class="line">#gizp压缩起点，文件大于1k才进行压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"># gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"># 进行压缩的文件类型。</span><br><span class="line">gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript ;</span><br><span class="line">#nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩</span><br><span class="line">gzip_static on</span><br><span class="line"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class="line">gzip_vary on;</span><br><span class="line"># 设置gzip压缩针对的HTTP协议版本</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure></li><li> <code>CSS Sprites</code><br>　　合并 CSS图片，减少请求数的又一个好办法。</li><li><code>Inline Images</code><br>　　使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。</li><li><code>图片懒加载</code><br>这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。 </li></ul><ol start="3"><li><p><strong>将外部脚本置底，将css放在HEAD中</strong><br><br>js的下载和执行会阻塞dom解析，也就是会阻塞页面的渲染，css也有可能会阻塞页面的渲染（因为js执行前会下载css）。<br>如果把CSS放在文档的最后面加载执行，CSS不会阻塞DOM的生成，但是浏览器在解析完DOM后，要花费额外时间来解析CSS，而不是在解析DOM的时候，并行解析CSS。<br>并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。<br>所以应该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行，从而使页面尽快的渲染完成。</p></li><li><p><strong>异步执行脚本</strong></p></li></ol><ul><li>defer和async</li><li>setTimeout等</li><li>Web Workers</li></ul><ol start="5"><li><p><strong>Lazy Load Javascript</strong><br><br>随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。YUI 则使用了第二种方式，在 YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。</p></li><li><p><strong>减少不必要的 HTTP跳转</strong><br><br>对于以目录形式访问的HTTP链接，很多人都会忽略链接最后是否带 ‘/‘，假如你的服务器对此是区别对待的话，那么你也需要注意，这其中很可能隐藏了301跳转，增加了多余请求。具体参见下图，其中第一个链接是以无’/‘结尾的方式访问的，于是服务器有了一次跳转。</p></li><li><p><strong>避免重复的资源请求</strong><br><br>这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求</p></li></ol><h3 id="二、代码级优化"><a href="#二、代码级优化" class="headerlink" title="二、代码级优化"></a>二、代码级优化</h3><ol><li><strong>Javascript</strong></li></ol><ul><li><p><code>DOM</code><br><br>DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。如果脚本中包含了大量的 DOM操作则需要注意以下几点：</p><ul><li>a. HTML Collection（HTML收集器，返回的是一个数组内容信息）<br><br>　　在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的 “访问集合” 包括读取集合的 length属性、访问集合中的元素。因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。</li><li>b. Reflow &amp; Repaint<br><br>　　除了上面一点之外， DOM操作还需要考虑浏览器的 Reflow和Repaint ，因为这些都是需要消耗资源的。</li></ul></li><li><p><code>慎用 with</code><br><br>with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。<br>　　因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。</p></li><li><p> <code>避免使用 eval和 Function</code><br>　　每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。<br>　　eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。<br>　　Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。<br>　　此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。</p></li><li><p><code>减少作用域链查找</code>（这方面设计到一些内容的相关问题）<br>　　前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">　　低效率的写法：</span><br><span class="line">&#x2F;&#x2F; 全局变量 </span><br><span class="line">var globalVar &#x3D; 1; </span><br><span class="line">function myCallback(info)&#123; </span><br><span class="line">    for( var i &#x3D; 100000; i--;)&#123; </span><br><span class="line">    &#x2F;&#x2F;每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次 </span><br><span class="line">        globalVar +&#x3D; i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">　　更高效的写法：</span><br><span class="line">&#x2F;&#x2F; 全局变量 </span><br><span class="line">var globalVar &#x3D; 1; </span><br><span class="line">function myCallback(info)&#123; </span><br><span class="line">    &#x2F;&#x2F; 局部变量缓存全局变量 </span><br><span class="line">    var localVar &#x3D; globalVar; </span><br><span class="line">    for( var i &#x3D; 100000; i--;)&#123; </span><br><span class="line">    &#x2F;&#x2F;访问局部变量是最快的 </span><br><span class="line">    localVar +&#x3D; i; </span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 本例中只需要访问 2次全局变量</span><br><span class="line">在函数中只需要将 globalVar中内容的值赋给localVar 中区</span><br><span class="line">    globalVar &#x3D; localVar; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，要减少作用域链查找还应该减少闭包的使用。</p></li><li><p><code>数据访问</code><br><br>Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量：</p><ul><li>a. 对任何对象属性的访问超过 1次</li><li>b. 对任何数组成员的访问次数超过 1次<br>另外，还应当尽可能的减少对对象以及数组深度查找。</li></ul></li><li><p><code>利用防抖和节流函数</code><br><br>降低事件监听回调频率</p></li></ul><ol start="2"><li><strong>CSS</strong></li></ol><ul><li><p><code>css选择符</code><br>在大多数人的观念中，都觉得浏览器对CSS选择符的解析式从左往右进行的，例如#toc A { color: #444; }这样一个选择符，如果是式从左往右解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是<strong>从右往左</strong>进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项，有人已经一一列举了， 详情参考此处。</p></li><li><p><code>减少重绘和重排</code><br>特别是重排，因为重排一定会触发重绘。具体如:</p><ul><li>基于vue/react等框架开发（虚拟dom和diff算法减少了重绘和重排）；</li><li>样式集中改变（利用当代浏览器的渲染队列机制将修改样式的代码写在一起，代码中间不要穿插无关样式修改的代码）；样式批量修改（如使用classname改变样式，或者box.style.cssText）；</li><li>样式读写分开；利用document.createDocumentFragment生成文档碎片批量插入dom元素或利用document.innerHTML插入多个dom string；</li><li>动画效果应用到position属性为absolute/fixed元素上（脱离文档流，减少对其他元素的影响）；</li><li>利用css3硬件加速（transform、opacity、filters，触发硬件加速，不触发重绘重排）；尽量避免table布局（不好计算位置和大小）等等</li></ul></li></ul><p>【参考】</p><p><a href="https://www.cnblogs.com/coober/p/8078847.html">前端性能优化方案都有哪些？</a></p><p><a href="https://juejin.cn/post/6844903789388890119">我是如何让公司后台管理系统焕然一新的(上) -性能优化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。&lt;/li&gt;
&lt;li&gt;从服务商角</summary>
      
    
    
    
    <category term="浏览器和计算机网络" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>css基础篇（汇总）</title>
    <link href="http://example.com/2021/12/12/css%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89/"/>
    <id>http://example.com/2021/12/12/css%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89/</id>
    <published>2021-12-12T14:18:13.000Z</published>
    <updated>2022-03-17T09:26:56.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-css选择器"><a href="#1-css选择器" class="headerlink" title="1. css选择器"></a>1. css选择器</h3><p>一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。<br>!important &gt; 行内样式 &gt; id &gt;  属性 &gt; 伪类 &gt; 类 &gt; 标签 &gt; 伪元素 &gt; 组合选择器 &gt; 通配符(*)。</p><h4 id="1-1-css选择器之组合选择器"><a href="#1-1-css选择器之组合选择器" class="headerlink" title="1.1 css选择器之组合选择器"></a>1.1 css选择器之组合选择器</h4><table><thead><tr><th>选择器</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>E,F</td><td>多元素选择器</td><td>同时匹配元素E或元素F</td></tr><tr><td>E F</td><td>后代选择器</td><td>匹配E元素所有的后代（不只是子元素、子元素向下<code>递归</code>）元素F</td></tr><tr><td>E&gt;F</td><td>子元素选择器</td><td>匹配E元素的所有<code>直接</code>子元素</td></tr><tr><td>E+F</td><td><code>直接相邻</code>选择器</td><td>匹配E元素之后的相邻的同级元素F</td></tr><tr><td>E~F</td><td>普通相邻选择器（弟弟选择器）</td><td>匹配E元素之后的同级元素F（<code>无论直接相邻与否</code>)</td></tr></tbody></table><h4 id="1-2-css选择器之伪类选择器"><a href="#1-2-css选择器之伪类选择器" class="headerlink" title="1.2 css选择器之伪类选择器"></a>1.2 css选择器之伪类选择器</h4><blockquote><p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。</p></blockquote><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:focus</td><td>input:focus</td><td>选择元素输入后具有焦点</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择所有选中的表单元素</td></tr><tr><td>:read-only</td><td>input:read-only</td><td>选择只读属性的元素属性</td></tr><tr><td>:read-write</td><td>input:read-write</td><td>选择没有只读属性的元素属性</td></tr><tr><td>:disabled</td><td>input:checked</td><td>选择所有禁用的表单元素</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择所有启用的表单元素</td></tr><tr><td>:in-range</td><td>input:in-range</td><td>选择元素指定范围内的值</td></tr><tr><td>:out-of-range</td><td>input:out-of-range</td><td>选择指定范围以外的值的元素属性</td></tr><tr><td>:valid</td><td>input:valid</td><td>选择所有有效值的属性</td></tr><tr><td>:invalid</td><td>input:invalid</td><td>选择所有无效的元素</td></tr><tr><td>:required</td><td>input:required</td><td>选择有”required”属性指定的元素属性</td></tr><tr><td>:optional</td><td>input:optional</td><td>选择没有”required”的元素属性</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择所有没有子元素的p元素</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择每个父元素是p元素的第一个p子元素</td></tr><tr><td>:last-of-type</td><td>p:first-of-type</td><td>选择每个p元素是其父元素的最后一个p元素</td></tr><tr><td>:first-child</td><td>p:first-child</td><td>匹配第一个p元素</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>匹配最后一个p元素</td></tr><tr><td>:not</td><td><code>:not(p)</code></td><td>选择所有p以外的元素</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择所有仅有一个子元素的p元素</td></tr><tr><td>:nth-child</td><td>p:nth-child(2)</td><td>选择所有p元素的第二个子元素</td></tr><tr><td>:nth-last-child</td><td>p:nth-last-child(2)</td><td>选择所有p元素倒数的第二个子元素</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择所有仅有一个子元素为p的元素</td></tr><tr><td>:nth-of-type</td><td>p:nth-of-type(2)</td><td>选择所有p元素第二个为p的子元素</td></tr><tr><td>:nth-last-of-type</td><td>p:nth-last-of-type(2)</td><td>选择所有p元素倒数的第二个为p的子元素</td></tr><tr><td>:link</td><td>a:link</td><td>选择所有未访问链接</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有访问过的链接</td></tr><tr><td>:hover</td><td>a:hover</td><td>把鼠标放在链接上的状态</td></tr><tr><td>:active</td><td>a:active</td><td>选择正在活动链接</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动#news元素(点击URL包含锚的名字)</td></tr><tr><td>:root</td><td>root</td><td>选择文档的根元素</td></tr><tr><td>:lang</td><td>q:lang(no){quotes: “<del>“ “</del>“}</td><td>为不同的语言匹配特殊的规则</td></tr></tbody></table><h4 id="1-3-css选择器之伪元素选择器"><a href="#1-3-css选择器之伪元素选择器" class="headerlink" title="1.3 css选择器之伪元素选择器"></a>1.3 css选择器之伪元素选择器</h4><table><thead><tr><th>选择器</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>::before/:before</td><td>在被选元素前插入内容。</td><td>需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</td></tr><tr><td>::after/:after</td><td>在选被元素后插入内容</td><td>其用法和特性与:before相似。</td></tr><tr><td>::first-letter/:first-letter</td><td>匹配元素中文本的首字母。</td><td>被修饰的首字母不在文档树中。</td></tr><tr><td>::first-line/:first-line</td><td>匹配元素中第一行的文本。</td><td>这个伪元素只能用在块元素中，不能用在内联元素中。</td></tr><tr><td>::selection</td><td>::selection匹配用户被用户选中或者处于高亮状态的部分</td><td>在火狐浏览器使用时需要添加-moz前缀。该伪元素只支持双冒号的形式。</td></tr><tr><td>::placeholder</td><td>::placeholder匹配占位符的文本，只有元素设置了placeholder属性时，该伪元素才能生效。</td><td>该伪元素不是CSS的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（IE10和Firefox18及其以下版本）会使用单冒号的形式。</td></tr><tr><td>::backdrop(处于试验阶段)</td><td>::backdrop用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色</td><td>该伪元素只支持双冒号的形式</td></tr></tbody></table><h4 id="1-4-css选择器之属性选择器"><a href="#1-4-css选择器之属性选择器" class="headerlink" title="1.4 css选择器之属性选择器"></a>1.4 css选择器之属性选择器</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>[attribute]</td><td>a[target]</td><td>用于选择具有指定属性的元素</td></tr><tr><td>[attribute=”value”]</td><td>a[target=”_blank”]</td><td>用于选择具有指定属性和值的元素</td></tr><tr><td>[attribute~=”value”]</td><td>[title~=”flower”]</td><td>于选择包含指定单词的属性值的元素</td></tr><tr><td>[attribute|=”value”]</td><td>[class|=”top”]</td><td>用于选取带有以指定值(此处<code>top-</code>)开头的属性值的元素</td></tr><tr><td>[attribute^=”value”]</td><td>[class^=”top”]</td><td>用于选择属性值以指定值(此处<code>top</code>)<code>开始</code>的元素</td></tr><tr><td>[attribute$=”value”]</td><td>[class$=”test”]</td><td>用于选择属性值以指定值结束的元素</td></tr><tr><td>[attribute*=”value”]</td><td>[class*=”te”]</td><td>用于选择属性值包含指定值的元素</td></tr></tbody></table><h3 id="2-清除浮动（代码示例）"><a href="#2-清除浮动（代码示例）" class="headerlink" title="2. 清除浮动（代码示例）"></a>2. 清除浮动（<a href="https://github.com/hello-astar/js/blob/master/clear-float.html">代码示例</a>）</h3><p>父元素没有设置高度，子元素浮动会导致父元素坍塌，此时内容会溢出容器外导致布局受影响。这种现象称为浮动。</p><ul><li><p>父级 div 定义 height<br>原理：父级 div 手动定义 height，就解决了父级 div 无法自动获取到高度的问题。<br>优点：简单、代码少、容易掌握<br>缺点：只适合高度固定的布局</p></li><li><p>在浮动元素后添加一个空标签<code>&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</code>，并且在CSS中设置.clear{clear:both;}，即可清理浮动。<br>官方对clear属性解释：“元素盒子的边不能和前面的浮动元素相邻”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。<br><img src="1-clear-float.png" alt="这里写图片描述"><br>原理：添加一个空标签，利用CSS提高的clear:both清除浮动，让父元素可以自动获取到高度<br>优点：简单，代码少，兼容所有浏览器<br>缺点：增加页面的标签，造成结构的混乱<br>建议：不推荐使用，此方法已经过时</p></li><li><p><strong>:after伪元素</strong><br><img src="2-clear-float.png" alt="这里写图片描述"><br>  原理：通过CSS伪元素在容器的内部元素之后添加一个看不见的空格“\20”或点“.” ，并且设置clear属性清除浮动。IE8 以上和非 IE 浏览器才支持:after，原理和方法 2 有点类似，<code>*zoom</code>(IE 专有属性，IE版本的BFC（Layout），可通过 <code>*zoom:1</code> 触发)可解决ie6，ie7 浮动问题 ，推荐使用，建议定义公共类，以减少 CSS 代码<br>  优点：浏览器支持较好<br>  缺点：clearfix这个class需要添加<code>*zoom: 1</code>（触发haslayout,当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位），才能支持IE6和IE7浏览器<br>  建议：推荐使用，设置公共类，减少CSS代码</p></li><li><p>父级元素定义：<code>overflow:auto/hidden; *zoom:1</code>，触发BFC特性。</p></li></ul><h3 id="3-盒子模型"><a href="#3-盒子模型" class="headerlink" title="3. 盒子模型"></a>3. 盒子模型</h3><ul><li>标准盒子模型（width和height属性只包含content）<br>宽度 = 内容的宽度（content）+ border + padding + margin<br>高度 = 内容的高度（content）+ border + padding + margin</li><li>低版本IE盒子模型（width和height属性包含了content、border、padding）<br>宽度 = 内容宽度（content + border + padding）+ margin<br>高度 = 内容高度（content + border + padding）+ margin</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型</p><ul><li>box-sizeing: content-box 表示标准盒模型（默认值）</li><li>box-sizeing: border-box 表示IE盒模型（怪异盒模型）</li></ul><h3 id="4-css中可以继承的样式"><a href="#4-css中可以继承的样式" class="headerlink" title="4. css中可以继承的样式"></a>4. css中可以继承的样式</h3><p>可继承的属性：font-size, font-family, color<br>不可继承的属性：border, padding, margin, width, height</p><h3 id="5-BFC（块级格式化上下文）"><a href="#5-BFC（块级格式化上下文）" class="headerlink" title="5. BFC（块级格式化上下文）"></a>5. <a href="https://zhuanlan.zhihu.com/p/25321647">BFC（块级格式化上下文）</a></h3><blockquote><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p></blockquote><blockquote><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul></blockquote><blockquote><p>BFC的特点：</p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul></blockquote><h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><ul><li><p>解决margin的重叠问题（<a href="https://www.jianshu.com/p/a7ead28910f4">margin合并</a>）<br>毗邻元素处于同一BFC中，将会发生外边距合并。</p><blockquote><p>In this specification, the expression collapsing margins means that adjoining margins (no non-empty content, padding or border areas or clearance separate them) of two or more boxes (which may be next to one another or nested) combine to form a single margin. 所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套的盒元素，并且它们之间没有非空内容、Padding或Border分隔。</p></blockquote><p>  <a href="https://github.com/hello-astar/js/blob/master/merge-margin.html">示例代码</a></p></li><li><p>解决高度塌陷的问题（父元素设置overflow: auto/hidden）<br>原理：计算BFC的高度时，需要计算浮动元素的高度</p></li><li><p>创建自适应两栏布局（左侧固定宽度，右侧自适应）<br>原理：BFC区域不会与浮动的容器发生重叠<br>实现方法：左侧浮动，右侧变为BFC。</p></li></ul><h3 id="6-两栏布局和三栏布局实现"><a href="#6-两栏布局和三栏布局实现" class="headerlink" title="6. 两栏布局和三栏布局实现"></a>6. 两栏布局和三栏布局实现</h3><h4 id="6-1-两栏布局"><a href="#6-1-两栏布局" class="headerlink" title="6.1 两栏布局"></a>6.1 两栏布局</h4><ul><li>左侧浮动，右侧magin-left</li><li>左侧浮动，右侧bfc(overflow: hidden)</li><li>左侧绝对定位，右侧magin-left</li><li>右侧绝对定位left: 200px</li><li>flex: 1</li></ul><h4 id="6-2-三栏布局"><a href="#6-2-三栏布局" class="headerlink" title="6.2 三栏布局"></a>6.2 三栏布局</h4><ul><li>左右侧绝对定位，中间margin</li><li>利用浮动</li><li>flex: 1</li><li>利用负margin（<a href="https://blog.csdn.net/Tracy_frog/article/details/77509450">css布局——双飞翼布局和圣杯布局</a>）</li><li>calc</li></ul><p><a href="https://github.com/hello-astar/js/blob/master/position.html">示例代码</a></p><h3 id="7-居中布局的实现"><a href="#7-居中布局的实现" class="headerlink" title="7. 居中布局的实现"></a>7. <a href="https://www.cnblogs.com/coco1s/p/4444383.html">居中布局的实现</a></h3><p>以下为简单总结：</p><ul><li>行内元素水平居中 <code>text-align: center;</code></li><li>块状元素水平居中<code>margin: 0 auto;</code></li><li>多个块状元素水平居中<br><code>1. display: inline-block; 和text-align: center;配合使用</code><br><code>2. flex布局</code></li><li>已知高度宽度元素水平垂直居中<br><code>1. 绝对定位与负margin方法</code><br><code>2. display: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;</code></li><li>未知宽度高度元素水平垂直居中<br><code>1. 将子元素改为inline或inline-block，然后设置父元素display: table-cell; text-align: center; vertical-align: middle;</code><br><code>2. translate -50%方法</code><br><code>3. flex布局</code></li></ul><h3 id="8-postion几个属性的作用？"><a href="#8-postion几个属性的作用？" class="headerlink" title="8. postion几个属性的作用？"></a>8. postion几个属性的作用？</h3><p>position 的常见四个属性值： relative，absolute，fixed，static。一般都要配合”left”、”top”、”right”以及 “bottom” 属性使用。<br>1）Static静态定位：<code>默认位置</code>，设置为 static  的元素，它始终会处于页面流给予的位置（static  元素会忽略任何 top、bottom、left 或 right 声明）。一般不常用。<br>2）Relative相对定位：位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，意思就是如果设置了 relative 值，那么，它偏移的 top，right，bottom，left 的值都以它原来的位置为基准偏移，而不管其他元素会怎么样。<code>注意 relative 移动后的元素在原来的位置仍占据空间</code>。<br>3）Absolute绝对定位：位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。意思就是如果它的父容器设置了 position 属性，并且 position 的属性值为 absolute 或者relative，那么就会依据父容器进行偏移。<code>如果其父容器没有设置 position 属性，那么偏移是以 body 为依据</code>。<code>注意设置 absolute 属性的元素在标准流中不占位置</code>。<br>4）Fixed固定定位：位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。不论窗口滚动与否，元素都会留在那个位置。它始终是以 body 为依据的。 <code>注意设置 fixed 属性的元素在标准流中不占位置</code>。</p><h3 id="9-对Flex布局的理解及其使用场景"><a href="#9-对Flex布局的理解及其使用场景" class="headerlink" title="9. 对Flex布局的理解及其使用场景"></a>9. 对Flex布局的理解及其使用场景</h3><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a></p><h3 id="10-display-none与visibility：hidden的区别？"><a href="#10-display-none与visibility：hidden的区别？" class="headerlink" title="10. display:none与visibility：hidden的区别？"></a>10. display:none与visibility：hidden的区别？</h3><p>display：none 不显示对应的元素，在文档布局中不再分配空间（重排+重绘）<br>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><h3 id="11-当margin-top、padding-top的值是百分比时，分别是如何计算的？"><a href="#11-当margin-top、padding-top的值是百分比时，分别是如何计算的？" class="headerlink" title="11. 当margin-top、padding-top的值是百分比时，分别是如何计算的？"></a>11. 当margin-top、padding-top的值是百分比时，分别是如何计算的？</h3><p>对元素的margin设置百分数，是相对于<code>父元素</code>的<code>width</code>计算的，不管是margin-top/margin-bottom/margin-left还是margin-right。（padding同理）</p><h3 id="12-重排和重绘"><a href="#12-重排和重绘" class="headerlink" title="12. 重排和重绘"></a>12. 重排和重绘</h3><p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。<br>重排是更明显的一种改变，可以理解为渲染树需要重新计算。下面是常见的触发重排的操作：<br>1）DOM 元素的几何属性变化<br>2）DOM 树的结构变化<br>3）获取某些属性<br>4）此外，改变元素的一些样式，调整浏览器窗口大小等等也都将触发重排。<br>注：重排对性能有很大的影响。</p><h3 id="13-css3-html5-es6的新特性"><a href="#13-css3-html5-es6的新特性" class="headerlink" title="13. css3,html5,es6的新特性"></a>13. css3,html5,es6的新特性</h3><p><a href="https://www.jianshu.com/p/d61bf4f36235">css3新特性</a><br><a href="https://github.com/2320390964/notes/issues/2">html5的新特性</a><br><a href="http://imweb.io/topic/55e330d6771670e207a16bbb">es6的新特性</a><br>let/const、class、扩展运算符、rest参数、模板字符串、Set、变量的解构赋值、Symbol（一种新的原始数据类型，表示独一无二的ID，它通过Symbol函数生成）</p><h3 id="14-CSS优化、提高性能的方法有哪些？"><a href="#14-CSS优化、提高性能的方法有哪些？" class="headerlink" title="14. CSS优化、提高性能的方法有哪些？"></a>14. CSS优化、提高性能的方法有哪些？</h3><h4 id="14-1-加载性能"><a href="#14-1-加载性能" class="headerlink" title="14.1 加载性能"></a>14.1 加载性能</h4><ul><li>css包压缩，减小文件体积</li><li>css单一样式，当需要下边距和左边距的时候，很多时候会选择使用<code>margin:top 0 bottom 0;</code> 但<code>margin-bottom:bottom;margin-left:left;</code>执行效率会更高。</li><li>减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ul><h4 id="14-2-选择器性能"><a href="#14-2-选择器性能" class="headerlink" title="14.2 选择器性能"></a>14.2 选择器性能</h4><ul><li>CSS选择符是从右到左进行匹配的，所以选择器最后面部分为最关键部分，如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）</li><li>避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</li><li>尽量少的去对标签进行选择，而是用class。</li><li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则</li></ul><h4 id="14-3-渲染性能"><a href="#14-3-渲染性能" class="headerlink" title="14.3 渲染性能"></a>14.3 渲染性能</h4><ul><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li></ul><h4 id="14-4-可维护性、健壮性"><a href="#14-4-可维护性、健壮性" class="headerlink" title="14.4 可维护性、健壮性"></a>14.4 可维护性、健壮性</h4><ul><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ul><h3 id="15-link和-import的区别"><a href="#15-link和-import的区别" class="headerlink" title="15. link和@import的区别"></a>15. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="16-对-CSS-Sprites-的理解"><a href="#16-对-CSS-Sprites-的理解" class="headerlink" title="16. 对 CSS Sprites 的理解"></a>16. 对 CSS Sprites 的理解</h3><p>CSS Sprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；<br>CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；<br>CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。</p><h4 id="维护方面："><a href="#维护方面：" class="headerlink" title="维护方面："></a>维护方面：</h4><p>CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。</p><h3 id="17-px，em，rem-的区别？"><a href="#17-px，em，rem-的区别？" class="headerlink" title="17. px，em，rem 的区别？"></a>17. px，em，rem 的区别？</h3><p> 1）px 像素（Pixel）。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度 DPI。<br>2）em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。<br>3）rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。<br>4）区别：IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。</p><h3 id="18-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#18-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="18. 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>18. 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h3><p>响应式网站设计(Responsive Web design)是<strong>一个网站能够兼容多个终端</strong>，而不是为每一个终端做一个特定的版本。</p><p>实现方法：@media + viewport</p><ul><li>媒体查询（@media），基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。pc端和移动端使用同一个项目，使用媒体查询实现响应式。缺点是要写很多样式，十分复杂。<br>下面简单使用媒体查询，使两栏布局在小屏设备下隐藏左侧。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 屏幕大小小于768px时候，隐藏左侧</span><br><span class="line">.left &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123; &#x2F;&#x2F; 屏幕大小大于等于768px时候，展示左侧</span><br><span class="line">.left &#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>网格和媒体查询结合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* For mobile phones: *&#x2F;</span><br><span class="line">[class*&#x3D;&quot;col-&quot;] &#123;</span><br><span class="line">width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123;</span><br><span class="line">&#x2F;* For desktop: *&#x2F;</span><br><span class="line">.col-1 &#123;width: 8.33%;&#125;</span><br><span class="line">.col-2 &#123;width: 16.66%;&#125;</span><br><span class="line">.col-3 &#123;width: 25%;&#125;</span><br><span class="line">.col-4 &#123;width: 33.33%;&#125;</span><br><span class="line">.col-5 &#123;width: 41.66%;&#125;</span><br><span class="line">.col-6 &#123;width: 50%;&#125;</span><br><span class="line">.col-7 &#123;width: 58.33%;&#125;</span><br><span class="line">.col-8 &#123;width: 66.66%;&#125;</span><br><span class="line">.col-9 &#123;width: 75%;&#125;</span><br><span class="line">.col-10 &#123;width: 83.33%;&#125;</span><br><span class="line">.col-11 &#123;width: 91.66%;&#125;</span><br><span class="line">.col-12 &#123;width: 100%;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>创建适应不同设备的方向(横屏landscape、竖屏portrait等)的布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果是竖屏背景将是浅蓝色：</span><br><span class="line">@media only screen and (orientation: landscape) &#123;</span><br><span class="line">body &#123;</span><br><span class="line">background-color: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>响应式网页设计之<strong>viewport</strong><br>Viewport 是用户网页的可视区域。<br>Viewport 随设备而异，在移动手机上比在电脑屏幕上要小。<br>在平板电脑和移动手机之前，网页只为电脑屏幕设计，网页的静态设计和固定大小是很常见的。<br>然后，当我们开始使用平板电脑和手机上网的时候，固定大小的网页太大了，不适合观看。为了解决这个问题，这些设备上的浏览器<code>缩小了整个网页</code>以适应屏幕。<br>这并不完美！但可快速修复。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0, maximum-scale&#x3D;1,user-scalable&#x3D;no&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>&lt;meta&gt; 窗口元素为浏览器提供了如何控制页面尺寸和缩放的说明。<br>width=device-width 部分将页面的宽度设置为跟随设备的屏幕宽度（其将根据设备变化而变化）。<br>initial-scale=1.0 部分设置浏览器首次加载页面时的初始缩放级别。</li></ul><h3 id="19-根据设计稿进行移动端web页面适配的方案"><a href="#19-根据设计稿进行移动端web页面适配的方案" class="headerlink" title="19. 根据设计稿进行移动端web页面适配的方案"></a>19. 根据设计稿进行移动端web页面适配的方案</h3><p>移动端适配主要有两个维度：</p><ul><li>适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li>适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>实现方案：</p><ul><li>媒体查询</li><li>flex弹性布局</li><li>rem 只用rem可以实现适配不同屏幕大小，但不能适配不同像素密度。<br>原理：<ul><li>htmlFontSize = 100 * clientWidth / baseWidth + ‘px’，则设计稿上的100px是页面上的1rem</li></ul></li><li>rem + viewport （<a href="https://github.com/hello-astar/js/tree/master/mobileAdaptation">示例代码</a>）<br><img src="3-viewport-rem.png"><br>原理：<ul><li>viewport设置scale = 1 / dpr，页面缩小到1个css像素由1个设备像素来显示，此时clientWidth = screenWidth * dpr。</li><li>rem设置clientWidth(屏幕宽度) / baseWidth(设计稿宽度)，相当于增加css像素数量，占满设备屏幕。</li><li>字体最好使用px，考虑到使用rem会随着屏幕大小改变字体的大小，我们希望在不同屏幕上看到字体大小是一样的。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">width: 1rem; </span><br><span class="line">height: 0.4rem;</span><br><span class="line">font-size: 12px; &#x2F;&#x2F; 默认写上dpr为1的fontSize</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr&#x3D;&quot;2&quot;] div &#123;</span><br><span class="line">font-size: 24px;</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr&#x3D;&quot;3&quot;] div &#123;</span><br><span class="line">font-size: 36px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  封装一个sass混合宏，提高开发效率  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@mixin font-dpr($font-size)&#123;</span><br><span class="line">font-size: $font-size;</span><br><span class="line">[data-dpr&#x3D;&quot;2&quot;] &amp; &#123;</span><br><span class="line">font-size: $font-size * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[data-dpr&#x3D;&quot;3&quot;] &amp; &#123;</span><br><span class="line">font-size: $font-size * 3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  使用如下  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@include font-dpr(16px);</span><br></pre></td></tr></table></figure>参考</li></ul></li><li><a href="https://www.cnblogs.com/2050/p/3877280.html">移动前端开发之viewport的深入理解</a></li><li><a href="https://segmentfault.com/a/1190000008767416">移动端Web页面适配方案</a></li><li><a href="http://caibaojian.com/flexible-js.html">flexible.js 布局详解</a></li></ul><h3 id="20-1px边框问题（示例代码）"><a href="#20-1px边框问题（示例代码）" class="headerlink" title="20. 1px边框问题（示例代码）"></a>20. 1px边框问题（<a href="https://github.com/hello-astar/js/blob/master/1pxborder.html">示例代码</a>）</h3><ul><li>直接把 1px 改成 1/dpr 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</li><li>利用伪元素 + <code>transform: scale(0.5)</code>实现</li><li><code>box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);</code></li><li><code>linear-gradient</code></li><li>viewport将1px处理成物理像素大小</li></ul><h3 id="21-设置小于12px的字体"><a href="#21-设置小于12px的字体" class="headerlink" title="21. 设置小于12px的字体"></a>21. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。<br>解决办法：</p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="22-z-index属性"><a href="#22-z-index属性" class="headerlink" title="22. z-index属性"></a>22. z-index属性</h3><blockquote><p>z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指<code>同级元素</code>间的堆叠，如果两个对象的此属 性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系 的，一定是子级在上父级在下。<br>Note：使用static定位或无position定位的元素z-index属性是无效的。</p></blockquote><h3 id="23-对requestAnimationframe的理解"><a href="#23-对requestAnimationframe的理解" class="headerlink" title="23. 对requestAnimationframe的理解"></a>23. 对requestAnimationframe的理解</h3><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。<br>MDN对该方法的描述：</p><blockquote><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p></blockquote><p>语法： window.requestAnimationFrame(callback);  其中，callback是下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于宏任务，所以会在执行完微任务之后再去执行。<br>取消动画： 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p><p>优势：</p><ul><li>CPU节能：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li><li>函数节流：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li><li>减少DOM操作：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li></ul><p>setTimeout执行动画的缺点：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p><ul><li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li><li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li></ul><h3 id="24-常见的图片格式及使用场景"><a href="#24-常见的图片格式及使用场景" class="headerlink" title="24. 常见的图片格式及使用场景"></a>24. 常见的图片格式及使用场景</h3><p>（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。<br>（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。<br>（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。<br>（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。<br>（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。<br>（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。<br>（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><p>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；<br>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；<br>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</p><h3 id="25-实现宽高自适应的正方形"><a href="#25-实现宽高自适应的正方形" class="headerlink" title="25. 实现宽高自适应的正方形"></a>25. 实现宽高自适应的正方形</h3><ol><li>利用padding-top百分比是相对于父元素的width<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.square &#123;</span><br><span class="line">  width: 20%; &#x2F;&#x2F; 等于父元素width * 20%</span><br><span class="line">  height: 0;</span><br><span class="line">  padding-top: 20%; &#x2F;&#x2F; 等于父元素width * 20%</span><br><span class="line">  background: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用子元素margin-top百分比是相对于父元素的width<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.square &#123;</span><br><span class="line">  width: 30%; &#x2F;&#x2F; 等于父元素width * 30%</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  background: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.square::after &#123;</span><br><span class="line">  content: &#39;&#39;;</span><br><span class="line">  display: block;</span><br><span class="line">  margin-top: 100%; &#x2F;&#x2F; 等于父元素width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-css选择器&quot;&gt;&lt;a href=&quot;#1-css选择器&quot; class=&quot;headerlink&quot; title=&quot;1. css选择器&quot;&gt;&lt;/a&gt;1. css选择器&lt;/h3&gt;&lt;p&gt;一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。&lt;b</summary>
      
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>思考：在浏览器中，输入URL回车后发生了什么？</title>
    <link href="http://example.com/2021/12/12/%E6%80%9D%E8%80%83%EF%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8C%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2021/12/12/%E6%80%9D%E8%80%83%EF%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8C%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2021-12-12T13:35:34.000Z</published>
    <updated>2022-03-17T09:26:56.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、URL构建和编码（浏览器进程）"><a href="#一、URL构建和编码（浏览器进程）" class="headerlink" title="一、URL构建和编码（浏览器进程）"></a>一、URL构建和编码（浏览器进程）</h2><h3 id="1、用户输入"><a href="#1、用户输入" class="headerlink" title="1、用户输入"></a>1、用户输入</h3><p>用户在地址栏输入关键字后，地址栏会首先判断输入的是搜索内容还是请求的URL。如果是搜索内容，则会使用浏览器默认的搜索引擎，合成新的带搜索关键字的URL，如果是地址，则会组装协议（加上http/https之类的）合成完整url，同时进行URL编码。</p><h3 id="2、URL编码"><a href="#2、URL编码" class="headerlink" title="2、URL编码"></a>2、URL编码</h3><p>一般来说，URL只能使用英文字母、阿拉伯数字和特殊标点符号（如<code>$ - _ . + ! * &#39; ( ) , </code>等等）以及某些保留字，不能使用其他文字和符号。如果要使用其他文字和符号，只能经过编码后才能使用。</p><p>由于不同的操作系统、不同的浏览器、不同的网页字符集，可能导致完全不同的编码结果，我们最好使用encodeURIComponent（utf-8编码）进行编码。</p><blockquote><p>encodeURIComponent()与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。<br>因此，<code>; / ? : @ &amp; = + $ , #</code>，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。</p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html">参考-关于URL编码</a></p><h2 id="二、URL请求阶段（网络进程）"><a href="#二、URL请求阶段（网络进程）" class="headerlink" title="二、URL请求阶段（网络进程）"></a>二、URL请求阶段（网络进程）</h2><blockquote><p>浏览器进程通过进程间通信（IPC）把URL请求发送至网络进程，网络进程收到URL请求后，会在这里发起真正的URL请求流程。</p></blockquote><h3 id="1、URL解析"><a href="#1、URL解析" class="headerlink" title="1、URL解析"></a>1、URL解析</h3><p>浏览器会通过URI和方法来判断“对什么”“进行怎样的操作”，并根据这些要求来完成自己的工作。浏览器是一个具备多种客户端功能的综合性客户端软件，它可以向web服务器发送和接收数据，也可以通过ftp服务器上传下载文件，也可以用于发送电子邮件等等。所以浏览器首先会解析url分析访问的是什么类型的服务器，从而生成发送给该服务器的请求消息。</p><p>我们这里只讨论通过URL访问web服务器的情况.</p><p>URL基本格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schema:&#x2F;&#x2F;host[:port#][path][?query-string][#anchor]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mywebsite.com&#x2F;sj&#x2F;test&#x2F;test.aspx?name&#x3D;sviergn&amp;x&#x3D;true#stuff</span><br></pre></td></tr></table></figure><p>浏览器通过schema得到访问web服务器的底层协议，http或者https等，通过host得到服务器IP地址或者域名，通过port得到连接端口号（http默认80，https默认443），同时得到所访问的资源的路径和锚以及发送给web服务器的数据。</p><h3 id="2、HSTS"><a href="#2、HSTS" class="headerlink" title="2、HSTS"></a>2、HSTS</h3><p>HSTS(HTTP Strict Transport Security，http严格传输安全)是一种新的Web安全协议，作用是强制客户端使用https与服务器创建连接，以减少会话劫持的风险。<br>比如你在地址栏输入<code>http://xxx.com</code>，浏览器会先在<code>本地</code>替换为<code>https://xxx.com</code>再发送请求。</p><p><strong>缺点</strong></p><p>用户<code>首次</code>访问某网站是不受HSTS保护的。这是因为首次访问时，浏览器还未记录HSTS，所以仍发送明文数据，如果这时候被中间人拦截了，就会引发安全问题（不过相对服务器重定向还是好多了，重定向方法<code>每次</code>请求都有可能被攻击）。解决方案是加入preload list，但是加入申请不一定能通过。</p><blockquote><p>浏览器厂商们为了解决这个问题，提出了HSTS Preload List方案：内置一份可以定期更新的列表，对于列表中的域名，即使用户之前没有访问过，也会使用HTTPS协议。<br>目前这个Preload List由Google Chrome维护，Chrome、Firefox、Safari、IE 11和Microsoft Edge都在使用。</p></blockquote><p><strong>优点</strong></p><p>使用HSTS代替301、302重定向，当输入http网址时，只由浏览器来决定重定向至https，而不需服务器端的重定向。</p><p>nginx配置也很简单，首先要支持https，然后在<code>nginx.conf</code>加入以下代码，重启nginx即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl https;</span><br><span class="line">    server_name www.xxx.com;</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubdomains; preload&quot;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置了下，发现chrome返回307状态码并自动转换到https了。</p><p><a href="https://www.huaweicloud.com/articles/fb6757dacce580e4cfea40cadeaf368a.html">参考-开启HSTS让浏览器强制跳转HTTPS访问</a></p><h3 id="3、查找本地缓存"><a href="#3、查找本地缓存" class="headerlink" title="3、查找本地缓存"></a>3、查找本地缓存</h3><ol><li>service worker：如果有service worker的话，service worker会拦截请求，查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，响应200(from service worker)。</li><li>没有service worker就是我们常规的浏览器缓存机制了。首先看看本地有没有缓存，没有缓存则请求最新数据返回200。</li><li>强缓存：浏览器会根据<code>catche-control/expires</code>（catche-control优先级高于expires）检测缓存有没有过期，没有过期就从本地缓存读取数据，返回200。（cache-control根据客户端时间校验新鲜度，expires根据服务器和客户端时间对比校验新鲜度-&gt;这会出现服务器时间跟客户端时间不一致导致的问题）</li><li>协商缓存：如果发现已经超过max-age时长了，就走<code>协商缓存</code>，由服务器判断缓存是否过期。根据之前服务端返回的<code>etag/last-modified</code>等头部信息，生成<code>if-none-match/if-modified-since</code>请求头发送至服务端，判断本地缓存是否过期，过期了服务器只能发送最新数据和新的<code>etag/last-modified</code>，返回200并更新本地缓存，没有过期就还是从本地缓存读取数据返回304。协商缓存之前要经过DNS域名解析，之后建立TCP链接，这些内容将在下面的篇幅中提及。</li></ol><h4 id="缓存的存储位置在哪呢？"><a href="#缓存的存储位置在哪呢？" class="headerlink" title="缓存的存储位置在哪呢？"></a>缓存的存储位置在哪呢？</h4><ol><li>service worker(浏览器独立线程进行缓存，离线缓存)</li><li>memory cache(内存缓存)</li><li>disk cache(硬盘缓存)</li><li>push cache(推送缓存,HTTP/2中的)</li></ol><p>以上缓存的优先级从上到下、从高到低。</p><h4 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h4><p>如果一个可以缓存的请求没有设置Expires和Cache-Control，但是响应头有设置Last-Modified和Date信息，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Date 减去 Last-Modified 值的 10% 作为缓存时间。</span><br><span class="line">&#x2F;&#x2F; Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间</span><br><span class="line">  response_is_fresh &#x3D;  max(0, (Date -  Last-Modified)) % 10</span><br></pre></td></tr></table></figure><h4 id="启发式缓存会引起什么问题吗？"><a href="#启发式缓存会引起什么问题吗？" class="headerlink" title="启发式缓存会引起什么问题吗？"></a>启发式缓存会引起什么问题吗？</h4><blockquote><p>考虑一个情况，假设你有一个文件没有设置缓存时间，在一个月前你更新了上个版本。这次发版后，你可能得等到3天后用户才看到新的内容了。如果这个资源还在CDN也缓存了，则问题会更严重。<br>所以，要给资源设置合理的缓存时间。不要不设置缓存，也不要设置过长时间的缓存。强缓存时间过长，则内容要很久才会覆盖新版本，缓存时间过短，服务器可能背不住。一般带hash的文件缓存时间可以长一点。</p></blockquote><p>设置页面禁止缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Cache-Control&quot; content&#x3D;&quot;no-cache, no-store, must-revalidate&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Pragma&quot; content&#x3D;&quot;no-cache&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Expires&quot; content&#x3D;&quot;0&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><ul><li>no-cache : 协商缓存</li><li>no-store : 不缓存</li><li>must-revalidate : 过期强制请求服务器</li></ul><h3 id="4、DNS解析"><a href="#4、DNS解析" class="headerlink" title="4、DNS解析"></a>4、DNS解析</h3><p>计算机实际是通过IP地址来标记的，DNS服务可将<code>符合人类记忆习惯</code>的域名地址解析为<code>计算机可理解</code>的服务器的IP地址。</p><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p><img src="dns.jpg" alt="DNS域名解析过程"></p><ol><li>递归查询</li></ol><p>我们的浏览器、操作系统、路由器都会缓存一些URL对应的IP地址，统称为<code>DNS高速缓存</code>。这是为了加快DNS解析速度，使得不必每次都到根域名服务器中去查询（这个缓存是有有效期的，过期删除，以提高信息的时效性）。这个查询过程是通过递归查询的方式实现的。</p><ul><li>首先搜索浏览器自身的DNS缓存，有缓存直接返回。</li><li>浏览器自身DNS缓存不存在映射关系，浏览器就会调用一个类似<code>gethostbyname</code>的程序组件（也就是解析器），此组件会先去检测本地hosts文件，查看是否有对应ip。</li><li>如果本地hosts文件不存在映射关系，就会查询路由缓存。</li><li>路由缓存不存在该映射就去查找计算机配置的DNS服务器的缓存。（一般TCP/IP参数里会设首选DNS服务器，通常是8.8.8.8）<br><img src="dns%E9%85%8D%E7%BD%AE.png" alt="计算机配置DNS服务器"></li></ul><p>打开命令行，输入<code>ipconfig /all</code>可以查看本地DNS服务器地址。</p><ul><li>如果还没找到就会委托本地DNS服务器向根域DNS服务器发出请求。</li></ul><ol start="2"><li>迭代查询</li></ol><p>DNS高速缓存查不到只能委托本地DNS服务器去访问各个域名服务器一个一个询问。（可以递归也可以迭代，但一般使用迭代查询）</p><blockquote><p>迭代查询的方式就是，局部的DNS服务器并不会自己向其他服务器进行查询，而是把能够解析该域名的服务器IP地址返回给查询者，查询者会不断的向这些服务器进行查询，直到查询到最终结果，迭代的话只会帮你找到相关的服务器，然后说我现在比较忙，你自己去找吧。</p></blockquote><ul><li>本地DNS服务器代我们的浏览器发起迭代DNS解析请求，首先它向根域DNS服务器发起请求（互联网的所有DNS服务器都会保存根域的DNS服务器地址），“请问<code>www.baidu.com</code>这个域名的IP地址是多少呀？”；（分配给根域DNS服务器的IP地址全球仅13个，它们使用多台服务器对应一个IP地址，所以尽管根域IP地址少，服务器却是很多的。）</li><li>根域根据这个域名的结构发现其属于com域，于是告诉本地DNS服务器“我不知道这个域名的IP地址,但是我知道com域DNS服务器的IP地址，你去找它去吧”；</li><li>于是本地DNS服务器又向com域DNS服务器发起了请求，“请问<code>www.baidu.com</code>这个域名的IP地址是多少呀?”,com域DNS服务器告诉本地DNS服务器：“我不知道<code>www.baidu.com</code>这个域名的IP地址，但是我知道baidu这个域的所在的DNS服务器地址，你去找它去”;</li><li>…顺藤摸瓜，最后本地DNS服务器找到了目标DNS服务器</li><li>于是本地DNS服务器又向目标DNS服务器发起请求（请问<code>www.baidu.com</code>这个域名的IP地址是多少？），这个时候目标DNS服务器一查，“呀！果真在我这耶”，于是就把找到的结果发送给本地DNS服务器;</li><li>这个时候本地DNS服务器就拿到了<code>www.baidu.com</code>这个域名对应的IP地址，将结果返回给解析器，解析器将结果写入操作系统内存空间，给浏览器读取。</li></ul><p>以上展示的是基本原理。在真实的互联网中，一台DNS服务器可以管理多个域的信息，因此不是像上面那样每个域都有自己的DNS服务器，现实中上级域和下级域有可能共享一台DNS服务器，在这种情况下，访问上级DNS服务器时就可以向下跳过一级DNS服务器，直接返回再下一级的DNS服务器的相关信息。</p><h4 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h4><blockquote><p>DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒。</p></blockquote><p>在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</p><ul><li><p><code>减少DNS请求次数</code>。最理想的方法就是将所有的内容资源（页面、脚本、样式表、图片等）都放在同一个域(Domain)下面，这样访问整个网站就只需要进行一次DNS查找，这样可以提高性能。</p></li><li><p><code>DNS预获取</code>。DOM还没开始，浏览器预解析地址，把解析好的地址放在本地缓存里面，DOM树生成完，要加载图片类的发现DNS已经解析好了，再发送请求。主要用于图片资源等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&#39;dns-prefetch&#39; href&#x3D;&#39;&#x2F;&#x2F;dfns.tanx.com&#39;&gt; &#x2F;&#x2F; 此代码预获取dfns.tanx.com这个域名的IP地址</span><br></pre></td></tr></table></figure></li><li><p>利用<code>DNS负载均衡</code>技术。一个网站如果只有一个服务器，访问量过大时很容易挂掉。DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器会根据每台机器的负载量、与用户的距离等情况返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。该技术常见的应用是CDN（Content Delivery Network）。</p></li></ul><h4 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h4><h4 id="网络号和主机号以及子网掩码"><a href="#网络号和主机号以及子网掩码" class="headerlink" title="网络号和主机号以及子网掩码"></a>网络号和主机号以及子网掩码</h4><blockquote><p>IP地址是一串32位的数字，按照8比特（1字节）为一组分成4组，分别用十进制标识然后再用圆点隔开。</p></blockquote><p>IP地址由网络号和主机号组成，加起来总共32位，但这两部分的具体结构是不固定的。在组建网络时，用户可以自行决定他们直接的分配关系，因此，我们还需要另外的附加信息（子网掩码）来表示IP地址的内部结构。</p><p>子网掩码32位（与IP地址相同），左边部分为1，右边部分为0，其中子网掩码为1的部分表示网络号，为0的部分表示主机号。举个例子，子网掩码255.255.255.0，255的二进制为八个1，此处3个255，即IP地址前24位为网络号，后8位为主机号。</p><p>主机号部分的比特全部为0或者全部为1时代表两种特殊的含义。全为0代表整个子网而不是子网中的某台设备，全为1代表向子网上所有设备发送包，即广播。</p><h3 id="5、TCP握手建立连接"><a href="#5、TCP握手建立连接" class="headerlink" title="5、TCP握手建立连接"></a>5、TCP握手建立连接</h3><blockquote><p>知道了IP地址之后，就可以委托操作系统内部的协议栈向这个目标IP地址，也就是我们要访问的Web服务器发送消息了。</p></blockquote><!--### 委托协议栈发送消息过程(DNS解析也有此过程)--><!--1. `创建`套接字--><!--2. 将管道`连接`到服务器端的套接字上--><!--3. `收发`数据--><!--4. `断开`管道并删除套接字--><!--### 套接字--><!-- 在一台计算机中，不同进程使用进程号或者进程标识（process ID）唯一地标识。进程号又称端口号。在网络环境中，标识一个进程必须同时使用IP地址和端口号。“套接字”或“套接字”地址表示一个IP地址与对应的一个进程标识。例如，一个IP地址为202.1.2.5客户端使用3022端口号，与一个IP地址为41.8.22.51、端口号为80的web服务器建立TCP连接，那么标识客户端的套接字为“202.1.2.5:3022”，标识服务器端的套接字为“41.8.22.51:80”。--><p>浏览器与服务器通过<code>3次握手</code>建立连接。</p><p><img src="tcp3%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="tcp三次握手.jpg"></p><blockquote><p>TCP协议是面向连接、面向字节流、支持双全工、支持并发连接、提供确认重传与拥塞控制的可靠传输层协议。</p></blockquote><h4 id="TCP握手过程可以发送数据吗？"><a href="#TCP握手过程可以发送数据吗？" class="headerlink" title="TCP握手过程可以发送数据吗？"></a>TCP握手过程可以发送数据吗？</h4><blockquote><p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据。<br>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的SYN报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发SYN报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。<br>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p></blockquote><h4 id="为什么不能是两次握手？"><a href="#为什么不能是两次握手？" class="headerlink" title="为什么不能是两次握手？"></a>为什么不能是两次握手？</h4><p>三次握手是为了确认双方都有接收和发送数据的能力（TCP特点：双全工、可靠）。<br>假设两次握手，客户端要是没有收到服务端的响应，就重新发了一个包请求连接，这时候服务端收到了就发送响应连接成功。第一个包可能由于网络延迟终于送到服务器这边了，这时服务端以为客户端又想连接了就同意连接，发送第二次握手，客户端一看这不是我上次发的失效包吗？不理它，服务端却以为连接成功了，一直等待客户端发送数据，浪费资源。</p><h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><blockquote><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN攻击是一种典型的DoS/DDoS攻击。</p></blockquote><blockquote><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h4 id="扩展知识-1"><a href="#扩展知识-1" class="headerlink" title="扩展知识"></a>扩展知识</h4><ol><li>tcp提供可靠的传输服务，它是怎么保证传输的可靠性的？</li></ol><p><strong>Keywords：</strong> tcp滑动窗口与流量控制；确认重传机制；拥塞窗口与拥塞控制；大文件拆分和数据包排序机制；</p><ul><li>通过序列号和确认应答信号确保了数据不会重复发送和重复接收。</li><li>同时通过超时重发控制保证即使数据包在传输过程中丢失，也能重发保持数据完整。</li><li>通过三次握手，四次挥手建立和关闭连接的连接管理保证了端对端的通信可靠性。</li><li>TCP还使用了滑动窗口控制提高了数据传输效率</li></ul><ol start="2"><li><p>tcp如何通过滑动窗口进行流量控制？</p><blockquote><p>接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量win来表示接收窗口的大小。<br><br>发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。<br><a href="https://www.cnblogs.com/kubidemanong/p/9987810.html">通俗易懂讲解TCP流量控制机制，了解一下</a><br><a href="https://zhuanlan.zhihu.com/p/37379780">TCP流量控制、拥塞控制</a></p></blockquote></li><li><p>tcp如何进行拥塞控制？</p></li></ol><p><strong>keywords：</strong> 慢启动、拥塞避免、快重传<br><a href="https://www.cnblogs.com/kubidemanong/p/12048297.html">图解拥塞控制，这应该是把拥塞控制讲的最通俗易懂的文章了</a></p><ol start="4"><li>udp和tcp的区别？<blockquote><p>像浏览器、邮件等一般的应用程序都是使用TCP收发数据的，而像DNS查询等收发较短的控制数据的时候则使用UDP。</p></blockquote></li></ol><p>UDP（用户数据报协议）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p>TCP（传输控制协议）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p><h3 id="6、HTTPS的SSL-TLS握手（4次握手）"><a href="#6、HTTPS的SSL-TLS握手（4次握手）" class="headerlink" title="6、HTTPS的SSL/TLS握手（4次握手）"></a>6、HTTPS的SSL/TLS握手（4次握手）</h3><p>现在很多网站都用上了https，我们知道，http是明文传输的，这意味着传输内容很容易被中间人窃取或者篡改。具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。</p><p>https相比http，多了一层数据加密，具有<code>防止窃听、防止篡改、防止伪装</code>的特点。</p><p><img src="https.jpg" alt="https"></p><p>需预备知识：非对称加密、对称加密、数字签名。</p><p>这里简单解释下过程，服务器去申请CA证书的时候会得到数字证书（内含公钥1）和私钥1，当浏览器发送请求时，服务器会返回数字证书，浏览器验证证书的合法性后，利用证书内的公钥1加密本地生成的会话密钥，发送给服务器，服务器用私钥1解密得到该会话密钥，这下双方就可以用会话密钥对称加密数据来通信了。</p><p>从以上过程可以看出，https只有在握手的时候使用非对称加密，通信过程使用的是对称加密。</p><h4 id="为什么握手过程使用非对称加密？"><a href="#为什么握手过程使用非对称加密？" class="headerlink" title="为什么握手过程使用非对称加密？"></a>为什么握手过程使用非对称加密？</h4><p>假设握手过程使用对称加密，中间人可以拦截到证书和公钥1，既可以取得客户端信任又能用公钥1破解出会话密钥，接下来破解通信内容就易如反掌了。</p><h4 id="为什么通信却用对称加密呢？"><a href="#为什么通信却用对称加密呢？" class="headerlink" title="为什么通信却用对称加密呢？"></a>为什么通信却用对称加密呢？</h4><p>非对称加密的加解密效率非常低，既然已经验证了服务器的合法性建立了连接，就没必要用非对称加密拉低效率了。另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</p><h4 id="为什么需要-CA-认证机构颁发证书？"><a href="#为什么需要-CA-认证机构颁发证书？" class="headerlink" title="为什么需要 CA 认证机构颁发证书？"></a>为什么需要 CA 认证机构颁发证书？</h4><p>CA证书相当于我们买房子时候发的房产证，房产证有权威机构（国家）进行背书，大家都信任国家，相信拿了这个证这个房子就是自己的。</p><blockquote><p>首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。<br>另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。<br>所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。</p></blockquote><h4 id="如何申请数字证书？"><a href="#如何申请数字证书？" class="headerlink" title="如何申请数字证书？"></a>如何申请数字证书？</h4><blockquote><p>我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：</p><ul><li>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</li><li>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li><li>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li><li>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。<br><br>这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用 Hash 函数来计算极客时间提交的明文信息，并得出信息摘要；然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极客时间的数字签名。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。</li></ul></blockquote><h4 id="用证书怎么验证合法？"><a href="#用证书怎么验证合法？" class="headerlink" title="用证书怎么验证合法？"></a>用证书怎么验证合法？</h4><blockquote><p>浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：</p><ol><li>验证域名、有效期等明文信息是否正确。证书上都有包含这些信息，比较容易完成验证；</li><li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；</li><li>判断证书是否被篡改。需要与 CA 服务器进行校验。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是正确的；</li><li>判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率<br>以上任意一步都满足的情况下浏览器才认为证书是合法的。</li></ol></blockquote><p>综上所述，这个证书也伪造不了，人家直接去问权威机构这证书是不是他们颁布的了。</p><h4 id="本地会话密钥被窃取怎么办？"><a href="#本地会话密钥被窃取怎么办？" class="headerlink" title="本地会话密钥被窃取怎么办？"></a>本地会话密钥被窃取怎么办？</h4><p>证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS 如何保证随机数不会被窃取？</p><p>其实 HTTPS 并不包含对随机数的安全保证，HTTPS 保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。</p><p><a href="https://juejin.cn/post/6844903830916694030">深入理解HTTPS工作原理</a></p><p><a href="https://cloud.tencent.com/developer/article/1601995">终于有人把https原理讲清楚了</a></p><h3 id="7、构建请求报文"><a href="#7、构建请求报文" class="headerlink" title="7、构建请求报文"></a>7、构建请求报文</h3><p>前面浏览器已经解析了URL，现在需要浏览器通过解析的结果生成http请求报文。直接在浏览器地址栏输入URL访问网页是GET方法。<br><img src="%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="请求报文"><br>尽管浏览器能够解析网址并生成HTTP消息，但它本身并不具备将消息发送到网络中的功能，所以生成HTTP消息之后，接下来我们需要委托操作系统将消息发送给web服务器。在发送之前，我们还需要查询服务器域名对应的IP地址。</p><h3 id="8、发送请求"><a href="#8、发送请求" class="headerlink" title="8、发送请求"></a>8、发送请求</h3><p>浏览器不负责请求的网络传输过程，这个过程交由操作系统负责。</p><h4 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h4><p><strong>应用层：</strong> 浏览器生成http请求报文，DNS解析域名。</p><p><strong>传输层：</strong> 负责数据的传输。将从浏览器接收到的消息打包，切割为<code>报文段</code>，并在各个报文上标记目的地址等控制信息，然后，网卡会将报文段转换为电信号并通过网线发送出去。</p><p><strong>网络层：</strong> 接入互联网。IP协议通过ip地址查找MAC地址（<code>ARP协议</code>，解析地址，根据通信方的ip地址反查出对应的MAC地址），在各个路由中间进行<code>路由中转</code>传送数据。</p><p><strong>网络接口层：</strong> 规定了与物理网络的接口。</p><h4 id="从网卡把数据包传输出去到服务器发生了什么？"><a href="#从网卡把数据包传输出去到服务器发生了什么？" class="headerlink" title="从网卡把数据包传输出去到服务器发生了什么？"></a>从网卡把数据包传输出去到服务器发生了什么？</h4><p>参考TCP/IP模型</p><h3 id="9、服务器处理请求并响应请求"><a href="#9、服务器处理请求并响应请求" class="headerlink" title="9、服务器处理请求并响应请求"></a>9、服务器处理请求并响应请求</h3><p>服务器端收到请求后由web server处理请求，常见的web server产品有Apache、Ngnix、IIS等。<br>大概就是处理特殊响应码，301（永久重定向）或者 302（临时重定向） 重定向。或者反向代理。然后解析用户请求，了解了要调度哪些资源文件，再通过响应的资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p><p>然后发送出响应报文，再走一遍传输过程（应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 网络接口层）。<br><img src="%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt="响应报文"></p><h3 id="10、响应数据处理"><a href="#10、响应数据处理" class="headerlink" title="10、响应数据处理"></a>10、响应数据处理</h3><h4 id="状态码301和302：重定向"><a href="#状态码301和302：重定向" class="headerlink" title="状态码301和302：重定向"></a>状态码301和302：重定向</h4><p><a href="https://blog.51cto.com/oldboy/1774260">Http状态码301和302概念简单区别及企业应用案例</a></p><blockquote><p>301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。<br>302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p></blockquote><h4 id="响应数据类型处理"><a href="#响应数据类型处理" class="headerlink" title="响应数据类型处理"></a>响应数据类型处理</h4><p>若状态码200，会通过响应的数据类型判断其中的内容。<br>Content-Type、charset、Content-Encoding等等响应头字段可以帮助浏览器判断响应内容的数据类型。对于HTML文档、纯文本、图片这些基本数据类型，浏览器自身具有显示这些内容的功能，因此由浏览器自身负责显示。比如 content-type 的值是“text/html”，那么浏览器会继续进行导航流程；如果是“applcaton/octet-steam”，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。</p><h3 id="11、准备渲染进程"><a href="#11、准备渲染进程" class="headerlink" title="11、准备渲染进程"></a>11、准备渲染进程</h3><ul><li><p>多进程的浏览器</p><blockquote><p>浏览器是多进程的，有一个主控进程，每一个tab页面都会新开一个渲染进程（某些情况下多个tab会共用一个渲染进程，比如同站点的A、B页面，从A页面打开B页面时候B会复用A的渲染进程）。<br>主要包括浏览器进程，插件进程，GPU进程，渲染进程、网络进程等等</p></blockquote></li><li><p>多线程的浏览器内核</p><blockquote><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：<br><br>JS引擎线程<br><br>GUI渲染线程<br><br>事件触发线程<br><br>定时器触发线程<br><br>异步http请求线程<br></p></blockquote><blockquote><p>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</p></blockquote></li></ul><h3 id="12、提交文档（网络进程-gt-渲染进程）"><a href="#12、提交文档（网络进程-gt-渲染进程）" class="headerlink" title="12、提交文档（网络进程 -&gt; 渲染进程）"></a>12、提交文档（网络进程 -&gt; 渲染进程）</h3><p>浏览器准备好渲染进程后，由于此时文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p><ul><li>浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息。</li><li>渲染进程收到消息后，会和网络进程建立传输输入的“管道”。</li><li>等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程。</li><li>浏览器进程收到消息后，会更新浏览器页面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新web页面。（这也就是为什么输入地址后回车，前一个页面并没有马上消失，而是要加载一会儿才会更新页面）</li></ul><h2 id="三、页面渲染阶段"><a href="#三、页面渲染阶段" class="headerlink" title="三、页面渲染阶段"></a>三、页面渲染阶段</h2><blockquote><p>渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML。</p></blockquote><blockquote><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</p></blockquote><h3 id="1、构建DOM树"><a href="#1、构建DOM树" class="headerlink" title="1、构建DOM树"></a>1、构建DOM树</h3><p><code>自上而下</code>解析html文档，调用<code>HTML解析器</code>（HTMLParser）生成DOM节点树（DOM树，也叫内容树），如果包含图片等外部资源信息，浏览器会交给网络进程去下载，如果解析到script标签，渲染引擎判断这是一段脚本或者需要去下载脚本，此时HTML解析器就会暂停DOM的解析，因为接下来的JavaScript可能要修改当前已经生成的 DOM 结构，等脚本下载后调用调用javascript解析器处理，等执行完毕才会继续解析DOM。（注意HTML解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据）<br><br><br><strong>详细过程</strong>：Bytes（字节） → Characters（字符） → Tokens（令牌） → Nodes（节点） → DOM（对象模型）</p><ol><li><p>字节转换为字符：浏览器拿到文件后由HTML解析器（拿到的是一些<code>字节码</code>）通过<code>编码方式</code>（一般是utf-8）转换为对应的<code>字符</code>（utf-8编码下，中文字符占3个字节、英文字符占1字节）。</p></li><li><p>分词（词法分析）：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集。Token分为Tag Token和文本Token。对应我们的起始标签、终止标签、和文本内容。</p></li><li><p>生成DOM节点并添加到DOM树中：<br></p><blockquote><p>HTML解析器维护了一个Token栈结构，该Token栈主要用来计算节点之间的父子关系，在第一个阶段中生成的Token会被按照顺序压到这个栈中。具体的处理规则如下所示：<br></p><ul><li>如果压入到栈中的是StartTag Token，HTML解析器会为该Token创建一个DOM节点，然后将该节点加入到DOM树中，它的父节点就是栈中相邻的那个元素生成的节点。</li><li>如果分词器解析出来是文本Token，那么会生成一个文本节点，然后将该节点加入到DOM树中，文本Token是不需要压入到栈中，它的父节点就是当前栈顶Token所对应的 DOM 节点。</li><li>如果分词器解析出来的是EndTag标签，比如是EndTag div，HTML解析器会查看Token栈顶的元素是否是StarTag div，如果是，就将StartTag div从栈中弹出，表示该div元素解析完成。</li></ul></blockquote><blockquote><p>这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上</p></blockquote></li></ol><h3 id="2、样式计算"><a href="#2、样式计算" class="headerlink" title="2、样式计算"></a>2、样式计算</h3><p>遇link/style标记，调用CSS解析器生成CSS规则树。<br></p><blockquote><p>和DOM一样，CSSOM也具有两个作用，第一个是提供给JavaScript操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个CSSOM体现在DOM中就是document.styleSheets。</p></blockquote><p><strong>详细过程</strong>：</p><ol><li>把 CSS 转换为浏览器能够理解的结构<code>styleSheets</code>。</li><li>转换样式表中的属性值，使其标准化，从而容易被渲染引擎理解。<br><img src="%E6%A0%87%E5%87%86%E5%8C%96%E5%B1%9E%E6%80%A7%E5%80%BC.jpg" alt="标准化属性值"></li><li>计算出 DOM 树中每个节点的具体样式，涉及到 CSS 的继承规则和层叠规则。</li></ol><h3 id="3、布局阶段"><a href="#3、布局阶段" class="headerlink" title="3、布局阶段"></a>3、布局阶段</h3><p>接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。<br><strong>详细过程</strong>：</p><ol><li>创建布局树<br><img src="%E5%B8%83%E5%B1%80.jpg" alt="布局"><br>为了构建布局树，浏览器大体上完成了下面这些工作：遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li><li>布局计算<br>计算布局树节点的坐标位置，在执行布局操作的时候，会把布局运算的结果重新写回布局树中。<h3 id="4、分层"><a href="#4、分层" class="headerlink" title="4、分层"></a>4、分层</h3>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。<br>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。<h3 id="5、生成绘制指令"><a href="#5、生成绘制指令" class="headerlink" title="5、生成绘制指令"></a>5、生成绘制指令</h3>渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。<br><img src="%E7%BB%98%E5%88%B6%E5%88%97%E8%A1%A8.jpg" alt="绘制列表"><h3 id="6、分块"><a href="#6、分块" class="headerlink" title="6、分块"></a>6、分块</h3>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。<br>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。<h3 id="7、光栅化（栅格化）"><a href="#7、光栅化（栅格化）" class="headerlink" title="7、光栅化（栅格化）"></a>7、光栅化（栅格化）</h3>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。<br>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。<h3 id="8、-合成和显示"><a href="#8、-合成和显示" class="headerlink" title="8、 合成和显示"></a>8、 合成和显示</h3>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。<h4 id="JS和CSS会不会阻塞DOM树的构建？如何阻塞？"><a href="#JS和CSS会不会阻塞DOM树的构建？如何阻塞？" class="headerlink" title="JS和CSS会不会阻塞DOM树的构建？如何阻塞？"></a>JS和CSS会不会阻塞DOM树的构建？如何阻塞？</h4><blockquote><p>当浏览器遇到一个script标记时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建。在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</p></blockquote></li></ol><h4 id="如何在渲染过程中进行优化？"><a href="#如何在渲染过程中进行优化？" class="headerlink" title="如何在渲染过程中进行优化？"></a>如何在渲染过程中进行优化？</h4><ul><li>js放body底部，尽量不阻塞DOM构建。</li><li>如果 JavaScript 文件中没有操作DOM相关代码，就可以将该JavaScript脚本设置为异步加载，通过async或defer来标记代码。<br><br>async和defer虽然都是异步的，不过还有一些差异，使用async标志的脚本文件一旦加载完成，会停止HTML解析器的工作并立即执行脚本；而使用了defer标记的脚本文件，需要在DOMContentLoaded事件之前执行。<br><br>多个defer脚本会按顺序从上到下执行；<br>多个async脚本会按下载完成时间执行，先下载完毕先执行；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&#39;foo.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script defer type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&#39;foo.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li>精简css，css放head中，首先css本身是不会阻塞DOM树的生成的，除非执行js，所以我们将css放在head中加载，还要把css放在js上面，这样js加载时css大概率已经加载完成了，不会阻塞js执行，也就不会阻塞DOM构建。</li><li>css尽量使用id和class，不要过度层叠。查找样式表是按照从右到左的顺序去匹配的，例如，div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。</li><li>压缩文件大小。</li><li>使用CDN。</li><li>对于大的CSS文件，可以通过媒体查询属性，将其拆分为多个不同用途的CSS文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li><li>减少重绘和重排。特别是重排，因为重排一定会触发重绘。具体如基于vue/react等框架开发（虚拟dom和diff算法减少了重绘和重排）；样式集中改变（利用当代浏览器的渲染队列机制将修改样式的代码写在一起，代码中间不要穿插无关样式修改的代码）；样式批量修改（如使用classname改变样式，或者box.style.cssText）；样式读写分开；利用document.createDocumentFragment生成文档碎片批量插入dom元素或利用document.innerHTML插入多个dom string；动画效果应用到position属性为absolute/fixed元素上（脱离文档流，减少对其他元素的影响）；利用css3硬件加速（transform、opacity、filters，触发硬件加速，不触发重绘重排）；尽量避免table布局（不好计算位置和大小）等等</li></ul><h2 id="九、TCP断开连接"><a href="#九、TCP断开连接" class="headerlink" title="九、TCP断开连接"></a>九、TCP断开连接</h2><p>connection: keep-alive并不会马上断开连接哦。除非有一方发送connection: close</p><p><img src="tcp4%E6%AC%A1%E5%88%86%E6%89%8B.jpg" alt="tcp4次分手"></p><h4 id="为什么分手后客户端要等待2个最长报文寿命MSL时间后，才真正进入“CLOSE”状态？"><a href="#为什么分手后客户端要等待2个最长报文寿命MSL时间后，才真正进入“CLOSE”状态？" class="headerlink" title="为什么分手后客户端要等待2个最长报文寿命MSL时间后，才真正进入“CLOSE”状态？"></a>为什么分手后客户端要等待2个最长报文寿命MSL时间后，才真正进入“CLOSE”状态？</h4><p>两个原因：</p><ul><li>确保服务器在最后阶段发送给客户端的数据，以及客户端发送给服务器的最后一个“ACK”报文都能正确地被接收，防止因个别报文传输错误导致连接释放失败。<br>如果最后一个ACK报文丢失，服务器端会重新传FIN报文，客户端收到后重新发送ACK报文。</li><li>防止“已失效的连接请求报文段”出现在本连接中。<br>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ul><h4 id="浏览器每个请求都需要建立tcp连接吗？"><a href="#浏览器每个请求都需要建立tcp连接吗？" class="headerlink" title="浏览器每个请求都需要建立tcp连接吗？"></a>浏览器每个请求都需要建立tcp连接吗？</h4><p>在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。<br><a href="https://zhuanlan.zhihu.com/p/224595048">HTTP keep-alive和TCP keepalive的区别，你了解吗？</a></p><h4 id="一个tcp连接中的http请求可以同时发送吗？"><a href="#一个tcp连接中的http请求可以同时发送吗？" class="headerlink" title="一个tcp连接中的http请求可以同时发送吗？"></a>一个tcp连接中的http请求可以同时发送吗？</h4><p>HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。<br>虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。<br>HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。</p><h4 id="浏览器对同一Host建立TCP连接到数量有没有限制？"><a href="#浏览器对同一Host建立TCP连接到数量有没有限制？" class="headerlink" title="浏览器对同一Host建立TCP连接到数量有没有限制？"></a>浏览器对同一Host建立TCP连接到数量有没有限制？</h4><p>Chrome最多允许对同一个Host建立6个TCP连接</p><p><a href="https://zhuanlan.zhihu.com/p/61423830">你猜一个 TCP 连接上面能发多少个 HTTP 请求</a><br><a href="https://cloud.tencent.com/developer/article/1458078">疯了吧！面试官 5 连问一个 TCP 连接可以发多少个 HTTP 请求？</a></p><p>【参考】</p><p><a href="https://juejin.cn/post/6844904194801926157">从输入URL到渲染全过程</a></p><p><a href="https://juejin.cn/post/6928677404332425223">阿里面试官的”说一下从url输入到返回请求的过程“问的难度就是不一样！</a></p><p><a href="https://juejin.cn/post/6950206307743842317">浏览器原理之从输入一个网址开始</a></p><p><a href="https://juejin.cn/post/6935232082482298911">从输入URL开始建立前端知识体系</a></p><p><a href="https://juejin.cn/post/6844903784229896199">从URL输入到页面展现到底发生什么？</a></p><p><a href="https://juejin.cn/post/6844903565610188807">【干货】十分钟读懂浏览器渲染流程</a></p><p><a href="https://blog.poetries.top/browser-working-principle/guide/part6/lesson34.html#%E4%BB%80%E4%B9%88%E6%98%AF-dom">DOM树：JavaScript是如何影响DOM树构建的</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376">进程和线程</a></p><p><a href="https://lq782655835.github.io/blogs/js/http-base-2.browser.html">JavaScript与浏览器 - 线程与引擎</a></p><!--这里简单说一种通过浏览器不同进程的角度来看这个问题的--><!--浏览器进程：--><!--• 用户输入内容，进行URL 解析（编码）--><!-- • 如果是文本，则拼接成默认搜索引擎加关键字的 URL 进行搜索--><!-- • 如果是 URL 就进行页面访问请求，并加上协议头（http、https 的区别）--><!--网络进程：--><!--• 查询缓存（缓存相关知识）--><!-- • 如果有浏览器本地缓存可用则使用本地缓存--><!--• DNS 解析（DNS 相关）--><!-- • 通过 DNS 来查询 IP 地址--><!-- • DNS 先查本地、后查运营商、逐级网上查。（域名解析是从后往前查的）--><!--• 拿到 IP 地址发起 HTTP 请求（这块可以问网络相关各种基础知识，TCP、IP、UDP、HTTPS、HTTP2）--><!-- • 建立 TCP 三次握手连接--><!-- • 如果是 HTTPS 建立 TLS 安全通道连接（HTTPS 加密方式）--><!-- • 发送 HTTP 请求，这个请求可能回到代理服务器或者源服务器。（服务器代理）--><!--• 拿到 HTTP 响应（HTTP 响应码）--><!--• 根据 Content-Type 来判断响应文件类型（常用 HTTP 响应头的作用）--><!-- • stream 类，浏览器启动下载界面下载文件。--><!-- • text、图片类，浏览器直接展示在页面上--><!-- • html 类型，浏览器会进行页面解析。--><!--渲染进程：--><!--• 页面解析--><!--• 网络进程向渲染进程传输 HTML 数据--><!--• 对 HTML 进行词法分析，通过堆栈算法构建 DOM 树。（AST语法树）--><!--• 如果遇到外部资源，浏览器会交给网络进程去下载。--><!--• 构建完 DOM 树的同时，将 CSS 代码转为浏览器可以理解的 StyleSheets--><!-- • 标准化样式属性值（单位、大小）--><!-- • 计算出 DOM 树每个节点的具体样式--><!-- • 计算每个 DOM 节点的父节点们的样式（样式继承）--><!--• DOM 树构建完成后， 合并 StyleSheets 构建出 CSSOM 渲染树。--><!--• 排版：遍历渲染树，计算元素的坐标位置。--><!--• 分层：为节点生成图层--><!--• 绘制：用浏览器指令逐条--><!--绘制页面元素。（如何避免重绘重排）--><!--• 栅格化--><!--• 合成--><!--真的是一道特别全面的问题，可以从各个角度挖问题~😃-->]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、URL构建和编码（浏览器进程）&quot;&gt;&lt;a href=&quot;#一、URL构建和编码（浏览器进程）&quot; class=&quot;headerlink&quot; title=&quot;一、URL构建和编码（浏览器进程）&quot;&gt;&lt;/a&gt;一、URL构建和编码（浏览器进程）&lt;/h2&gt;&lt;h3 id=&quot;1、用户输</summary>
      
    
    
    
    <category term="浏览器和计算机网络" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="渲染机制" scheme="http://example.com/tags/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    
    <category term="网络基础" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>javascript基础篇（汇总）</title>
    <link href="http://example.com/2021/12/12/javascript%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://example.com/2021/12/12/javascript%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-12-12T12:50:20.000Z</published>
    <updated>2022-03-25T08:43:31.999Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><a href="https://www.jianshu.com/p/ea85cd730b62">for … in … 和hasOwnProperty</a></p></li><li><p><a href="https://segmentfault.com/a/1190000005654451">事件冒泡和事件捕获</a></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;s1&quot;&gt;s1</span><br><span class="line">    &lt;div id&#x3D;&quot;s2&quot;&gt;s2&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">s1.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">        console.log(&quot;s1 冒泡事件&quot;);         </span><br><span class="line">&#125;,false);</span><br><span class="line">s2.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">        console.log(&quot;s2 冒泡事件&quot;);</span><br><span class="line">&#125;,false);</span><br><span class="line">        </span><br><span class="line">s1.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">        console.log(&quot;s1 捕获事件&quot;);</span><br><span class="line">&#125;,true);</span><br><span class="line">        </span><br><span class="line">s2.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">        console.log(&quot;s2 捕获事件&quot;);</span><br><span class="line">&#125;,true);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p> 当我们点击s2的时候,执行结果如下:<br> s1捕获事件-&gt; s2冒泡事件 -&gt; s2捕获事件 -&gt; s1冒泡事件</p><p> 这里大体分析下执行结果</p><ol><li>点击s2，click事件从document-&gt;html-&gt;body-&gt;s1-&gt;s2(捕获前进)<br>这里在s1上发现了捕获注册事件，则输出”s1 捕获事件”</li><li>到达s2，已经到达目的节点，s2上注册了冒泡和捕获事件，先注册的冒泡后注册的捕获，则先执行冒泡，输出”s2 冒泡事件”</li><li>再在s2上执行后注册的事件，即捕获事件，输出”s2 捕获事件”</li><li>下面进入冒泡阶段，按照s2-&gt;s1-&gt;body-&gt;html-&gt;documen(冒泡前进),在s1上发现了冒泡事件，则输出”s1 冒泡事件”</li></ol></li><li><p><strong>事件委托</strong><br>利用事件冒泡和事件捕获的特点，我们可以使用事件委托减少事件处理函数的绑定数量。<br>好处： 1. 减少事件注册；2. 新增子对象无需再次绑定事件，对我们动态增加子元素的时候很友好。<br>用法：利用事件冒泡原理 =&gt; 父元素进行事件响应=&gt; 通过e.target可以找到子元素<br>假设有以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul id&#x3D;&quot;s1&quot; style&#x3D;&quot;background: red; padding: 20px;&quot;&gt;</span><br><span class="line">      &lt;li&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 分别点击item获取其value</span><br><span class="line">var list &#x3D; document.getElementById(&#39;s1&#39;).getElementsByTagName(&#39;li&#39;);</span><br><span class="line">Array.prototype.forEach.call(list, element &#x3D;&gt; &#123;</span><br><span class="line">  element.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.target.innerText)</span><br><span class="line">&#125;, true)</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>我们可以使用事件代理进行优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul id&#x3D;&quot;s1&quot; style&#x3D;&quot;background: red; padding: 20px;&quot;&gt;</span><br><span class="line">      &lt;li data-index&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li data-index&#x3D;&quot;2&quot;&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li data-index&#x3D;&quot;3&quot;&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 分别点击item获取其value</span><br><span class="line">var s1 &#x3D; document.getElementById(&#39;s1&#39;);</span><br><span class="line">s1.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  if (e.target.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;) &#123;</span><br><span class="line">    console.log(e.target.innerText, e.target.dataset.index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。</p></blockquote></li><li><p><strong>节流throttle和防抖debounce</strong></p></li></ol><ul><li>节流：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。<br>常用场景：监听滚动事件判断滚动是否到底部，若不使用节流，则会触发很多次判断，我们使用节流，每500ms只触发一次判断，极大优化性能。</li><li>防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</li><li>常用场景：输入框监听用户输入，获取用户输入内容调用后台接口。若直接使用input事件，用户还没打完字就多次调用接口，造成服务器压力过大。使用防抖，用户输入后500ms再次触发input事件，则再等500ms，直到500ms内无新输入，发送数据至服务器端。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function debounce (fn, delay &#x3D; 300) &#123;</span><br><span class="line">  var timeout &#x3D; 0;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    timeout &#x3D; setTimeout(fn.bind(this, ...arguments), delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throttle (fn, delay &#x3D; 300) &#123;</span><br><span class="line">  var last &#x3D; 0;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var now &#x3D; +new Date();</span><br><span class="line">    if (!last || now &gt;&#x3D; last + delay) &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">      last &#x3D; now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>throttle优化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function throttle (fn, delay &#x3D; 300) &#123;</span><br><span class="line">  var last &#x3D; 0;</span><br><span class="line">  var timeout &#x3D; 0</span><br><span class="line">  return function () &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    var now &#x3D; +new Date();</span><br><span class="line">    if (!last || now &gt;&#x3D; last + delay) &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">      last &#x3D; now;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timeout &#x3D; setTimeout(fn.bind(this, ...arguments), delay); &#x2F;&#x2F; 确保最后再调用一次函数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><p><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html">DOMContentLoaded和load的区别</a></p></li><li><p><a href="https://www.cnblogs.com/liuhe688/p/5891273.html">变量和函数提升（函数声明的优先级最高）</a></p></li><li><p><strong>定义函数时用 var foo = function () {} 和 function foo() 有什么区别？</strong><br><a href="https://www.zhihu.com/question/19878052">https://www.zhihu.com/question/19878052</a><br><a href="https://www.cnblogs.com/coco1s/p/3959927.html">https://www.cnblogs.com/coco1s/p/3959927.html</a></p></li><li><p><strong>延长作用域链（with、try-catch）</strong><br><a href="https://www.jianshu.com/p/a9e3a605f4ab">https://www.jianshu.com/p/a9e3a605f4ab</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868200385680e8cf932dba9433ea367de9aba2b4784000">面向对象思想（OOP）</a></p><blockquote><p>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student：<br>所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。<br>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法</p></blockquote></li></ol><ol start="10"><li><p><a href="https://www.cnblogs.com/dolphinX/p/3280876.html">作用域链</a><br>作用： 保证对执行环境有权访问的所有变量和函数的<strong>有序</strong>访问。（标识符解析是沿着作用域链一级一级地搜索标识符的过程）</p></li><li><p> <a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">闭包</a><br>意义：1.从函数外部读取函数内部声明的变量。</p></li><li><p>让被读取的变量的值始终保持在<strong>内存</strong>中。（由于闭包会使得函数中的变量都被保存在内存中，<strong>内存消耗很大</strong>，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致<strong>内存泄露</strong>。解决方法是，在退出函数之前，将不使用的局部变量全部删除。）<br>实现方法：在函数内部再定义一个函数然后return出去！</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　function f1()&#123;</span><br><span class="line">　　　　var n&#x3D;999;</span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n); </span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return f2;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var result&#x3D;f1();</span><br><span class="line">　　result(); &#x2F;&#x2F; 999</span><br></pre></td></tr></table></figure><p>  在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">　function f1()&#123;</span><br><span class="line"></span><br><span class="line">　　　　var n&#x3D;999;</span><br><span class="line"></span><br><span class="line">　　　　nAdd&#x3D;function()&#123;n+&#x3D;1&#125;</span><br><span class="line"></span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　return f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var result&#x3D;f1();</span><br><span class="line"></span><br><span class="line">　　result(); &#x2F;&#x2F; 999</span><br><span class="line"></span><br><span class="line">　　nAdd();</span><br><span class="line"></span><br><span class="line">　　result(); &#x2F;&#x2F; 1000</span><br></pre></td></tr></table></figure><p>  在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在<strong>内存</strong>中，并没有在f1调用后被自动清除。<br>  为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。<br>  这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p></li><li><p><strong>使用闭包定义私有变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function ProV () &#123;</span><br><span class="line">var name;</span><br><span class="line"> </span><br><span class="line">this.setName &#x3D; function (value) &#123;</span><br><span class="line">name &#x3D; value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">this.getName &#x3D; function () &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var p &#x3D; new ProV(); &#x2F;&#x2F;定义ProV的实例对象</span><br><span class="line">p.setName(&quot;Tom&quot;);</span><br><span class="line"> </span><br><span class="line">console.log(p.name); &#x2F;&#x2F;undefined 对象p的name是私有变量，不能直接访问。</span><br><span class="line">console.log(p.getName()); &#x2F;&#x2F;Tom</span><br></pre></td></tr></table></figure></li><li><p><strong>setTimeout函数之循环和闭包</strong><br><a href="https://blog.csdn.net/huakaiwuxing/article/details/78968642">https://blog.csdn.net/huakaiwuxing/article/details/78968642</a><br><a href="https://www.jianshu.com/p/e5225ba4a025">https://www.jianshu.com/p/e5225ba4a025</a></p></li><li><p><strong>call、apply和bind的区别</strong></p></li></ol><ul><li>call和apply是为了改变函数运行时的上下文而存在的，不同的是使用apply时函数参数以数组形式传参，而使用call时函数参数以单独形式传参。注意call和apply方法都会使函数立即执行。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func.call(this, arg1,arg2,...)</span><br><span class="line">func.apply(this, [arg1,arg2,...])</span><br></pre></td></tr></table></figure>  <a href="https://github.com/lin-xin/blog/issues/7">https://github.com/lin-xin/blog/issues/7</a></li><li>bind()方法会创建一个新函数，称为绑定函数，传入this可以修改该函数的上下文，原函数的上下文没有改变，多次调用bind()方法是无效的。<br>bind()本身可以带函数参数，而调用绑定函数时候带的参数则是在 <strong>bind 中参数的基础上再往后排</strong>。</li><li>例子  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代理console.log</span><br><span class="line">function log() &#123;</span><br><span class="line">console.log.apply(console, arguments)</span><br><span class="line">&#125;</span><br><span class="line">log(1,2) &#x2F;&#x2F; 1,2</span><br><span class="line">log(1) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure></li></ul><ol start="15"><li><p><a href="https://juejin.im/entry/5903018cac502e0063d92127">arguments对象</a></p><blockquote><p>ES6中的箭头函数没有自己的 arguments 对象，不过在大多数情形下，rest参数可以给出一个解决方案：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">const fn &#x3D; () &#x3D;&gt; Array.prototype.slice.call(arguments);</span><br><span class="line">a &#x3D; fn(1, 2); &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/72a590f59f4f">arguments.callee</a><br>好处: 自己调用自己的时候去除函数名的耦合性。</p><blockquote><p>现在已经不推荐使用arguments.callee(),访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。</p></blockquote></li><li><p><a href="https://github.com/mqyqingfeng/Blog/issues/11">call和apply的模拟实现</a></p></li><li><p><strong>apply实现bind</strong><br>ie8不兼容bind，但兼容apply和call<br>准备知识：<a href="https://www.jianshu.com/p/ae57baecc57d">关于[ ].slice.call()</a></p></li></ol><p><strong>简单版</strong>=&gt;实现改变this指向以及传参<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; function(context)&#123;</span><br><span class="line">    &#x2F;&#x2F;保存this，也就是调用bind的那个函数</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);&#x2F;&#x2F; arguments没有数组的slice方法，此方法可以把传进来的参数变为数组 &#x2F;&#x2F; 第二个参数为1，剔除context</span><br><span class="line">    return function()&#123;</span><br><span class="line">        &#x2F;&#x2F;将第一次的参数与此次传入的参数合并，调用self函数</span><br><span class="line">        return self.apply(context,args.concat([].slice.call(arguments)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <a href="https://juejin.im/post/59093b1fa0bb9f006517b906#comment">从简单版进阶到优化版</a></p><ol start="18"><li><p><a href="https://segmentfault.com/a/1190000013911763">JavaScript之this指向</a><br>当一个函数作为函数而不是方法来调用的时候，this指向的是全局对象</p></li><li><p><a href="https://github.com/mqyqingfeng/Blog/issues/2">原型和原型链</a></p><blockquote><p>在读取对象的属性时候，首先查找自身的属性。如果没有找到，则会进一步查找构造函数的prototype对象的属性。这就是原型链的基本原理。这样一来，在通过构造函数生成的对象之间就实现了对其prototype对象的<strong>属性的共享</strong>。<br>这种共享用面向对象的术语来说就是继承。通过继承可以生成具有同样执行方式的对象，不过请注意，如果修改构造函数的prototype，<strong>已经生成的对象</strong>也会发生相应的改变。</p></blockquote></li></ol><p><a href="http://zencode.in/2.Javascript%E5%8E%9F%E5%9E%8B%E9%93%BE.html">Javascript 原型链</a><br><img src="https://img-blog.csdnimg.cn/img_convert/ab4674a4df3a390fc87200ab4cb0ba92.png" alt="扩展版"></p><ol start="20"><li><p>输出顺序-考察变量提升、原型链、运算符优先级<br>答案是 2 4 1 1 2 3 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line"> getName &#x3D; function () &#123; console.log(1); &#125;;</span><br><span class="line"> return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function () &#123; console.log(2);&#125;;</span><br><span class="line">Foo.prototype.getName &#x3D; function () &#123; console.log(3);&#125;;</span><br><span class="line">var getName &#x3D; function () &#123; console.log(4);&#125;;</span><br><span class="line">function getName() &#123; console.log(5);&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请写出以下输出结果：</span><br><span class="line">Foo.getName();  &#x2F;&#x2F; 函数属性</span><br><span class="line">getName();  &#x2F;&#x2F; 变量提升</span><br><span class="line">Foo().getName();  &#x2F;&#x2F; 调用Foo时， window上的getName变成1</span><br><span class="line">getName(); </span><br><span class="line">new Foo.getName(); </span><br><span class="line">new Foo().getName(); &#x2F;&#x2F; new的时候返回实例，查找到原型链上有getName </span><br><span class="line">new new Foo().getName();  &#x2F;&#x2F; .运算符的优先级大于new</span><br></pre></td></tr></table></figure></li><li><p><strong>instance运算与isPrototypeOf方法</strong>虽然也可以用constructor属性来判断对象类型，不过更为常见的做法是使用instanceof运算来进行判断。对于通过原型链进行派生继承的情况，instanceof运算也是有效的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; new Date()</span><br><span class="line">d instanceof Date &#x2F;&#x2F; true</span><br><span class="line">d instanceof Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">function Derived() &#123;&#125;</span><br><span class="line">function Base() &#123;&#125;</span><br><span class="line">Derived.prototype &#x3D; new Base()</span><br><span class="line">var obj &#x3D; new Derived()</span><br><span class="line">obj instanceof Derived &#x2F;&#x2F; true</span><br><span class="line">obj instanceof Base &#x2F;&#x2F; true</span><br><span class="line">obj instanceof Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">Derived.prototype.isPrototypeOf(obj) &#x2F;&#x2F; true</span><br><span class="line">Base.prototype.isPrototypeOf(obj) &#x2F;&#x2F; true</span><br><span class="line">Object.prototype.isPrototypeOf(obj) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么在JavaScript中“Object instanceof Function”和“Function instanceof Object”都返回true？</strong><br><a href="https://codeday.me/bug/20171204/102055.html">https://codeday.me/bug/20171204/102055.html</a><br>instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的<strong>原型链上</strong>（<code>__proto__</code>）即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; AAA.prototype</span><br><span class="line">Object.getPrototypeOf(Object.getPrototypeOf(obj)) &#x3D;&#x3D;&#x3D; AAA.prototype</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;一直到原型链尽头</span><br></pre></td></tr></table></figure></li><li><p><strong>关于constructor</strong><br>可以通过constructor属性来从对象处获取其构造函数，constructor不是对象的直接属性，而是通过原型链查找到的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">function B() &#123;&#125;</span><br><span class="line">A.prototype &#x3D; new B()</span><br><span class="line">var obj &#x3D; new A()</span><br><span class="line">obj.constructor &#x2F;&#x2F; function B()&#123;&#125;</span><br><span class="line">A.prototype.constructor &#x3D; A</span><br><span class="line">obj.constructor &#x2F;&#x2F; function A() &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>js实现继承的几种方式以及优缺点</strong><br><a href="https://github.com/mqyqingfeng/Blog/issues/16">JavaScript深入之继承的多种方式和优缺点</a></p></li><li><p><strong>js创建对象的7种方式及其优缺点</strong><br><a href="https://juejin.im/entry/58291447128fe1005cd41c52">JavaScript 创建对象的 7 种方法</a></p></li><li><p><strong>new创建对象过程发生了什么</strong><br>创建新对象person={}<br>新对象的__proto__属性指向构造函数的原型对象<br>构造函数的this指向新对象<br>执行构造函数内部代码，给person（this）添加属性<br>返回新对象person</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function new2 (func, ...rest) &#123;</span><br><span class="line">var o&#x3D; &#123;&#125;;</span><br><span class="line">o._proto_ &#x3D; Person.prototype; &#x2F;&#x2F;引用构造函数的原型对象</span><br><span class="line">func.apply(person, rest);</span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/h15882065951/article/details/69913881">https://blog.csdn.net/h15882065951/article/details/69913881</a></p></li><li><p><strong>判断变量类型</strong></p></li></ol><ul><li>typeof<br>typeof 可以判断number, string, object, boolean, function, undefined, symbol 这七种类型，但是，很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; new String(&#39;abc&#39;);</span><br><span class="line">typeof s &#x3D;&#x3D;&#x3D; &#39;object&#39;&#x2F;&#x2F; true</span><br><span class="line">s instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li>instanceof  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 缺点</span><br><span class="line">[] instanceof Array &#x2F;&#x2F; true</span><br><span class="line">[] instanceof Object &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li>Object.prototype.toString.call可以比较准确判断类型<br><a href="https://juejin.im/post/5b0b9b9051882515773ae714">https://juejin.im/post/5b0b9b9051882515773ae714</a></li></ul><ol start="28"><li><p><a href="https://juejin.im/post/5aa2b26b518825556020873f">关于Ajax</a></p></li><li><p> <strong>js数组常见方法</strong><br>slice(生成新数组)、splice（在原数组上操作）、concat（新数组）、shift（从原数组删除第一个元素）、unshift（从原数组头部增加元素）、pop（删除最后一个元素）、map（遍历，return的数值组成新数组）、reduce（遍历，return的数值参与到遍历中，最后返回结果）、filter（return值为true时加入新数组）、join（转为字符串）<br><a href="https://www.cnblogs.com/picaso/archive/2012/05/24/2517100.html">slice和splice的区别</a></p></li><li><p><a href="https://juejin.im/post/5949d85f61ff4b006c0de98b#heading-7">数组去重</a><br>object键值对+filter<br>考虑键值对的key为字符串类型，object[typeof item + item]=true<br>object[‘1’] 和 object[1]相同，使用typeof区分。 </p></li><li><p><strong>DOM操作</strong><br><a href="https://blog.csdn.net/qq_22944825/article/details/78047070">https://blog.csdn.net/qq_22944825/article/details/78047070</a><br>parentElement、children（数组）、removeChild、innerHTML、firstElementChild、lastElementChild、nextElementSibling、previousElementSibling等等</p></li><li><p><strong>跨域处理</strong><br><a href="https://zhuanlan.zhihu.com/p/111669476">图像ping</a></p><blockquote><p>相类似的，由于img标签也是不受跨域约束。但是需要注意的是图像PING和JSONP的区别。<br>图像ping的数据是通过查询字符串的形式发送的，而响应可以是任意内容，而通常是图或者204响应。通过图像ping，浏览器得不到任何具体的数据，但可以通过侦听onload和error事件知道响应是什么时候接收到的，利用这一特性，图像ping非常适合跟踪用户点击或动态广告曝光次数.</p></blockquote><p><a href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html">JSONP</a><br><a href="https://blog.csdn.net/jian_xi/article/details/66472870">JSONP优缺点</a><br><a href="https://blog.csdn.net/jian_xi/article/details/66474717">JSONP安全防范</a>-decodeURIComponent防止XSS漏洞<br><a href="https://blog.csdn.net/joyhen/article/details/21631833">前端解决跨域问题的8种方案（最新最全）</a><br><a href="https://segmentfault.com/a/1190000012469713#articleHeader11">ajax跨域，这应该是最全的解决方案了</a></p></li><li><p><strong>箭头函数的this指向</strong><br>“箭头函数”的this，总是指向定义时所在的对象，而不是运行时所在的对象。“箭头函数”的this，总是指向定义时所在的对象，而不是运行时所在的对象。（封闭词法上下文）<br><a href="https://segmentfault.com/a/1190000015087728">https://segmentfault.com/a/1190000015087728</a><br>不能做构造函数：因为没有自己的this<br>call和apply无效<br>没有prototype<br>不适用于作为对象的方法</p></li><li><p><strong>异步同步加载javascript(堵塞和非堵塞)</strong><br><a href="https://www.jianshu.com/p/055b0ea0d03c">https://www.jianshu.com/p/055b0ea0d03c</a></p><blockquote><p>异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。</p></blockquote></li><li><p><a href="https://blog.csdn.net/qq_39579242/article/details/81509661">匿名函数</a></p><blockquote><p>匿名函数，仅在调用时，才临时创建函数对象和作用域链对象；调用完，立即释放，所以匿名函数比非匿名函数更节省内存空间</p></blockquote></li><li><p><strong>关于es6</strong><br><a href="https://juejin.im/post/59c8aec0f265da065c5e965e">https://juejin.im/post/59c8aec0f265da065c5e965e</a><br><a href="https://www.cnblogs.com/fengxiongZz/p/8191503.html">https://www.cnblogs.com/fengxiongZz/p/8191503.html</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNzQ2ODEyMQ==&mid=2247486440&idx=1&sn=913290153adb600e063fc8a6efc57c24&chksm=9b7ceedeac0b67c888e25c8ca0f1de69d79bf82b88fad5075b32e90c3d27ab6003472fee1a68&mpshare=1&scene=24&srcid=0903fa2akeYTzpiKt3v3nugR&sharer_sharetime=1599094364860&sharer_shareid=fbf943ecb6bb30f0acd02fd096061a3a#rd">实现一个promise</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">const PENDING &#x3D; &#39;pending&#39;;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Promiseh (fn) &#123;</span><br><span class="line">  let self &#x3D; this;</span><br><span class="line">  self.value &#x3D; null;</span><br><span class="line">  self.error &#x3D; null;</span><br><span class="line">  self.status &#x3D; PENDING;</span><br><span class="line">  self.onFulfilled &#x3D; [];</span><br><span class="line">  self.onRejected &#x3D; [];</span><br><span class="line"></span><br><span class="line">  function resolve (value) &#123;</span><br><span class="line">    if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        self.status &#x3D; FULFILLED;</span><br><span class="line">        self.value &#x3D; value;</span><br><span class="line">        self.onFulfilled.forEach(onFulfilled &#x3D;&gt; &#123;</span><br><span class="line">          onFulfilled(self.value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject (error) &#123;</span><br><span class="line">    if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        self.status &#x3D; REJECTED;</span><br><span class="line">        self.error &#x3D; error;</span><br><span class="line">        self.onRejected.forEach(onRejected &#x3D;&gt; &#123;</span><br><span class="line">          onRejected(self.error);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promiseh.prototype.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    let self &#x3D; this;</span><br><span class="line">    let bridgePromise &#x3D; null;</span><br><span class="line">    onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : value &#x3D;&gt; value</span><br><span class="line">    onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : error &#x3D;&gt; &#123; throw error; &#125;</span><br><span class="line"></span><br><span class="line">    if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      return bridgePromise &#x3D; new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        self.onFulfilled.push((value) &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let x &#x3D; onFulfilled(value);</span><br><span class="line">            resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        self.onRejected.push(error &#x3D;&gt; &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            let x &#x3D; onRejected(error);</span><br><span class="line">            resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else if (self.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;</span><br><span class="line">      return bridgePromise &#x3D; new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; onFulfilled(self.value);</span><br><span class="line">          resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line"></span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return bridgePromise &#x3D; new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; onRejected(self.error);</span><br><span class="line">          resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Promiseh.prototype.catch &#x3D; function (onRejected) &#123;</span><br><span class="line">  return this.then(null, onRejected);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 一直到promise调用的最后一个才返回</span><br><span class="line">function resolvePromise (bridgePromise, x, resolve, reject) &#123;</span><br><span class="line">  if (x instanceof Promiseh) &#123; &#x2F;&#x2F; 函数返回值为promise</span><br><span class="line">    if (x.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      x.then(y &#x3D;&gt; &#123;</span><br><span class="line">        resolvePromise(bridgePromise, y, resolve, reject);</span><br><span class="line">      &#125;, error &#x3D;&gt; &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      x.then(resolve, reject); &#x2F;&#x2F; 执行结束直接把resolve和reject传进去</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;88&#39;);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;).then(aa &#x3D;&gt; &#123;</span><br><span class="line">  console.log(aa, &#39;hhhh&#39;)</span><br><span class="line">  return 99</span><br><span class="line">&#125;).then(bb &#x3D;&gt; &#123;</span><br><span class="line">  console.log(bb, &#39;hhhh&#39;)</span><br><span class="line">  return new Promiseh((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      reject(100);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(d &#x3D;&gt; &#123;</span><br><span class="line">  console.log(d ,&#39;kkk&#39;)</span><br><span class="line">&#125;, d &#x3D;&gt; &#123;</span><br><span class="line">  console.log(d, dd)</span><br><span class="line">&#125;).catch(e &#x3D;&gt; &#123;</span><br><span class="line">  console.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://juejin.im/post/6844903968292749319#heading-0">事件循环eventLoop</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&#39;script start&#39;)</span><br><span class="line">  new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;promise1&#39;)</span><br><span class="line">  &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;promise1 then&#39;)</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;settimeout4&#39;)</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(&#39;script will end&#39;)</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;settimeout1&#39;)</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;settimeout3&#39;)</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&#39;script end&#39;)</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;settimeout2&#39;)</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&#39;last script&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>解析</code><br>script标签属于宏任务，所以当前队列三个宏任务</p><ol><li> 执行第一个宏任务script，输出—<code>script start</code>, 存储一个微任务then</li><li> 输出—<code>script will end</code>, 存储两个宏任务settimeout1和settimeout3</li><li>下一个宏任务script执行前，必须清空微任务队列，输出—<code>promise1 then</code>, 存储宏任务settimeout4</li><li>没有微任务了，查看宏任务队列，排在前面的是第二个script标签，输出—<code>script end</code>, 存储宏任务settimeout2</li><li>执行下一个宏任务，输出—<code>last script</code></li><li>依次执行剩下的宏任务，输出<code>settimeout1</code>、<code>settimeout3</code>、<code>ettimeout4</code>、<code>settimeout2</code></li></ol></li></ol><p><strong>node.js的事件循环</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">  &#125;);</span><br><span class="line">  new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(7);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(8);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(6);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(9);</span><br><span class="line">  process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(10);</span><br><span class="line">  &#125;);</span><br><span class="line">  new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(12);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>答案 node &lt;11:1 7 6 8 2 4 9 11 3 10 5 12 node&gt;=11:1 7 6 8 2 4 3 5 9 11 10 12</code></p><p>解析<br><strong>宏任务和微任务</strong><br>宏任务：macrotask,包括setTimeout、setInerVal、setImmediate(node独有)、requestAnimationFrame(浏览器独有)、I/O、UI rendering(浏览器独有)<br>微任务：microtask,包括process.nextTick(Node独有)、Promise.then()、Object.observe、MutationObserver<br>Promise构造函数中的代码是同步执行的，new Promise()构造函数中的代码是同步代码，并不是微任务</p><p><strong>Node.js中的EventLoop执行宏队列的回调任务有6个阶段</strong><br>1.timers阶段：这个阶段执行setTimeout和setInterval预定的callback<br>2.I/O callback阶段：执行除了close事件的callbacks、被timers设定的callbacks、setImmediate()设定的callbacks这些之外的callbacks<br>3.idle, prepare阶段：仅node内部使用<br>4.poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里<br>5.check阶段：执行setImmediate()设定的callbacks<br>6.close callbacks阶段：执行socket.on(‘close’, ….)这些callbacks<br><strong>NodeJs中宏队列主要有4个</strong><br>1.Timers Queue<br>2.IO Callbacks Queue<br>3.Check Queue<br>4.Close Callbacks Queue<br>这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。<br><strong>NodeJS中微队列主要有2个</strong><br>1.Next Tick Queue：是放置process.nextTick(callback)的回调任务的<br>2.Other Micro Queue：放置其他microtask，比如Promise等<br>在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。<br><strong>Node.js中的EventLoop过程</strong><br>1.执行全局Script的同步代码<br>2.执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务<br>3.开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，<strong>每一个阶段的macrotask任务</strong>执行完毕后，开始执行微任务，也就是步骤2<br>4.Timers Queue -&gt; 步骤2 -&gt; I/O Queue -&gt; 步骤2 -&gt; Check Queue -&gt; 步骤2 -&gt; Close Callback Queue -&gt; 步骤2 -&gt; Timers Queue ……<br>5.这就是Node的Event Loop<br><strong>Node 11.x新变化</strong><br>现在node11在timer阶段的setTimeout,setInterval…和在check阶段的immediate都在node11里面都修改为一旦<strong>执行一个阶段里的一个任务就立刻执行微任务队列</strong>。为了和浏览器更加趋同.</p><ol start="39"><li><strong>indexedDB（数据库，大部分浏览器不支持）、userData（只有ie支持）、flash cookie、 http cookie（cookie）、session storage（浏览器会话）、local storage（永久）</strong><br><a href="https://segmentfault.com/a/1190000004743454#articleHeader2">cookie篇</a><blockquote><p>document.cookie = “name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]”</p></blockquote></li></ol><blockquote><p>我们知道 cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，浏览器就会在本地硬盘上查找与该 URL 相关联的 Cookie。如果该 Cookie 存在，浏览器就将它添加到request header的Cookie字段中，与http请求一起发送到该站点。</p></blockquote><blockquote><p>当然，用户也可以通过expries设置删除时间。这个值是个GMT格式的日期，类似例三中的Sat, 04 Nov 2017 16:00:00 GMT，这表明这个 cookie 将在2017-11-04的16时整失效，在此期间浏览器关闭后此cookie仍会保存在用户的机器中。GMT格式可以通过 toGMTString() 和 toUTCString() 获得。如果设置的失效时间是个以前的时间，则 cookie 会被立即删除，这也是用来删除 cookie 的方法。<br>在新的http协议中已经使用 max-age 属性来取代 expries。expries 表示的是失效时间，准确讲是「时刻」，max-age表示的是生效的「时间段」，以「秒」为单位。若 max-age 为正值，则表示 cookie 会在 max-age 秒后失效。如例四中设置”max-age=10800;”，也就是生效时间是3个小时，那么 cookie 将在三小时后失效。若 max-age 为负值，则cookie将在浏览器会话结束后失效，即 session，max-age的默认值为-1。若 max-age 为0，则表示删除cookie。</p></blockquote><ol start="40"><li><p><a href="https://juejin.cn/post/6844903929705136141">如何写出一个惊艳面试官的深拷贝?</a></p></li><li><p><a href="https://www.jianshu.com/p/cfd0fa90b4d1">离线应用</a></p></li><li><p><strong>其他</strong><br><a href="https://blog.csdn.net/SinceroTu/article/details/78055278">js前端面试题总结及答案</a><br><a href="https://blog.csdn.net/xixi880928/article/details/78842689">腾讯面试题集锦</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/ea85cd730b62&quot;&gt;for … in … 和hasOwnProperty&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.c</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js基础" scheme="http://example.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://example.com/2021/12/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/12/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-12T12:47:45.000Z</published>
    <updated>2022-03-17T09:26:57.001Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190315202820398.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="比较类排序"><a href="#比较类排序" class="headerlink" title="比较类排序"></a>比较类排序</h2><p>– 冒泡排序（内外循环）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">for(var i&#x3D;0, n&#x3D;arr.length;i&lt;n;i++) &#123;</span><br><span class="line">var flag &#x3D; 0 &#x2F;&#x2F; 优化</span><br><span class="line">for(var j&#x3D;0;j&lt;n-i-1;j++) &#123;</span><br><span class="line">if(arr[j+1]&lt;arr[j]) &#123;</span><br><span class="line">var t &#x3D; arr[j+1]</span><br><span class="line">arr[j+1]&#x3D;arr[j]</span><br><span class="line">arr[j]&#x3D;t</span><br><span class="line">flag &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag &#x3D;&#x3D;&#x3D; 0) break</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向冒泡排序法（鸡尾酒排序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function bubbleTwoWaySort(arr) &#123;</span><br><span class="line">var t, left &#x3D; 0, right &#x3D; arr.length - 1</span><br><span class="line">while(left &lt; right) &#123;</span><br><span class="line">for(var j &#x3D; left;j &lt;&#x3D; right;j++) &#123;</span><br><span class="line">if(arr[j+1]&lt;arr[j]) &#123;</span><br><span class="line">t &#x3D; arr[j+1]</span><br><span class="line">arr[j+1]&#x3D;arr[j]</span><br><span class="line">arr[j]&#x3D;t</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">left++</span><br><span class="line">if(left &gt;&#x3D; right) break</span><br><span class="line">for(var k &#x3D; right; k &gt;&#x3D; left;k--) &#123;</span><br><span class="line">if(arr[k-1] &gt; arr[k]) &#123;</span><br><span class="line">t &#x3D; arr[k-1]</span><br><span class="line">arr[k-1] &#x3D; arr[k]</span><br><span class="line">arr[k] &#x3D; t</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>考虑这样的一个序列：(2,3,4,5,1) 。如果使用鸡尾酒排序，一个来回就可以搞定；而冒泡排序则需要跑四趟。<br>其根本原因在于冒泡是单向的，如果从左向右冒泡，对于小数靠后就会很不利（一趟只能挪一个位置，那就需要多次循环。这种数又被称之为乌龟）；相应的，如果从右向左冒泡，对于大数靠前又会很不利（靠前的一只大乌龟）。鸡尾酒排序的优点就在于这里，由于在序列中左右摇摆（为此鸡尾酒排序又称之为 shaker sort），两种较差的局面就能得到规避，以此在性能上带来一些提升。</p></blockquote><p>– 选择排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function selectSort(arr) &#123;</span><br><span class="line">for(var i &#x3D; 0, n &#x3D; arr.length;i &lt; n-1;i++)&#123;</span><br><span class="line">var min &#x3D; i</span><br><span class="line">for(var j &#x3D; i + 1;j &lt; n;j++)&#123;</span><br><span class="line">if(arr[j]&lt;arr[min])&#123;</span><br><span class="line">min &#x3D; j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(min !&#x3D;&#x3D; i) &#123;</span><br><span class="line">var temp &#x3D; arr[i]</span><br><span class="line">arr[i] &#x3D; arr[min]</span><br><span class="line">arr[min] &#x3D; temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 插入排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function insertSort(arr) &#123;</span><br><span class="line">for(var i &#x3D; 1, n &#x3D; arr.length; i &lt; n ; i++) &#123;</span><br><span class="line">var j &#x3D; i - 1</span><br><span class="line">var current &#x3D; arr[i]</span><br><span class="line">while(current &lt; arr[j] &amp;&amp; j &gt;&#x3D; 0) &#123;</span><br><span class="line">arr[j+1] &#x3D; arr[j]</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">arr[j+1] &#x3D; current</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 折半插入排序<br>减少搜索次数，但数据交换次数不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function insertSort2 (arr) &#123;</span><br><span class="line">  for (let i &#x3D; 1, n &#x3D; arr.length; i &lt; n; i++) &#123;</span><br><span class="line">    let right &#x3D; i</span><br><span class="line">    let left &#x3D; 0</span><br><span class="line">    let mid</span><br><span class="line">    var current &#x3D; arr[i]</span><br><span class="line">    while (left &lt;&#x3D; right) &#123;</span><br><span class="line">      mid &#x3D; Math.floor(left + (right - left) &#x2F; 2)</span><br><span class="line">      if (current &lt; arr[mid]) right &#x3D; mid - 1</span><br><span class="line">      else left &#x3D; mid + 1</span><br><span class="line">    &#125;</span><br><span class="line">    for (var j &#x3D; i - 1; j &gt;&#x3D; left; j--) arr[j + 1] &#x3D; arr[j]</span><br><span class="line">arr[j+1] &#x3D; current</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 希尔排序（又称缩小增量排序）（本质还是插入排序）<br>将待排序列按照某种规则分成几个子序列，分别对这几个子序列进行直接插入排序。这个规则的体现就是增量的选取，如果增量是1， 那就是直接插入排序。</p><blockquote><p>首先，我们来回忆一下，插入排序的优点，它有两个优点：<br>对于小数列的速度很快（所以被用来做其他高级排序在小数列情况下的优化实现）<br>依赖输入，对于接近有序的数列很快<br>希尔排序就是充分利用了这两个优点，来优化插入排序。那么，希尔排序做了哪些改动呢：</p><ol><li>将数组分隔成更小的数组<br>希尔排序假设一个值 h, 将数列中,间隔为 h 的元素，作为一个新的子数列，这时，将整个大的数列分成了若干小数列，然后挨个处理子数列。因为 优点1，所以希尔排序会表现得很快。然后减小 h 的值，直到 1。</li><li>对基本有序的大数列排序<br>当 h=1 的时候，就是对整个数组运行一遍插入排序，数组有序。因为之前的操作，使得整个数列已经处于基本有序的状态了。这时充分利用了 优点2，排序也会表现得很快。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">var len &#x3D; arr.length;</span><br><span class="line">&#x2F;&#x2F; gap一直到1（直接插入排序）</span><br><span class="line">    for (var gap &#x3D; Math.floor(len &#x2F; 2); gap &gt; 0; gap &#x3D; Math.floor(gap &#x2F; 2)) &#123;</span><br><span class="line">        for (var i &#x3D; gap; i &lt; len; i++) &#123;</span><br><span class="line">            var j &#x3D; i;</span><br><span class="line">            var current &#x3D; arr[i];</span><br><span class="line">            while (j - gap &gt;&#x3D; 0 &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] &#x3D; arr[j - gap];</span><br><span class="line">                 j &#x3D; j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] &#x3D; current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 归并排序(重点在于合并)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(arr) &#123;</span><br><span class="line">if(arr.length &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line">var arr1 &#x3D; mergeSort(arr.slice(0, arr.length &#x2F; 2))</span><br><span class="line">var arr2 &#x3D; mergeSort(arr.slice(arr.length &#x2F; 2))</span><br><span class="line">return merge(arr1, arr2)</span><br><span class="line">&#125;</span><br><span class="line">function merge(arr1, arr2) &#123;</span><br><span class="line">var result &#x3D; []</span><br><span class="line">var p1 &#x3D; 0, p2 &#x3D; 0</span><br><span class="line">while(p1 &lt; arr1.length &amp;&amp; p2 &lt; arr2.length) &#123;</span><br><span class="line">if(arr1[p1] &lt; arr2[p2])&#123;</span><br><span class="line">result.push(arr1[p1])</span><br><span class="line">p1++</span><br><span class="line">&#125; else &#123;</span><br><span class="line">result.push(arr2[p2])</span><br><span class="line">p2++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result.concat(arr1.slice(p1).concat(arr2.slice(p2)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度为O(1)的归并： 在merge的时候使用插入排序，-  &gt; -用时间换取空间(小声哔哔)<br>– 快速排序<br>取巧写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">if(arr.length &lt;&#x3D; 1) return arr</span><br><span class="line">var [current] &#x3D; arr.splice(0,1)</span><br><span class="line">var arr1 &#x3D; arr.filter(item &#x3D;&gt; item &lt;&#x3D; current)</span><br><span class="line">var arr2 &#x3D; arr.filter(item &#x3D;&gt; item &gt; current)</span><br><span class="line">return [</span><br><span class="line">...quickSort(arr1),</span><br><span class="line">current,</span><br><span class="line">...quickSort(arr2)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常规写法(性能比上面的高)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">if(left &lt; right) &#123;</span><br><span class="line">var mid &#x3D; pritation(arr, left, right)</span><br><span class="line">quickSort(arr, left, mid-1)</span><br><span class="line">quickSort(arr, mid+1, right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function pritation(arr, left, right) &#123;</span><br><span class="line">var i &#x3D; left</span><br><span class="line">var j &#x3D; right</span><br><span class="line">var temp &#x3D; arr[left]</span><br><span class="line">while(i &lt; j) &#123;</span><br><span class="line">while(i &lt; j &amp;&amp; arr[j]&gt;&#x3D;temp) j--</span><br><span class="line">if(i&lt;j) arr[i++] &#x3D; arr[j]</span><br><span class="line">while(i &lt; j &amp;&amp; arr[i]&lt;temp) i++</span><br><span class="line">if(i&lt;j) arr[j--] &#x3D; arr[i]</span><br><span class="line">&#125;</span><br><span class="line">arr[i] &#x3D; temp</span><br><span class="line">return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种不错的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function quickSort2(ary, comparator &#x3D; (a, b) &#x3D;&gt; a - b) &#123;</span><br><span class="line">  return partition(ary, comparator)</span><br><span class="line">&#125;</span><br><span class="line">function partition(ary, comparator, start &#x3D; 0, end &#x3D; ary.length - 1, ) &#123;</span><br><span class="line">  if (start &gt;&#x3D; end) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var pivotIndex &#x3D; Math.floor(Math.random() * (end - start + 1) + start)</span><br><span class="line">  var pivot &#x3D; ary[pivotIndex]</span><br><span class="line"></span><br><span class="line">  swap(ary, pivotIndex, end)</span><br><span class="line"></span><br><span class="line">  for (var i &#x3D; start - 1, j &#x3D; start; j &lt; end; j++) &#123;</span><br><span class="line">    if (comparator(ary[j], pivot) &lt; 0) &#123;</span><br><span class="line">      i++</span><br><span class="line">      swap(ary, i, j)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  swap(ary, i + 1, end)</span><br><span class="line">  partition(ary, comparator, start, i)</span><br><span class="line">  partition(ary, comparator, i + 2, end)</span><br><span class="line">  return ary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归方法实现快排（使用栈）（函数递归开销大）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function quickSort2(arr, left, right) &#123;</span><br><span class="line">var stack &#x3D; [] &#x2F;&#x2F;使用数组的push、pop方法实现栈效果</span><br><span class="line">stack.push(right, left)</span><br><span class="line">while(stack.length &gt; 0) &#123;</span><br><span class="line">var l &#x3D; stack.pop(), r &#x3D; stack.pop()</span><br><span class="line">if(l &lt; r) &#123;</span><br><span class="line">var mid &#x3D; pritation(arr, l, r)</span><br><span class="line">stack.push(mid-1, l, r, mid+1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 堆排序(利用递归，反正只要把最大值或者最小值放到根节点就好了)<br>大顶堆：父亲大孩子小<br>小顶堆：父亲小孩子大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function heapSort(arr) &#123;</span><br><span class="line">&#x2F;&#x2F; 建堆</span><br><span class="line">for(var i &#x3D; Math.floor(arr.length &#x2F; 2); i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">maxHeapify(arr, i, arr.length)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 已经将最大值放在根节点了</span><br><span class="line">&#x2F;&#x2F; 进行堆排序，将根节点与叶子节点交换，重新建堆</span><br><span class="line">for(var j &#x3D; arr.length - 1; j&gt;&#x3D; 0 ; j--) &#123;</span><br><span class="line">var t &#x3D; arr[0]</span><br><span class="line">arr[0] &#x3D; arr[j]</span><br><span class="line">arr[j] &#x3D; t</span><br><span class="line">maxHeapify(arr, 0, j-1) &#x2F;&#x2F; 排好序的不需参与建堆</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function maxHeapify(arr, i, size) &#123;</span><br><span class="line">&#x2F;&#x2F; 父亲i, 孩子2i+1和2i+2</span><br><span class="line">var l &#x3D; 2*i + 1, r &#x3D; 2*i + 2, largest &#x3D; i</span><br><span class="line">if (l &lt;&#x3D; size &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        largest &#x3D; l</span><br><span class="line">    &#125;</span><br><span class="line">    if (r &lt;&#x3D; size &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        largest &#x3D; r</span><br><span class="line">&#125;</span><br><span class="line">if(largest !&#x3D;&#x3D; i) &#123;</span><br><span class="line">var t &#x3D; arr[i]</span><br><span class="line">arr[i] &#x3D; arr[largest]</span><br><span class="line">arr[largest] &#x3D; t</span><br><span class="line">        maxHeapify(arr, largest, size)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非比较类排序"><a href="#非比较类排序" class="headerlink" title="非比较类排序"></a>非比较类排序</h2><p>– 计数排序<br>找到最小值和最大值，建立从最小值到最大值的数的count（数组对象），遍历数组，count[key]++，再遍历count输出排好序的数组。<br>优点：O(n+k)<br>缺点：数据量大或者数据跨度大（例如数组[1,100000000,999]）的时候，消耗内存空间、时间大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function countingSort (arr) &#123;</span><br><span class="line">let n &#x3D; arr.length</span><br><span class="line">if (n &lt;&#x3D; 1) return arr</span><br><span class="line">let min &#x3D; Math.min.apply(null, arr)</span><br><span class="line">let max &#x3D; Math.max.apply(null, arr)</span><br><span class="line">if (min &#x3D;&#x3D;&#x3D; max) return arr</span><br><span class="line">let count &#x3D; &#123;&#125;</span><br><span class="line">for (let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">count[arr[i]] &#x3D; count.hasOwnProperty(arr[i]) ? count[arr[i]] + 1 : 1</span><br><span class="line">&#125;</span><br><span class="line">let res &#x3D; []</span><br><span class="line">for (let i &#x3D; min; i &lt;&#x3D; max; i++) &#123;</span><br><span class="line">while(count[i]--) &#123;</span><br><span class="line">res.push(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 桶排序<br>将数据分组，对每一组内分别排序，再合并<br>比如对1-100岁人员按照岁数排序，可以分为1-20岁一组，20-40岁一组，内部排好序后合并。<br>数据输入：数组以及桶的个数bucket<br>得到每组范围(max-min+1)/bucket<br>此排序主要适用于均匀分布的数字数组，在这种情况下能够达到最大效率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(arr, bucket) &#123;</span><br><span class="line">var n &#x3D; arr.length;</span><br><span class="line">var result &#x3D; [];</span><br><span class="line">if(n &lt;&#x3D; 1) return arr;</span><br><span class="line">bucket &#x3D; bucket || 1;</span><br><span class="line">&#x2F;&#x2F; 找到数组最大和最小值</span><br><span class="line">var min &#x3D; Math.min.apply(null, arr), max &#x3D; Math.max.apply(null, arr);</span><br><span class="line">if(min &#x3D;&#x3D;&#x3D; max) return arr;</span><br><span class="line">&#x2F;&#x2F; 每一个桶的范围</span><br><span class="line">var f &#x3D; (max - min + 1) &#x2F; bucket;</span><br><span class="line">var mybucket &#x3D; new Array(bucket);</span><br><span class="line">for(var i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">var index &#x3D; Math.floor((arr[i] - min)&#x2F;f);</span><br><span class="line">mybucket[index] &#x3D; mybucket[index] || [];</span><br><span class="line">var currbucket &#x3D; mybucket[index];</span><br><span class="line">currbucket.push(arr[i]);</span><br><span class="line">var k &#x3D; currbucket.length - 2;</span><br><span class="line">while(k &gt;&#x3D; 0 &amp;&amp; currbucket[k] &gt; arr[i]) &#123;</span><br><span class="line">currbucket[k+1] &#x3D; currbucket[k];</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">currbucket[k+1] &#x3D; arr[i]</span><br><span class="line">&#125;</span><br><span class="line">for(var i &#x3D; 0; i &lt; bucket; i++) &#123;</span><br><span class="line">if(mybucket[i])</span><br><span class="line">result &#x3D; result.concat(mybucket[i])</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 基数排序<br>基数排序是一种非比较型的整数排序算法。其基本原理是，按照整数的每个位数分组。在分组过程中，对于不足位的数据用0补位。<br>基数排序按照对位数分组的顺序的不同，可以分为LSD（Least significant digit）基数排序和MSD（Most significant digit）基数排序。</p><p>LSD基数排序，是按照从低位到高位的顺序进行分组排序。MSD基数排序，是按照从高位到低位的顺序进行分组排序。上述两种方式不仅仅是对位数分组顺序不同，其实现原理也是不同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function lsdSort(arr) &#123;</span><br><span class="line">var n &#x3D; arr.length;</span><br><span class="line">if(n&lt;&#x3D;1) return arr;</span><br><span class="line">var bucket &#x3D; new Array(10)</span><br><span class="line">var result &#x3D; arr</span><br><span class="line">var max &#x3D; Math.max.apply(null, arr)</span><br><span class="line">&#x2F;&#x2F; 根据max的位数确定要进行多少次桶排序</span><br><span class="line">var count &#x3D; max.toString().length;</span><br><span class="line">for(var i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">for(var j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">&#x2F;&#x2F; i&#x3D;0 -&gt; 个位</span><br><span class="line">&#x2F;&#x2F; i&#x3D;1 -&gt; 十位</span><br><span class="line">var curr &#x3D; Math.floor(result[j]&#x2F;(Math.pow(10,i))) % 10</span><br><span class="line">bucket[curr] &#x3D; bucket[curr] || []</span><br><span class="line">bucket[curr].push(result[j])</span><br><span class="line">&#125;</span><br><span class="line">result &#x3D; []</span><br><span class="line">for(var j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">if(bucket[j]) &#123;</span><br><span class="line">result &#x3D; result.concat(bucket[j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 重置桶</span><br><span class="line">bucket &#x3D; new Array(10)</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MSD:最开始时也是遍历所有元素，取最大值，得到最大位数，建立10个桶。这时从百位取起。不足三位，对应位置为0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function msdSort(arr, times) &#123;</span><br><span class="line">var n &#x3D; arr.length;</span><br><span class="line">if(n&lt;&#x3D;1) return arr;</span><br><span class="line">var bucket &#x3D; new Array(10)</span><br><span class="line">var result &#x3D; []</span><br><span class="line">var max &#x3D; Math.max.apply(null, arr)</span><br><span class="line">var min &#x3D; Math.min.apply(null, arr)</span><br><span class="line">if(max &#x3D;&#x3D;&#x3D; min) return arr;</span><br><span class="line">&#x2F;&#x2F; 根据max的位数确定要进行多少次桶排序</span><br><span class="line">var count &#x3D; times || max.toString().length;</span><br><span class="line">&#x2F;&#x2F; 只需要取最高位，其他递归</span><br><span class="line">for(var j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">var curr &#x3D; Math.floor(arr[j]&#x2F;(Math.pow(10,count-1))) % 10</span><br><span class="line">&#x2F;&#x2F; 取该位数</span><br><span class="line">bucket[curr] &#x3D; bucket[curr] || []</span><br><span class="line">bucket[curr].push(arr[j])</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; console.log(bucket)</span><br><span class="line">&#x2F;&#x2F; 遍历桶，多于一个数的递归排序</span><br><span class="line">for(var j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">if(bucket[j]) &#123;</span><br><span class="line">result &#x3D; result.concat(msdSort(bucket[j], count - 1))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【参考】<br><a href="http://www.suanfajun.com/%E5%B8%B8%E7%94%A812%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%81%E4%BA%8C%EF%BC%9A%E9%B8%A1%E5%B0%BE%E9%85%92%E6%94%B9%E8%BF%9B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html">常用12大排序算法之十二：鸡尾酒（双向冒泡或改进冒泡）排序算法</a></p><p><a href="https://www.cnblogs.com/reposkeeper-wx/p/suan-fa-xi-lie-zhi-wu-xi-er-pai-xu.html">算法系列之五 希尔排序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190315202820398.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2021/12/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/12/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-12T12:45:30.000Z</published>
    <updated>2022-03-17T09:26:57.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>JavaScript设计模式的作用 - 提高代码的重用性，可读性，使代码更容易的维护和扩展。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li><a href="#单例模式">单例模式</a></li><li><a href="#工厂模式">工厂模式</a></li><li><a href="#抽象工厂模式">抽象工厂模式</a></li><li><a href="#策略模式">策略模式</a></li><li><a href="#模板方法模式">模板方法模式</a></li><li><a href="#职责链模式">职责链模式</a></li><li><a href="#发布订阅者模式">发布订阅者模式</a></li><li><a href="#桥接模式">桥接模式</a></li><li><a href="#适配器模式">适配器模式</a></li><li><a href="#代理模式">代理模式</a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1></li></ol><ul><li><span id = '单例模式'>单例模式</span><blockquote><p>确保一个类仅有一个实例，并提供一个访问它的全局访问点。一般我们是这样实现单例的，用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可</p></blockquote></li></ul><p>单例模式下对象只会实例化一次，我们可以利用闭包，当该对象已经存在的时候，直接返回该对象，否则重新创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var singleton &#x3D; function( fn )&#123;</span><br><span class="line">    var result;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return result || ( result &#x3D; fn .apply( this, arguments ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var createMask &#x3D; singleton( function()&#123;</span><br><span class="line">return document.body.appendChild( document.createElement(&#39;div&#39;) );</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p><a href="http://www.alloyteam.com/2012/10/common-javascript-design-patterns/">http://www.alloyteam.com/2012/10/common-javascript-design-patterns/</a></p><ul><li><span id = '工厂模式'>工厂模式</span><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。<br>工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(何为耦合？就是相互影响)。通过使用工厂方法而不是new关键字及具体类，可以把所有实例化的代码都集中在一个位置，有助于创建模块化的代码，这才是工厂模式的目的和优势。</p></blockquote></li></ul><p>能解决多个相似的问题，但不能知道对象识别的问题(对象的类型不知道)<br>使用工厂模式生成xhr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var XMLHttpFactory &#x3D;function()&#123;&#125;;　　　　　　&#x2F;&#x2F;这是一个简单工厂模式</span><br><span class="line">  　　XMLHttpFactory.createXMLHttp &#x3D;function()&#123;</span><br><span class="line"> 　　　　 var XMLHttp &#x3D; null;</span><br><span class="line">  　　　　if (window.XMLHttpRequest)&#123;</span><br><span class="line"> 　　　　　　XMLHttp &#x3D; new XMLHttpRequest()</span><br><span class="line"> 　　　　 &#125;elseif (window.ActiveXObject)&#123;</span><br><span class="line">  　　　　　　XMLHttp &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">  　　　　&#125;</span><br><span class="line"> 　　return XMLHttp;</span><br><span class="line"> 　　&#125;</span><br><span class="line"> 　　&#x2F;&#x2F;XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。</span><br><span class="line"> 　　var AjaxHander &#x3D;function()&#123;</span><br><span class="line"> 　　　　var XMLHttp &#x3D; XMLHttpFactory.createXMLHttp();</span><br><span class="line"> 　　　　 　　　　...</span><br><span class="line"> 　　&#125;</span><br></pre></td></tr></table></figure><ul><li><span id = '抽象工厂模式'>抽象工厂模式</span><blockquote><p>将其成员对象的实列化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。 父类就变成了一个抽象类，但是父类可以执行子类中相同类似的方法，具体的业务逻辑需要放在子类中去实现。</p></blockquote></li></ul><p>定义函数实现子类继承父类，然后子类重写父类中的抽象方法。<br>工厂中定义多个抽象类，实现具体子类继承抽象类<br>实现方式—&gt;<a href="https://segmentfault.com/a/1190000012422055">https://segmentfault.com/a/1190000012422055</a></p><ul><li><span id = '策略模式'>策略模式</span><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换<br>使用策略模式重构代码，可以消除程序中大片的条件分支语句。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以使用策略模式来封装他们</p></blockquote></li></ul><p>普通模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var awardS &#x3D; function (salary) &#123;</span><br><span class="line">  return salary * 4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var awardA &#x3D; function (salary) &#123;</span><br><span class="line">  return salary * 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var awardB &#x3D; function (salary) &#123;</span><br><span class="line">  return salary * 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var calculateBonus &#x3D; function (level, salary) &#123;</span><br><span class="line">  if (level &#x3D;&#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line">    return awardS(salary);</span><br><span class="line">  &#125;</span><br><span class="line">  if (level &#x3D;&#x3D;&#x3D; &#39;A&#39;) &#123;</span><br><span class="line">    return awardA(salary);</span><br><span class="line">  &#125;</span><br><span class="line">  if (level &#x3D;&#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">    return awardB(salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">calculateBonus(&#39;A&#39;, 10000);</span><br></pre></td></tr></table></figure><p>策略模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var strategies &#x3D; &#123;</span><br><span class="line">  &#39;S&#39;: function (salary) &#123;</span><br><span class="line">    return salary * 4;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#39;A&#39;: function (salary) &#123;</span><br><span class="line">    return salary * 3;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#39;B&#39;: function (salary) &#123;</span><br><span class="line">    return salary * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var calculateBonus &#x3D; function (level, salary) &#123;</span><br><span class="line">  return strategies[level](salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculateBonus(&#39;A&#39;, 10000);</span><br></pre></td></tr></table></figure><ul><li><span id = '模板方法模式'>模板方法模式</span><blockquote><p>模板方法模式使用了原型链的方法，封装性好，复用性差<br>模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。</p></blockquote></li></ul><blockquote><p>模板方法是基于继承的设计模式，可以很好的提高系统的扩展性。 java中的抽象父类、子类<br>模板方法有两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。</p></blockquote><p>实现：父类定义方法，子类实现方法（抽象工厂模式封装了继承函数）。<br>示例—-&gt;<a href="https://blog.csdn.net/ligang2585116/article/details/50365276">https://blog.csdn.net/ligang2585116/article/details/50365276</a></p><ul><li><span id = '职责链模式'>职责链模式</span><blockquote><p>职责链，一系列可能处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，减少了很多重复代码。</p></blockquote></li></ul><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的<strong>耦合关系</strong>，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p></blockquote><p><a href="https://div.io/topic/1800#1%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89">https://div.io/topic/1800#1%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89</a></p><ul><li><span id = '发布订阅者模式'>发布订阅者模式（观察者模式）</span><blockquote><p>发布订阅模式，顾名思义，就是一个发布消息，一个监听消息，当有消息接收时处理消息。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">function Publisher(name) &#123;</span><br><span class="line">    this.name &#x3D; &#39;报纸&#39; + name</span><br><span class="line">    &#x2F;&#x2F; 订阅了本出版社的读者列表</span><br><span class="line">    this.subscribers &#x3D; [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加一个迭代方法，遍历所有投递列表 </span><br><span class="line">Publisher.prototype.deliver &#x3D; function(data) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历当前出版社对象所有的订阅过的方法</span><br><span class="line">    const context &#x3D; this</span><br><span class="line">    this.subscribers.forEach(function(fn) &#123;</span><br><span class="line">        &#x2F;&#x2F;data用于传参数给内部方法</span><br><span class="line">        fn.fire(context.name, data);</span><br><span class="line">    &#125;);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 观察者</span><br><span class="line">function Observe(callback) &#123;</span><br><span class="line">    this.fire &#x3D; callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给予订阅者阅读的能力</span><br><span class="line">Observe.prototype.subscribe &#x3D; function(publisher) &#123;</span><br><span class="line"></span><br><span class="line">    var that &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; some如果有一个返回值为true则为true</span><br><span class="line">    var alreadyExists &#x3D; publisher.subscribers.some(function(el)&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的el指的是函数对象</span><br><span class="line">        return el.fire &#x3D;&#x3D;&#x3D; that.fire &#x2F;&#x2F; 查看是否已经订阅了，如果订阅了就不再订阅</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果存在这个函数对象则不进行添加</span><br><span class="line">    if (!alreadyExists) &#123;</span><br><span class="line">        publisher.subscribers.push(this);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给予观察者退订的能力</span><br><span class="line">Observe.prototype.unsubscribe &#x3D; function(publisher) &#123;</span><br><span class="line"></span><br><span class="line">    var that &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 过滤，将返回值为true的重组成数组</span><br><span class="line">    publisher.subscribers &#x3D; publisher.subscribers.filter(function(el) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里的el.fire指的是观察者传入的callback</span><br><span class="line">        &#x2F;&#x2F; that.fire就是当前对象对callback的引用</span><br><span class="line">        return !(el.fire &#x3D;&#x3D;&#x3D; that.fire) &#x2F;&#x2F; 删除掉订阅</span><br><span class="line">    &#125;)</span><br><span class="line">    return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var publisher1 &#x3D; new Publisher(&#39;xixi&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实例化的读者，这个需要改进</span><br><span class="line">var observer1 &#x3D; new Observe(function(publisher, text) &#123;</span><br><span class="line">        console.log(&#39;得到来自&#39;+publisher +&#39;的订阅消息：&#39;+ text + &#39;,哈哈哈&#39;)</span><br><span class="line">&#125;);</span><br><span class="line">var observer2 &#x3D; new Observe(function(publisher, text) &#123;</span><br><span class="line">    console.log(&#39;得到来自&#39;+publisher +&#39;的订阅消息：&#39;+ text + &#39;,嘻嘻嘻&#39;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读者订阅了一家报纸,在报社可以查询到该读者已经在订阅者列表了，</span><br><span class="line">&#x2F;&#x2F; publisher1.subscribers-&gt;[observer1]</span><br><span class="line">observer1.subscribe(publisher1);</span><br><span class="line">observer2.subscribe(publisher1)                                                     </span><br><span class="line">&#x2F;&#x2F; 分发报纸，执行所有内在方法</span><br><span class="line">publisher1.deliver(13);&#x2F;&#x2F; 输出123</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 退订</span><br><span class="line">observer1.unsubscribe(publisher1);</span><br><span class="line">publisher1.deliver(12388);</span><br></pre></td></tr></table></figure></li><li><span id = '桥接模式'>桥接模式</span><br><a href="https://segmentfault.com/a/1190000012547750">https://segmentfault.com/a/1190000012547750</a></li><li><span id = '适配器模式'>适配器模式</span><blockquote><p>适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。</p></blockquote></li></ul><p><a href="https://segmentfault.com/a/1190000012436538">https://segmentfault.com/a/1190000012436538</a></p><ul><li><span id='代理模式'>代理模式</span><blockquote><p>代理模式的定义是把对一个对象的访问, 交给另一个代理对象来操作.</p></blockquote></li></ul><p>保护代理、虚拟代理（图片预加载）、缓存代理<br><a href="https://juejin.im/post/5a68491cf265da3e5661b342#heading-0">https://juejin.im/post/5a68491cf265da3e5661b342#heading-0</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h1&gt;&lt;p&gt;JavaScript设计模式的作用 - 提高代码的重用性，可读性，使代码更容易的维护和扩展。&lt;/p&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>实现平衡二叉树AVL</title>
    <link href="http://example.com/2021/12/12/%E5%AE%9E%E7%8E%B0%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/"/>
    <id>http://example.com/2021/12/12/%E5%AE%9E%E7%8E%B0%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/</id>
    <published>2021-12-12T12:41:44.000Z</published>
    <updated>2022-03-17T09:26:56.976Z</updated>
    
    <content type="html"><![CDATA[<p>AVL是BST的升级版，搜索性能更高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">function Node(key) &#123;</span><br><span class="line">    this.data &#x3D; key</span><br><span class="line">    this.left &#x3D; null</span><br><span class="line">    this.right &#x3D; null</span><br><span class="line">&#125;</span><br><span class="line">function AVL(arr) &#123;</span><br><span class="line">    this.root &#x3D; null</span><br><span class="line">    this.createAVL(arr)</span><br><span class="line">&#125;</span><br><span class="line">AVL.prototype.createAVL &#x3D; function(arr) &#123;</span><br><span class="line">    const len &#x3D; arr.length</span><br><span class="line">    if(len &#x3D;&#x3D;&#x3D; 0) return null</span><br><span class="line">    let root &#x3D; null</span><br><span class="line">    const res &#x3D; []</span><br><span class="line">    for(let i &#x3D; 0;i &lt; len; i++) &#123;</span><br><span class="line">        if(res.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            root &#x3D; this.insertNode(root, arr[i])</span><br><span class="line">            res.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.root &#x3D; root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; RR型左旋</span><br><span class="line">AVL.prototype.rotateL &#x3D; function(AvlNode) &#123;</span><br><span class="line">    var node &#x3D; AvlNode.right; &#x2F;&#x2F; 保存右子节点</span><br><span class="line">    AvlNode.right &#x3D; node.left; &#x2F;&#x2F; node的左子节点连接到AvlNode成为其右子节点</span><br><span class="line">    node.left &#x3D; AvlNode; &#x2F;&#x2F; AvlNode连接到node成为其左子节点</span><br><span class="line">    return node; &#x2F;&#x2F; 返回node，连接到AvlNode最初的父节点</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; LL型右旋</span><br><span class="line">AVL.prototype.rotateR &#x3D; function(AvlNode) &#123;</span><br><span class="line">    var node &#x3D; AvlNode.left;</span><br><span class="line">    AvlNode.left &#x3D; node.right;</span><br><span class="line">    node.right &#x3D; AvlNode;</span><br><span class="line">    return node</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; RL型</span><br><span class="line">AVL.prototype.rotateRL &#x3D; function(AvlNode) &#123;</span><br><span class="line">    AvlNode.right &#x3D; this.rotateR(AvlNode.right)</span><br><span class="line">    return this.rotateL(AvlNode)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; LR型</span><br><span class="line">AVL.prototype.rotateLR &#x3D; function(AvlNode) &#123;</span><br><span class="line">    AvlNode.left &#x3D; this.rotateL(AvlNode.left)</span><br><span class="line">    return this.rotateR(AvlNode)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 获取高度</span><br><span class="line">AVL.prototype.getHeight &#x3D; function(node) &#123;</span><br><span class="line">    if(node &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVL.prototype.balanceAVL &#x3D; function(root) &#123;</span><br><span class="line">    if(root &#x3D;&#x3D;&#x3D; null) return root</span><br><span class="line">    let lHeight &#x3D; this.getHeight(root.left)</span><br><span class="line">    let rHeight &#x3D; this.getHeight(root.right)</span><br><span class="line">    if(lHeight - rHeight &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">        let ll &#x3D; this.getHeight(root.left.left)</span><br><span class="line">        let lr &#x3D; this.getHeight(root.left.right)</span><br><span class="line">        if(ll - lr &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">            root &#x3D; this.rotateR(root) &#x2F;&#x2F; LL型</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root &#x3D; this.rotateLR(root)&#x2F;&#x2F;LR型</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(rHeight - lHeight &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">        let rl &#x3D; this.getHeight(root.right.left)</span><br><span class="line">        let rr &#x3D; this.getHeight(root.right.right)</span><br><span class="line">        if(rr - rl &#x3D;&#x3D;&#x3D; 1) &#123; &#x2F;&#x2F;RR型</span><br><span class="line">            root &#x3D; this.rotateL(root)</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            root &#x3D; this.rotateRL(root)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line">AVL.prototype.insertNode &#x3D; function(node, key) &#123;</span><br><span class="line">    if(node &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">        node &#x3D; new Node(key)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if(key &lt; node.data) &#123;</span><br><span class="line">            node.left &#x3D; this.insertNode(node.left, key)</span><br><span class="line">            node &#x3D; this.balanceAVL(node)</span><br><span class="line">        &#125; else if(key &gt; node.data) &#123;        </span><br><span class="line">            node.right &#x3D; this.insertNode(node.right, key)</span><br><span class="line">            node &#x3D; this.balanceAVL(node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node</span><br><span class="line">&#125;</span><br><span class="line">AVL.prototype.deleteNode &#x3D; function(node, key) &#123; &#x2F;&#x2F; 返回删除后的值</span><br><span class="line">    if(node &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">        return node</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if(key &#x3D;&#x3D;&#x3D; node.data) &#123;</span><br><span class="line">            if(node.left &#x3D;&#x3D;&#x3D; null &amp;&amp; node.right &#x3D;&#x3D;&#x3D; null) return null &#x2F;&#x2F; 直接删除该节点</span><br><span class="line">            if(node.left &#x3D;&#x3D;&#x3D; null &amp;&amp; node.right !&#x3D;&#x3D; null) &#123;</span><br><span class="line">                node &#x3D; node.right</span><br><span class="line">                return node</span><br><span class="line">            &#125;</span><br><span class="line">            else if(node.right &#x3D;&#x3D;&#x3D; null &amp;&amp; node.left !&#x3D;&#x3D; null) &#123;</span><br><span class="line">                node &#x3D; node.left</span><br><span class="line">                return node</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 左右节点都有的</span><br><span class="line">                node.data &#x3D; node.right.data</span><br><span class="line">                node.right &#x3D; this.deleteNode(node.right, key)</span><br><span class="line">                node &#x3D; this.balanceAVL(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(key &lt; node.data) &#123;</span><br><span class="line">            &#x2F;&#x2F; 将后面的值复制上来，然后递归删除</span><br><span class="line">            node.left &#x3D; this.deleteNode(node.left, key)</span><br><span class="line">            node &#x3D; this.balanceAVL(node)</span><br><span class="line">        &#125; else &#123;          </span><br><span class="line">            node.right &#x3D; this.deleteNode(node.right, key)</span><br><span class="line">            node &#x3D; this.balanceAVL(node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node</span><br><span class="line">&#125;</span><br><span class="line">const AVLobj &#x3D; new AVL([2,3,9,1])</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AVL是BST的升级版，搜索性能更高。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="平衡二叉树" scheme="http://example.com/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://example.com/2021/12/12/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2021/12/12/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2021-12-12T12:22:24.000Z</published>
    <updated>2022-03-17T09:26:57.003Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>给定一个字符串，找出不含有重复字符的 最长子串 的长度。</p><p>示例：</p><p>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。</p><p>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。</p><p>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列 而不是子串。</p><p><strong>分析：</strong><br>①必须会的<strong>暴力破解法</strong>，求无重复字符的最长子串，只需要把所有的子串列出来，找到其中最长的无重复子串即可。<br>比如对于长度为5的字符串abcda, 我们可以先看看abcda是否为最长无重复字符子串，遍历1遍，if(arr.indexOf(item) !== i) { 说明有重复字符}<br>再看看长度为4的子串，abcd、bcda…<br>…<br>该法缺点：效率极低，运行时间长。<br>n*n +(n-1)*(n-1)+…+2*2+1*1<br>O(n^3)<br>②<strong>动态规划法</strong>，c[i][j]表示从i到j的串的最长无重复子串<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C3n5yrVK-1639311705103)(//img-blog.csdn.net/20180321171900738?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]<br>如果s[j]不在从i到j-1的子串中，c[i][j]=c[i][j-1]+1；反之，c[i][j]=0<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gac3RWgD-1639311705106)(//img-blog.csdn.net/20180321172154735?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]<br>观察上表，可以看出，对角线值一定为1（分析略），每一行可以从对角线处开始遍历，遇到0结束该行遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var x&#x3D;new Array();</span><br><span class="line">  var len&#x3D;s.length;</span><br><span class="line">  var max&#x3D;0;</span><br><span class="line">  var sub&#x3D;&quot;&quot;;</span><br><span class="line">  for(let i&#x3D;0;i&lt;len;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  x[i]&#x3D;new Array();</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i&#x3D;0;i&lt;len;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  sub&#x3D;s[i];</span><br><span class="line">  for(let j&#x3D;i;j&lt;len;j++)</span><br><span class="line">  &#123;</span><br><span class="line">  if(i&#x3D;&#x3D;j)</span><br><span class="line">  &#123;</span><br><span class="line">  x[i][j]&#x3D;1;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">  if(sub.indexOf(s[j])&#x3D;&#x3D;-1)</span><br><span class="line">  &#123;</span><br><span class="line">  x[i][j]&#x3D;x[i][j-1]+1;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">  break;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  max&#x3D;x[i][j]&gt;max?x[i][j]:max;</span><br><span class="line">  sub+&#x3D;s[j];</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br></pre></td></tr></table></figure><p>缺点：效率依旧很低。双重循环，时间复杂度O(n^2)<br>③<strong>尺取法</strong><br>网上看了代码，知道了有尺取法这个东西。<br>步骤：</p><ul><li><p>初始化两个指针（head,tail）指向字符串开头</p></li><li><p>tail++,如果tail指针指向的字符不与head和tail-1之间的字符重复，tail继续向后移动，更新max；反之，head一直加到没有重复字符为止</p></li><li><p>重复第二步骤，直到tail指针指向字符串结尾</p><p>代码：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const map &#x3D; &#123;&#125;;</span><br><span class="line">   var left &#x3D; 0;</span><br><span class="line">   </span><br><span class="line">   return s.split(&#39;&#39;).reduce((max, v, i) &#x3D;&gt; &#123;</span><br><span class="line">       left &#x3D; map[v] &gt;&#x3D; left ? map[v] + 1 : left;</span><br><span class="line">       map[v] &#x3D; i;</span><br><span class="line">       return Math.max(max, i - left + 1);</span><br><span class="line">   &#125;, 0);</span><br></pre></td></tr></table></figure><p>这串简短的代码就像女神一样优雅美丽。<br>（这段js涉及split函数、reduce函数、箭头函数等内容，请自行了解）<br><img src="https://img-blog.csdnimg.cn/img_convert/b697fddda616a90c5096aff90af1d1da.png" alt="这里写图片描述"><br>翻译成大白话就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const map&#x3D;&#123;&#125;;</span><br><span class="line">   var left&#x3D;0;</span><br><span class="line">   var max&#x3D;0;</span><br><span class="line">   var left&#x3D;0;</span><br><span class="line">   for(var i&#x3D;0;i&lt;s.length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   var v&#x3D;s[i];</span><br><span class="line">   if(map[v]&gt;&#x3D;left)&#x2F;&#x2F;一开始map[v]不存在，undefined，式子值为false</span><br><span class="line">   &#123;</span><br><span class="line">   left&#x3D;map[v]+1;</span><br><span class="line">   &#125;</span><br><span class="line">   map[v]&#x3D;i;</span><br><span class="line">   if(max&lt;i-left+1)</span><br><span class="line">   &#123;</span><br><span class="line">   max&#x3D;i-left+1;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return max;</span><br></pre></td></tr></table></figure><p>说一下对尺取法的理解吧<br>目标：<strong>最长</strong>的无重复子串<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8H6yZiqj-1639311705110)(//img-blog.csdn.net/20180321185401942?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]<br>当出现上述情况时候，在当前子串范围内max=6，该子串的子串max一定小于6<br>接下来无论head向右如何移动（head&lt;=tail），所能得到的子串（如cdabsa、dabsa）的最大无重复字符长度len一定是小于6的，故对它们进行计算是没有意义的，该部分的max已经找到，直接将head指针移到b字符处，计算下部分的max<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SPuDhSu2-1639311705112)(//img-blog.csdn.net/20180321190148533?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]<br>时间复杂度： 只遍历一遍，O(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br&gt;给定一个字符串，找出不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。&lt;/p&gt;
&lt;p&gt;给定 “bbbbb” ，最</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最长无重复子串" scheme="http://example.com/tags/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB常用命令自查笔记</title>
    <link href="http://example.com/2021/12/12/MongoDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%87%AA%E6%9F%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/12/12/MongoDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%87%AA%E6%9F%A5%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-12T12:10:26.000Z</published>
    <updated>2022-03-17T09:26:56.939Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MongoDB是NoSQL数据库系统中比较流行的数据库之一。它也是最接近关系型数据库的，一个数据库可以包含多个集合（Collection），类似于关系数据库中的表；而每个集合中可以存储一组由列标识的记录，列是可以自由定义的，非常灵活，这就类似于关系数据库表中的每一条记录。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201124224803613.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="MongoDB-Database常用命令"><a href="#MongoDB-Database常用命令" class="headerlink" title="MongoDB Database常用命令"></a>MongoDB Database常用命令</h2><ol><li>连接数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --host xx.xx.xx.xx -u 用户名 -p 密码 --authenticationDatabase admin</span><br></pre></td></tr></table></figure></li><li>Help查看命令提示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.help();</span><br><span class="line">db.yourCollection.help();</span><br></pre></td></tr></table></figure></li><li>显示所有数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs;</span><br></pre></td></tr></table></figure></li><li>切换/创建数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use XXX;</span><br></pre></td></tr></table></figure></li><li>查看当前数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db;</span><br><span class="line">db.getName();</span><br></pre></td></tr></table></figure></li><li>删除当前使用的数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase();</span><br></pre></td></tr></table></figure></li><li>显示当前db状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.stats();</span><br></pre></td></tr></table></figure></li><li>当前db的版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.version();</span><br></pre></td></tr></table></figure></li><li>查看当前db的连接服务器机器地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.getMongo();</span><br></pre></td></tr></table></figure><h2 id="MongoDB-Collection集合命令"><a href="#MongoDB-Collection集合命令" class="headerlink" title="MongoDB Collection集合命令"></a>MongoDB Collection集合命令</h2></li><li>创建一个集合(在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建成功会显示&#123;&quot;ok&quot;: 1&#125;</span><br><span class="line">db.createCollection(&quot;log&quot;, &#123;capped : true, size : 5242880, max : 5000 &#125;); &#x2F;&#x2F; 此命令将创建一个名为log的集合，该集合的最大大小为 5 MB，最多 5000 个文档。</span><br><span class="line">&#x2F;&#x2F; 判断集合是否为定容量</span><br><span class="line">db.collName.isCapped();</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20201124230130637.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>得到指定名称的集合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.getCollectionName(&quot;log&quot;);</span><br></pre></td></tr></table></figure></li><li>得到当前db的所有集合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show collections;</span><br><span class="line">db.getCollectionNames();</span><br></pre></td></tr></table></figure></li><li>显示当前db所有集合索引的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.printCollectionStats();</span><br></pre></td></tr></table></figure></li><li>查询当前集合的数据条数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.count();</span><br></pre></td></tr></table></figure></li><li>查看当前集合数据空间大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.dataSize();</span><br></pre></td></tr></table></figure></li><li>获取当前集合所在的db<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.getDB();</span><br></pre></td></tr></table></figure></li><li>获取当前集合的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.stats();</span><br></pre></td></tr></table></figure></li><li>获取集合总大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.totalSize();</span><br></pre></td></tr></table></figure></li><li>获取集合储存空间大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.storageSize();</span><br></pre></td></tr></table></figure></li><li>集合重命名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.renameCollection(&quot;newName&quot;);&#96;</span><br></pre></td></tr></table></figure></li><li>删除当前集合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.drop();</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li><li>查询所有记录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find();</span><br><span class="line">db.yourCollection.find().pretty(); &#x2F;&#x2F; 使用易读的方式读取数据</span><br></pre></td></tr></table></figure></li><li>查询某列组成的数据（去重）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.distinct(&quot;name&quot;); &#x2F;&#x2F; 若多个name值为“张三”, 只会查出一个张三</span><br></pre></td></tr></table></figure></li><li>按条件查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find(&#123; name: &quot;张三&quot;&#39; &#125;); &#x2F;&#x2F; 查询name为“张三”的行（document）</span><br><span class="line">db.yourCollection.find(&#123; age: &#123; &amp;lt: 22 &#125; &#125;); &#x2F;&#x2F; 查询age值小于22的行</span><br><span class="line">db.yourCollection.find(&#123; tags: &#123; $in:  [&#39;男&#39;, &#39;女&#39;] &#125; &#125;); &#x2F;&#x2F; 与查询数组中指定的值中的任何一个匹配</span><br><span class="line">&#x2F;&#x2F; 其他 $gt 大于、$gte大于等于、$lte小于等于、$ne不等于、$nin 与查询数组中指定的值中的任何一个都不匹配</span><br></pre></td></tr></table></figure></li><li>字符模糊匹配<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find(&#123; name: &#x2F;mongo&#x2F; &#125;);</span><br><span class="line">&#x2F;&#x2F; 相当于%%</span><br><span class="line">select * from userInfo where name like ‘%mongo%&#39;;</span><br></pre></td></tr></table></figure></li><li>查询指定列数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find(&#123;&#125;, &#123; name: 1, age: 1 &#125;);</span><br><span class="line">&#x2F;&#x2F; 相当于 select name, age from yourCollection</span><br></pre></td></tr></table></figure></li><li>按条件查询指定列数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find(&#123; age: &#123; $lt: 20 &#125;&#125;, &#123; name: 1, age: 1 &#125;)</span><br></pre></td></tr></table></figure></li><li>排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find().sort(&#123; age: 1 &#125;); &#x2F;&#x2F; 升序</span><br><span class="line">db.yourCollection.find().sort(&#123; age: -1 &#125;); &#x2F;&#x2F; 降序</span><br></pre></td></tr></table></figure></li><li>查询前5条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find().limit(5);</span><br></pre></td></tr></table></figure></li><li>查询10条以后的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find().skip(10);</span><br></pre></td></tr></table></figure></li><li>查询在5-10之间的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find().limit(10).skip(5);</span><br></pre></td></tr></table></figure></li><li>or(与)查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find(&#123; $or: [&#123; age: 22&#125;, &#123; age: 25 &#125;]&#125;); &#x2F;&#x2F; age &#x3D; 22 或 age &#x3D; 25</span><br></pre></td></tr></table></figure></li><li>查询第一条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.findOne();</span><br><span class="line">db.yourCollection.find().limit(1);</span><br></pre></td></tr></table></figure></li><li>查询某个结果集的记录条数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.find(&#123; age: &#123; $gte: 25 &#125; &#125;).count();</span><br></pre></td></tr></table></figure></li><li>使用aggreate聚合,进行分类统计 <a href="https://www.cnblogs.com/greenteaone/p/11655543.html">Mongoose: aggregate聚合 $group使用说明</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.aggregate([&#123; $group: &#123; _id: &quot;$tag&quot;, count: &#123;$sum: 1&#125;&#125;&#125;]) &#x2F;&#x2F; 按照tag进行分组，获取每种类别以及每种类别数量</span><br></pre></td></tr></table></figure></li><li>使用populate进行连表查询–Population 可以自动替换document中的指定字段，替换内容从其他collection获取。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">const Schema &#x3D; mongoose.Schema;</span><br><span class="line">const personSchema &#x3D; new Schema(&#123;</span><br><span class="line">  _id: Schema.Types.ObjectId,</span><br><span class="line">  name: String,</span><br><span class="line">  age: Number,</span><br><span class="line">  stories: [&#123;</span><br><span class="line">    type: Schema.Types.ObjectId,</span><br><span class="line">    ref: &#39;Story&#39; &#x2F;&#x2F; ref选项告诉Mongoose在填充的时候使用哪个Model填充，这里使用Story Model，所有存储再次的_id都必须是Story Model中document的&#96;_id&#96;.</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const storySchema &#x3D; new Schema(&#123;</span><br><span class="line">  author: &#123;</span><br><span class="line">    type: Schema.Types.ObjectId,</span><br><span class="line">    ref: &#39;Person&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  title: String,</span><br><span class="line">  fans: [&#123;</span><br><span class="line">    type: Schema.Types.ObjectId,</span><br><span class="line">    ref: &#39;Person&#39;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 创建Story和Person两个Model</span><br><span class="line">let Story &#x3D; mongoose.model(&#39;Story&#39;, storySchema);</span><br><span class="line">let Person &#x3D; mongoose.model(&#39;Person&#39;, personSchema);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加文档</span><br><span class="line">let author &#x3D; new Person(&#123;</span><br><span class="line">  name: &#39;astar&#39;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;); &#x2F;&#x2F; mongoose将会自动生成_id</span><br><span class="line">await author.save();</span><br><span class="line"></span><br><span class="line">let story &#x3D; new Story(&#123;</span><br><span class="line">  title: &#39;故事集&#39;,</span><br><span class="line">  author: author._id</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">await story.save();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询文档，使用populate填充story字段</span><br><span class="line">let story &#x3D; await Story.findOne(&#123; title: &#39;故事集&#39; &#125;).populate(&#39;author&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可选返回字段</span><br><span class="line">let story &#x3D; await Story.findOne(&#123; title: &#39;故事集&#39; &#125;).populate(&#39;author&#39;, [&#39;name&#39;]); &#x2F;&#x2F; 返回的author字段包含了_id和name</span><br><span class="line">&#x2F;&#x2F; 若不想返回_id，可使用String类型, 空格分割，其中&#96;-_id&#96;表示不返回_id</span><br><span class="line">let story &#x3D; await Story.findOne(&#123; title: &#39;故事集&#39; &#125;).populate(&#39;author&#39;, &#39;name age -_id&#39;); &#x2F;&#x2F; 返回的author字段包含了name和age</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 填充多个字段</span><br><span class="line">let story &#x3D; await Story.findOne(&#123; title: &#39;故事集&#39; &#125;).populate(&#39;author&#39;).populate(&#39;fans&#39;); &#x2F;&#x2F; 如果对同一字段 populate() 两次，只有最后一次生效。</span><br></pre></td></tr></table></figure>populate({ objParam }) - 更丰富的选项</li></ol><p><code>objParam</code></p><ul><li><code>path</code>：需要 populate 的字段。</li><li><code>populate</code>：多级填充。</li><li><code>select</code>：从 populate 的文档中选择返回的字段。</li><li><code>model</code>：用于 populate 的关联 model。如果没有指定，populate 将根据 schema 中定义的 ref 字段中的名称查找 model。可指定跨数据库的 model。</li><li><code>match</code>：populate 连表查询的条件，符合条件的会用文档替换 _id，不符合条件的会用 null 替换 _id。</li><li><code>options</code>：populate 查询的选项。<ul><li>sort：排序。</li><li>limit：限制数量。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">    find(...).</span><br><span class="line">    populate(&#123;</span><br><span class="line">        path: &#39;fans&#39;,</span><br><span class="line">        match: &#123; age: &#123; $gte: 20 &#125; &#125;,</span><br><span class="line">        select: &#39;name -_id&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">            limit: 5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 多级填充</span><br><span class="line">&#x2F;&#x2F; 查询 friends 的 friends</span><br><span class="line">Author.findOne(&#123; name: &#39;dora&#39; &#125;).populate(&#123;</span><br><span class="line">  path: &#39;friends&#39;,</span><br><span class="line">  populate: &#123; path: &#39;friends&#39; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>跨数据库填充</p><p>跨数据库不能直接通过 schema 中的 ref 选项填充，但是可以通过 objParam 中的 model 选项显式指定一个跨数据库的 model。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let eventSchema &#x3D; new Schema(&#123;</span><br><span class="line">  name: String,</span><br><span class="line">  conversation: ObjectId  &#x2F;&#x2F; 注意，这里没有指定 ref！</span><br><span class="line">&#125;);</span><br><span class="line">let conversationSchema &#x3D; new Schema(&#123;</span><br><span class="line">  numMessages: Number</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let db1 &#x3D; mongoose.createConnection(&#39;localhost:27000&#x2F;db1&#39;);</span><br><span class="line">let db2 &#x3D; mongoose.createConnection(&#39;localhost:27001&#x2F;db2&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不同数据库的 Model</span><br><span class="line">let Event &#x3D; db1.model(&#39;Event&#39;, eventSchema);</span><br><span class="line">let Conversation &#x3D; db2.model(&#39;Conversation&#39;, conversationSchema);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示指定 model</span><br><span class="line">let doc &#x3D; await Event.find().populate(&#123;</span><br><span class="line">   path: &#39;conversation&#39;, </span><br><span class="line">   model: Conversation </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用refPath进行动态引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let userSchame &#x3D; new Schame(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    connextions: [&#123;</span><br><span class="line">        kind: String,</span><br><span class="line">        item: &#123;</span><br><span class="line">            type: ObjectId,</span><br><span class="line">            refPath: &#39;connections.kind&#39; &#x2F;&#x2F; 根据kind字段判断使用哪个collection来填充item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">User.</span><br><span class="line">    findOne(...).</span><br><span class="line">    populate(&#39;connections.item&#39;)</span><br></pre></td></tr></table></figure><p>虚拟值填充（4.5.0新功能）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var PersonSchema &#x3D; new Schema(&#123;</span><br><span class="line">  name: String,</span><br><span class="line">  band: String</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var BandSchema &#x3D; new Schema(&#123;</span><br><span class="line">  name: String</span><br><span class="line">&#125;);</span><br><span class="line">BandSchema.virtual(&#39;members&#39;, &#123;</span><br><span class="line">  ref: &#39;Person&#39;, &#x2F;&#x2F; The model to use</span><br><span class="line">  localField: &#39;name&#39;, &#x2F;&#x2F; Find people where &#96;localField&#96;</span><br><span class="line">  foreignField: &#39;band&#39;, &#x2F;&#x2F; is equal to &#96;foreignField&#96;</span><br><span class="line">  &#x2F;&#x2F; If &#96;justOne&#96; is true, &#39;members&#39; will be a single doc as opposed to</span><br><span class="line">  &#x2F;&#x2F; an array. &#96;justOne&#96; is false by default.</span><br><span class="line">  justOne: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var Person &#x3D; mongoose.model(&#39;Person&#39;, PersonSchema);</span><br><span class="line">var Band &#x3D; mongoose.model(&#39;Band&#39;, BandSchema);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Suppose you have 2 bands: &quot;Guns N&#39; Roses&quot; and &quot;Motley Crue&quot;</span><br><span class="line"> * And 4 people: &quot;Axl Rose&quot; and &quot;Slash&quot; with &quot;Guns N&#39; Roses&quot;, and</span><br><span class="line"> * &quot;Vince Neil&quot; and &quot;Nikki Sixx&quot; with &quot;Motley Crue&quot;</span><br><span class="line"> *&#x2F;</span><br><span class="line">Band.find(&#123;&#125;).populate(&#39;members&#39;).exec(function(error, bands) &#123;</span><br><span class="line">  &#x2F;* &#96;bands.members&#96; is now an array of instances of &#96;Person&#96; *&#x2F;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要记得虚拟值默认不会被 toJSON() 输出。如果你需要填充的虚拟值显式在依赖 JSON.stringify() 的函数 （例如 Express 的 res.json() function）中打印， 需要在 toJSON 中设置 virtuals: true 选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Set &#96;virtuals: true&#96; so &#96;res.json()&#96; works</span><br><span class="line">var BandSchema &#x3D; new Schema(&#123;</span><br><span class="line">  name: String</span><br><span class="line">&#125;, &#123; toJSON: &#123; virtuals: true &#125; &#125;);</span><br></pre></td></tr></table></figure><p>如果你使用了填充保护，要确保 select 中包含了 foreignField。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Band.</span><br><span class="line">  find(&#123;&#125;).</span><br><span class="line">  populate(&#123; path: &#39;members&#39;, select: &#39;name&#39; &#125;).</span><br><span class="line">  exec(function(error, bands) &#123;</span><br><span class="line">    &#x2F;&#x2F; Won&#39;t work, foreign field &#96;band&#96; is not selected in the projection</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Band.</span><br><span class="line">  find(&#123;&#125;).</span><br><span class="line">  populate(&#123; path: &#39;members&#39;, select: &#39;name band&#39; &#125;).</span><br><span class="line">  exec(function(error, bands) &#123;</span><br><span class="line">    &#x2F;&#x2F; Works, foreign field &#96;band&#96; is selected</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在中间件中使用填充<br>你可以在 pre 或 post 钩子中使用填充。 如果你总是需要填充某一字段，可以了解一下mongoose-autopopulate 插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Always attach &#96;populate()&#96; to &#96;find()&#96; calls</span><br><span class="line">MySchema.pre(&#39;find&#39;, function() &#123;</span><br><span class="line">  this.populate(&#39;user&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Always &#96;populate()&#96; after &#96;find()&#96; calls. Useful if you want to selectively populate</span><br><span class="line">&#x2F;&#x2F; based on the docs found.</span><br><span class="line">MySchema.post(&#39;find&#39;, async function(docs) &#123;</span><br><span class="line">  for (let doc of docs) &#123;</span><br><span class="line">    if (doc.isPublic) &#123;</span><br><span class="line">      await doc.populate(&#39;user&#39;).execPopulate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#96;populate()&#96; after saving. Useful for sending populated data back to the client in an</span><br><span class="line">&#x2F;&#x2F; update API endpoint</span><br><span class="line">MySchema.post(&#39;save&#39;, function(doc, next) &#123;</span><br><span class="line">  doc.populate(&#39;user&#39;).execPopulate(function() &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="修改、添加、删除数据"><a href="#修改、添加、删除数据" class="headerlink" title="修改、添加、删除数据"></a>修改、添加、删除数据</h3><ol><li><p>添加行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.insert(&#123;name: &#39;aaa&#39;&#125;)</span><br><span class="line">db.yourCollection.save(&#123; name: &#39;name&#39;, age: 20 &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。<br>insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。</p></blockquote></li><li><p>2 版本之后新增了 db.collection.insertOne() 和 db.collection.insertMany()。</p></li><li><p>修改行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;, &#x2F;&#x2F; 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</span><br><span class="line">     multi: &lt;boolean&gt;, &#x2F;&#x2F; 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</span><br><span class="line">     writeConcern: &lt;document&gt; &#x2F;&#x2F; 可选，抛出异常的级别。</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.update(&#123; age: 25 &#125;, &#123; $set: &#123; name: &#39;张三&#39; &#125; &#125;, false, true); &#x2F;&#x2F; 相当于：update yourCollection set name &#x3D; ‘changeName’ where age &#x3D; 25;</span><br><span class="line">db.yourCollection.update(&#123;name: ‘Lisi’&#125;, &#123;$inc: &#123;age: 50&#125;&#125;, false, true); &#x2F;&#x2F; 相当于：update yourCollection set age &#x3D; age + 50 where name &#x3D; ‘Lisi&#39;;</span><br><span class="line">db.yourCollection.update(&#123;name: ‘Lisi’&#125;, &#123;$inc: &#123;age: 50&#125;, $set: &#123;name: ‘hoho’&#125;&#125;, false, true); &#x2F;&#x2F; 相当于：update yourCollection set age &#x3D; age + 50, name &#x3D; ‘hoho’ where name &#x3D; ‘Lisi&#39;;</span><br><span class="line">db.yourCollection.update(&#123;name: ‘Lisi’&#125;, &#123;$pull: &#123;age: 50&#125;, $set: &#123;name: ‘hoho’&#125;&#125;, false, true); </span><br></pre></td></tr></table></figure></li><li><p>删除行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.remove(&#123; age: 25 &#125;);</span><br><span class="line">db.yourCollection.remove(&#123;&#125;); &#x2F;&#x2F; 删除所有数据</span><br></pre></td></tr></table></figure></li><li><p>查询修改删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.findAndModify(&#123;</span><br><span class="line">query: &#123;age: &#123;$gte: 25&#125;&#125;,</span><br><span class="line">sort: &#123;age: -1&#125;,</span><br><span class="line">update: &#123;$set: &#123;name: ‘a2′&#125;, $inc: &#123;age: 2&#125;&#125;,</span><br><span class="line">remove: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>数组元素的删除、添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(&lt;query&gt;, &#123; $pull: &#123; &#39;group&#39;: &#123; groupName: &#39;friends&#39; &#125; &#125;&#125;); &#x2F;&#x2F; 删除group数组中groupName为friends的数据</span><br><span class="line">db.collection.update(&lt;query&gt;, &#123; $addToSet: &#123; &#39;group&#39;: &#123; groupName: &#39;newFriends&#39;&#125; &#125;&#125;); &#x2F;&#x2F; 在group数组中增加groupName为newFriends的数据</span><br></pre></td></tr></table></figure><h2 id="MongoDB索引"><a href="#MongoDB索引" class="headerlink" title="MongoDB索引"></a>MongoDB索引</h2><blockquote><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。<br>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。<br>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p></blockquote></li><li><p>创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.createIndex(&#123;name: 1&#125;); &#x2F;&#x2F; 1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</span><br><span class="line">db.yourCollection.createIndex(&#123;&quot;name&quot;:1,&quot;age&quot;:-1&#125;); &#x2F;&#x2F; 也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）</span><br></pre></td></tr></table></figure></li><li><p>查询当前聚集集合所有索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.getIndexes();</span><br></pre></td></tr></table></figure></li><li><p>查看总索引记录大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.totalIndexSize();</span><br></pre></td></tr></table></figure></li><li><p>读取当前集合的所有index信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.reIndex();</span><br></pre></td></tr></table></figure></li><li><p>删除指定索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.dropIndex(“name_1″);</span><br></pre></td></tr></table></figure></li><li><p>删除所有索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourCollection.dropIndexes();</span><br></pre></td></tr></table></figure><h2 id="MongoDB用户相关"><a href="#MongoDB用户相关" class="headerlink" title="MongoDB用户相关"></a>MongoDB用户相关</h2></li><li><p>添加一个用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: &#39;username&#39;, pwd: &#39;xxx&#39;, roles: [&#123;role: &#39;readWrite&#39;, db: &#39;dbName&#39;&#125;]&#125;);</span><br></pre></td></tr></table></figure></li><li><p>数据库认证、安全模式（登录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.auth(&quot;ray&quot;, &quot;123456&quot;);</span><br></pre></td></tr></table></figure></li><li><p>显示当前所有用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show users;</span><br></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.removeUser(&quot;userName&quot;);</span><br></pre></td></tr></table></figure><p>【参考】</p></li></ol><p><a href="http://www.mongoosejs.net/docs/index.html">Mongoose中文文档</a></p><p><a href="https://www.cnblogs.com/fayin/p/6656445.html">【mongodb】——常用命令大全</a></p><p><a href="https://juejin.cn/post/6844903591166083086">正确理解和使用 Mongodb 的索引</a></p><p><a href="https://www.cnblogs.com/greenteaone/p/11655543.html">Mongoose: aggregate聚合 $group使用说明</a></p><p><a href="https://segmentfault.com/a/1190000021010300">mongoose 系列之一 find 查询</a></p><p><a href="https://juejin.cn/post/6844904067819372558#heading-0">你必须要懂得关于mongoose的一小小部分</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;MongoDB是NoSQL数据库系统中比较流行的数据库之一。它也是最接近关系型数据库的，一个数据库可以包含多个集合（Collection），类似于关系数据库中的表；而每个集合中可以存储一组由列标识的记录，列是可以自由定义的，非常灵活，这就类似于关系</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mongodb" scheme="http://example.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>使用animation实现文字无限横向滚动</title>
    <link href="http://example.com/2021/12/12/%E4%BD%BF%E7%94%A8animation%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%97%A0%E9%99%90%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/"/>
    <id>http://example.com/2021/12/12/%E4%BD%BF%E7%94%A8animation%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%97%A0%E9%99%90%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/</id>
    <published>2021-12-12T12:02:23.000Z</published>
    <updated>2022-03-17T09:26:56.971Z</updated>
    
    <content type="html"><![CDATA[<p>需求</p><ol><li>若文字长度不超过容器宽度，则不滚动， 反之滚动（复制一遍文字，让滚动无缝衔接）。</li><li>匀速滚动（运动时间 = 路程 / 速度）。</li><li>监听resize事件，结合防抖throttle，触发后重新计算是否需要滚动。</li></ol><p>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;notice&quot; ref&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;p ref&#x3D;&quot;notice&quot;&gt;&#123;&#123;notice&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; throttle &#125; from &#39;@&#x2F;utils&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      defaultTxt: &#39;测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试。。。。。测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试。。。。。测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试。。。。。测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试。。。。。测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试测试环境用于测试。。。。。&#39;,</span><br><span class="line">      notice: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.getStyle()</span><br><span class="line">    window.addEventListener(&#39;resize&#39;, throttle(this.getStyle, 1000, true))</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getStyle () &#123;</span><br><span class="line">      this.notice &#x3D; this.defaultTxt</span><br><span class="line">      this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">        let containerW &#x3D; this.$refs.container.clientWidth</span><br><span class="line">        let noticeW &#x3D; this.$refs.notice.clientWidth</span><br><span class="line">        console.log(containerW, noticeW)</span><br><span class="line">        if (noticeW &gt; containerW) &#123;</span><br><span class="line">          this.notice &#x3D; this.defaultTxt + this.defaultTxt</span><br><span class="line">          this.$refs.notice.className &#x3D; &#39;run&#39;</span><br><span class="line">          this.$refs.notice.style.animationDuration &#x3D; noticeW &#x2F; 100 + &#39;s&#39; &#x2F;&#x2F; 匀速</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.notice &#x3D; this.defaultTxt</span><br><span class="line">          this.$refs.notice.className &#x3D; &#39;&#39;</span><br><span class="line">          this.$refs.notice.style.animationDuration &#x3D; 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed () &#123;</span><br><span class="line">    window.onresize &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">.notice &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 100%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  height: 30px;</span><br><span class="line">  line-height: 30px;</span><br><span class="line">  background: rgb(247, 225, 225);</span><br><span class="line">  color: #666;</span><br><span class="line">  @keyframes run &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">      transform: translateX(0);</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">      transform: translateX(-50%);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  p &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">  &#125;</span><br><span class="line">  .run &#123;</span><br><span class="line">    animation: 20s run linear infinite;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>附上防抖throttle代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export const throttle &#x3D; (fn, delay &#x3D; 1000, last &#x3D; false) &#x3D;&gt; &#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  let start &#x3D; new Date();</span><br><span class="line">  return function () &#123;</span><br><span class="line">    last &amp;&amp; timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">    let now &#x3D; new Date();</span><br><span class="line">    let context &#x3D; this;</span><br><span class="line">    let args &#x3D; arguments;</span><br><span class="line">    if (now - start &gt;&#x3D; delay) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      start &#x3D; now;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (last) &#123; &#x2F;&#x2F; 脱离事件后执行最后一次 &#x2F;&#x2F; 一般用于触底加载之类 &#x2F;&#x2F; 防止重复提交不需要执行最后一次</span><br><span class="line">        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">        &#125;, delay - (now - start));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需求&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若文字长度不超过容器宽度，则不滚动， 反之滚动（复制一遍文字，让滚动无缝衔接）。&lt;/li&gt;
&lt;li&gt;匀速滚动（运动时间 = 路程 / 速度）。&lt;/li&gt;
&lt;li&gt;监听resize事件，结合防抖throttle，触发后重新计算是否需要滚动。&lt;/</summary>
      
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Array.prototype.fill()生成二维数组问题</title>
    <link href="http://example.com/2021/12/12/Array-prototype-fill-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/12/12/Array-prototype-fill-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-12T11:56:35.000Z</published>
    <updated>2022-03-17T09:26:56.936Z</updated>
    
    <content type="html"><![CDATA[<p>我打算使用Array.prototype.fill()快速生成二维数组，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Array(10).fill(new Array(5).fill(0))</span><br></pre></td></tr></table></figure><p>预期生成10 * 5的二维数组<br>但是，当我们操作数组时，会发现出现了问题,以下代码使得所有p[i][0]都变为了10，这说明填充的数组都指向同一个引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[0][0] &#x3D; 10</span><br></pre></td></tr></table></figure><p>查阅MDN，得知填充的是数组的引用。</p><blockquote><p>If the first parameter is an object, each slot in the array will reference that object.</p></blockquote><p><strong>解决</strong><br>为了解决以上问题，我们尝试使用Array.prototype.map()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Array(10).map(() &#x3D;&gt; new Array(5).fill(0))</span><br></pre></td></tr></table></figure><p>控制台打印p，发现他是一个包含了10个empty items的一维数组，说明map失败。</p><p>Array.map的callback只会针对已经赋值过的item进行调用（包括undefined）。<br>所以当有的元素被删除了，或者从来没有被赋值的时候，callback不会调用这个元素。</p><blockquote><p>map calls a provided callbackFn function once for each element in an array, in order, and constructs a new array from the results. callbackFn is invoked only for indexes of the array which have assigned values (including undefined).</p></blockquote><p>优化: 初始化时赋值为null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Array(10).fill(null).map(() &#x3D;&gt; new Array(5).fill(0))</span><br></pre></td></tr></table></figure><p>其它方法：使用索引迭代器Array.prototype.keys()，利用扩展运算符可以获取从没赋值的empty items。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; [...Array(10).keys()].map(() &#x3D;&gt; new Array(5).fill(0))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我打算使用Array.prototype.fill()快速生成二维数组，代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js基础" scheme="http://example.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>跨域及其解决方案</title>
    <link href="http://example.com/2021/12/12/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2021/12/12/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-12-12T11:50:25.000Z</published>
    <updated>2022-03-17T09:26:57.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会有跨域？"><a href="#为什么会有跨域？" class="headerlink" title="为什么会有跨域？"></a>为什么会有跨域？</h2><p><code>出于安全性考虑</code>，浏览器限制脚本内发起的跨源HTTP请求。例如，XMLHttpRequest和Fetch API遵循<code>同源策略</code>。这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。</p><blockquote><p>同源策略：如果两个URL的protocol(协议)、port(端口，如果有指定的话)和host(域名)都相同的话，则这两个URL是同源。</p></blockquote><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h3><p>在CORS之前，开发人员也有跨域请求资源的需求，他们提出了多种方案，其中JSONP为常见的一种。JSONP作为一种古老的方案已经不被推荐在项目中使用，但其优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据，我们也有必要了解下其实现原理，开阔开发思路。</p><blockquote><p>原理： 所有具有src属性的HTML标签都是可以跨域的。在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;和&lt;link&gt;这几个标签是可以加载跨域（非同源）的资源的，并且加载的方式其实相当于一次普通的GET请求，唯一不同的是，为了安全起见，浏览器不允许这种方式下对加载到的资源的读写操作，而只能使用标签本身应当具备的能力（比如脚本执行、样式应用等等）。</p></blockquote><blockquote><p>JSONP的缺点：</p><ul><li>只能实现get一种请求方式。</li><li>JSONP在调用失败的时候前端不能获取各种HTTP状态码。</li><li>安全性问题。万一假如提供JSONP的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。那么结果是什么？所有调用这个JSONP的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用JSONP的时候必须要保证使用的JSONP服务必须是安全可信的。</li></ul></blockquote><p>利用script标签天生具有跨域能力和脚本执行的能力的原理，前后端约定好一个函数名callbackName，使用script标签发送请求，服务器端获取数据res后响应请求返回callback(res)格式的脚本，则会在客户端将res作为参数执行函数callback，至此，客户端获取到了接口的返回值res。</p><p>先实现一个简单的JSONP。</p><h4 id="jsonp-v1版本"><a href="#jsonp-v1版本" class="headerlink" title="jsonp_v1版本"></a>jsonp_v1版本</h4><p>服务器示例代码(node) <a href="http://xxx.xxx.com/">http://xxx.xxx.com</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#39;&#x2F;test&#39;, async ctx &#x3D;&gt; &#123;</span><br><span class="line">    const &#123; keyword, callback &#125; &#x3D; ctx.query;</span><br><span class="line">    let res &#x3D; await testController.getData(&#123; keyword &#125;);</span><br><span class="line">    ctx.body &#x3D; &#96;$&#123;callback&#125;(&#123;</span><br><span class="line">      code: 1,</span><br><span class="line">      data: $&#123;JSON.stringify(res)&#125;,</span><br><span class="line">      msg: &#39;请求成功&#39;</span><br><span class="line">    &#125;)&#96;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>前端示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先处理下参数</span><br><span class="line">const getEncodeParams &#x3D; (data &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  let res &#x3D; []</span><br><span class="line">  for (let key in data) &#123;</span><br><span class="line">    res.push(&#96;$&#123;encodeURIComponent(key)&#125;&#x3D;$&#123;encodeURIComponent(data[key])&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">  return res.join(&#39;&amp;&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function jsonp_v1 (url, data, callbackFunc) &#123;</span><br><span class="line">  let elem &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  elem.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line">  elem.src &#x3D; &#96;$&#123;url&#125;?$&#123;getEncodeParams(data)&#125;&amp;callback&#x3D;callbackFunc&#96;;</span><br><span class="line">  window.callbackFunc &#x3D; callbackFunc;</span><br><span class="line">  document.body.appendChild(elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 发送请求</span><br><span class="line">jsonp_v1(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;tool&#x2F;test&#39;, &#123; keyword: &#39;hello-world&#39; &#125;, function (res) &#123; &#x2F;&#x2F; 服务器处理请求后会返回&quot;调用这个函数的脚本&quot;</span><br><span class="line">  alert(res)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缺点：发送多个请求时，window.callbackFunc会被重写，例如运行以下代码，我们期望alert一次，console一次，结果却是console两次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jsonp_v1(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;tool&#x2F;test&#39;, &#123; keyword: &#39;hello-world&#39; &#125;, function (res) &#123; &#x2F;&#x2F; 服务器处理请求后会返回&quot;调用这个函数的脚本&quot;</span><br><span class="line">  alert(res)</span><br><span class="line">&#125;);</span><br><span class="line">jsonp_v1(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;tool&#x2F;test&#39;, &#123; keyword: &#39;hello&#39; &#125;, function (res) &#123; &#x2F;&#x2F; 服务器处理请求后会返回&quot;调用这个函数的脚本&quot;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="jsonp-v2版本"><a href="#jsonp-v2版本" class="headerlink" title="jsonp_v2版本"></a>jsonp_v2版本</h4><p>对v1版本的优化：需要考虑同时发送多个JSONP请求的情况，callbackFunc 挂在 window上的属性名需要唯一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function jsonp_v2(url, data, callbackFunc) &#123;</span><br><span class="line">  let elem &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  let callbackName &#x3D; &#96;jsonp_$&#123;new Date().getTime()&#125;&#96;;</span><br><span class="line">  elem.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line">  elem.src &#x3D; &#96;$&#123;url&#125;?$&#123;getEncodeParams(data)&#125;&amp;callback&#x3D;$&#123;callbackName&#125;&#96;;</span><br><span class="line">  window[callbackName] &#x3D; callbackFunc;</span><br><span class="line">  document.body.appendChild(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsonp-v3版本"><a href="#jsonp-v3版本" class="headerlink" title="jsonp_v3版本"></a>jsonp_v3版本</h4><p>优化：封装promise获取返回值，加入错误处理机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function jsonp_v3 (url, data) &#123;</span><br><span class="line"> return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">   let elem &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">   let callbackName &#x3D; &#96;jsonp_$&#123;new Date().getTime()&#125;&#96;;</span><br><span class="line">   elem.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line">   elem.src &#x3D; &#96;$&#123;url&#125;?$&#123;getEncodeParams(data)&#125;&amp;callback&#x3D;$&#123;callbackName&#125;&#96;;</span><br><span class="line">   window[callbackName] &#x3D; resolve;</span><br><span class="line">   elem.onerror &#x3D; function () &#123; reject(&#39;调用接口失败&#39;) &#125;</span><br><span class="line">   document.body.appendChild(elem);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsonp-v4版本"><a href="#jsonp-v4版本" class="headerlink" title="jsonp_v4版本"></a>jsonp_v4版本</h4><p>优化：当发送大量请求后，我们会发现页面多了很多全局变量和script标签，这些数据应该在完成请求后删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function jsonp_v4 (url, data) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    let elem &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    let callbackName &#x3D; &#96;jsonp_$&#123;new Date().getTime()&#125;&#96;;</span><br><span class="line">    elem.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line">    elem.src &#x3D; &#96;$&#123;url&#125;?$&#123;getEncodeParams(data)&#125;&amp;callback&#x3D;$&#123;callbackName&#125;&#96;;</span><br><span class="line">    window[callbackName] &#x3D; function (res) &#123; &#x2F;&#x2F; 服务器处理请求后会返回&quot;调用这个函数的脚本&quot;</span><br><span class="line">      resolve(res);</span><br><span class="line">      delete window[callbackName];</span><br><span class="line">      document.body.removeChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    elem.onerror &#x3D; function() &#123;</span><br><span class="line">      reject(&#39;调用接口失败&#39;);</span><br><span class="line">      delete window[callbackName];</span><br><span class="line">      document.body.removeChild(elem);</span><br><span class="line">   &#125;</span><br><span class="line">   document.body.appendChild(elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/hello-astar/js/blob/master/cross-domain/jsonp.html">示例代码</a></p><h3 id="2-图像ping"><a href="#2-图像ping" class="headerlink" title="2. 图像ping"></a>2. 图像ping</h3><blockquote><p>图像Ping原理与JSONP差不多，它是与服务器进行简单、<code>单向</code>的跨域通信的一种方式。 请求的数据是通过査询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let img &#x3D; new Image();</span><br><span class="line">img.onload &#x3D; img.onerror &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;已通知服务端nick浏览了此页面&#39;)</span><br><span class="line">&#125;</span><br><span class="line">img.src &#x3D; &#96;http:&#x2F;&#x2F;localhost:3000&#x2F;tool&#x2F;test?name&#x3D;nick&#96;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/hello-astar/js/blob/master/cross-domain/imgPing.html">示例代码</a></p><h3 id="3-CORS跨域资源共享"><a href="#3-CORS跨域资源共享" class="headerlink" title="3. CORS跨域资源共享"></a>3. CORS跨域资源共享</h3><blockquote><p>CORS是一个W3C标准，名为“跨域资源共享”（Cross-origin resource sharing）。它是一种基于HTTP头的机制，该机制通过允许服务器标示除了它自己以外的其它origin(域、协议和端口)，这样浏览器就可以访问加载这些资源。跨域资源共享还通过一些机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨域资源的“预检”请求（option请求）。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。</p></blockquote><blockquote><p>实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p></blockquote><p>以下为示例代码（nodejs中间件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> module.exports &#x3D; function (WHITE_WEBSITES) &#123;</span><br><span class="line">  return async function (ctx, next) &#123;</span><br><span class="line">    const allowHost &#x3D; WHITE_WEBSITES; &#x2F;&#x2F; 白名单</span><br><span class="line">    if (allowHost.includes(ctx.request.header.origin)) &#123;</span><br><span class="line">      ctx.set(&#39;Access-Control-Allow-Origin&#39;, ctx.request.header.origin);</span><br><span class="line">      ctx.set(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, Content-Length, Authorization, Accept, X-Requested-With&#39;);</span><br><span class="line">      ctx.set(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, OPTIONS&#39;);</span><br><span class="line">      ctx.set(&#39;Access-Control-Allow-Credentials&#39;, true);</span><br><span class="line">    &#125;</span><br><span class="line">    if (ctx.method &#x3D;&#x3D; &#39;OPTIONS&#39;) &#123;</span><br><span class="line">      ctx.response.status &#x3D; 204;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      await next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端发送请求时，将withCredentials置为true，可以在跨域请求中发送cookie。</p><blockquote><p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p></blockquote><h3 id="4-反向代理"><a href="#4-反向代理" class="headerlink" title="4. 反向代理"></a>4. 反向代理</h3><blockquote><p>注意，由于接口代理是有代价的，所以这个一般是开发过程中进行的。</p></blockquote><p>前端本地开发的过程中，往往需要使用代理解决跨域问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue.config.js</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    ...</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#39;&#x2F;test-proxy&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;192.168.22.173:3000&#39;,          </span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#39;^&#x2F;test-proxy&#39;: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="简单了解下正向代理和反向代理"><a href="#简单了解下正向代理和反向代理" class="headerlink" title="简单了解下正向代理和反向代理"></a>简单了解下正向代理和反向代理</h4><p><img src="1_proxy.png" alt="image"><br>正向代理代理客户端，反向代理代理服务器。举个不那么恰当但容易理解的比喻，正向代理相当于帮我们找房的中介，方向代理相当于二房东。</p><h3 id="5-nodejs中间件代理跨域"><a href="#5-nodejs中间件代理跨域" class="headerlink" title="5. nodejs中间件代理跨域"></a>5. nodejs中间件代理跨域</h3><p>使用如koa2-proxy-middleware之类的中间件进行代理转发。</p><h3 id="6-iframe"><a href="#6-iframe" class="headerlink" title="6. iframe"></a>6. iframe</h3><h4 id="方法一-iframe-postMessage"><a href="#方法一-iframe-postMessage" class="headerlink" title="方法一 iframe + postMessage"></a>方法一 iframe + postMessage</h4><p>iframe使得一个页面可以嵌套非同源站点的html文件，他俩可以通过<code>postMessage api</code>通信，利用这两特性，我们可以在页面（假设a.html）内嵌一个iframe（假设指向b.html，b.html与服务器能正常通信），设置其display为none，由不跨域的b.html请求接口，获取接口返回值后通过postMessage返回给a.html</p><blockquote><p>window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  * 通过iframe通信</span><br><span class="line">  * @author astar</span><br><span class="line">  * @date 2021-07-03 12:47</span><br><span class="line">  *&#x2F;</span><br><span class="line">  function iframeCommunicate(url, cb) &#123;</span><br><span class="line">    let iframe &#x3D; document.createElement(&#39;iframe&#39;);</span><br><span class="line">    let key &#x3D; &#96;callbackName_$&#123;new Date().getTime()&#125;&#96;;</span><br><span class="line">    iframe.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">    iframe.name &#x3D; key;</span><br><span class="line">    iframe.src &#x3D; url + &#96;&amp;key&#x3D;$&#123;key&#125;&#96;; &#x2F;&#x2F; 增加请求唯一标识</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">    window[key] &#x3D; cb;</span><br><span class="line">  &#125;</span><br><span class="line">  function handleIframe (e) &#123;</span><br><span class="line">    let &#123; data, key &#125; &#x3D; e.data;</span><br><span class="line">    if (window[key]) &#123;</span><br><span class="line">      window[key](e.data);</span><br><span class="line">      let iframes &#x3D; document.getElementsByName(key);</span><br><span class="line">      document.body.removeChild(iframes[0]);</span><br><span class="line">      delete window[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 所有接口返回都会调用handleIframe,需要指定唯一的标识(key),辨别返回的信息是哪一次调用iframeCommunicate</span><br><span class="line">  window.addEventListener(&#39;message&#39;, handleIframe);</span><br><span class="line"></span><br><span class="line">  iframeCommunicate(&#96;http:&#x2F;&#x2F;localhost:3000&#x2F;b.html?type&#x3D;GET&amp;queryUrl&#x3D;$&#123;encodeURIComponent(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;tool&#x2F;test?keyword&#x3D;888&amp;callback&#x3D;test&#39;)&#125;&#96;, function(params) &#123;</span><br><span class="line">    console.log(&#39;接口返回&#39;, params)</span><br><span class="line">  &#125;);</span><br><span class="line">  iframeCommunicate(&#96;http:&#x2F;&#x2F;localhost:3000&#x2F;b.html?type&#x3D;POST&amp;queryUrl&#x3D;$&#123;encodeURIComponent(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;tool&#x2F;test&#39;)&#125;&amp;keyword&#x3D;999&amp;callback&#x3D;test&#96;, function(params) &#123;</span><br><span class="line">    console.log(&#39;接口返回&#39;, params)</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  * 解析url,获取接口url,请求方式和参数</span><br><span class="line">  * @author astar</span><br><span class="line">  * @date 2021-07-03 17:37</span><br><span class="line">  *&#x2F;</span><br><span class="line">  function parseSearch() &#123;</span><br><span class="line">    let search &#x3D; location.search.slice(1);</span><br><span class="line">    let keyValuePairArr &#x3D; search.split(&#39;&amp;&#39;);</span><br><span class="line">    let obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    keyValuePairArr.forEach(pair &#x3D;&gt; &#123;</span><br><span class="line">      let [key, value] &#x3D; pair.split(&#39;&#x3D;&#39;);</span><br><span class="line">      obj[decodeURIComponent(key)] &#x3D; decodeURIComponent(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  * 获取接口参数</span><br><span class="line">  * @author astar</span><br><span class="line">  * @date 2021-07-03 17:38</span><br><span class="line">  *&#x2F;</span><br><span class="line">  function getParams(obj) &#123;</span><br><span class="line">    delete obj.type;</span><br><span class="line">    delete obj.queryUrl;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  let obj &#x3D; parseSearch();</span><br><span class="line">  &#x2F;&#x2F; 简单使用xhr发送请求</span><br><span class="line">  let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">    if (xhr.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">      console.log(xhr.status, xhr.responseText)</span><br><span class="line">      if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D;&#x3D; 304) &#123;</span><br><span class="line">        window.parent.postMessage(&#123; data: xhr.responseText, key: obj.key &#125;, &#39;*&#39;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(&quot;Request was unsuccessful:&quot; + xhr.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.open(obj.type, obj.queryUrl);</span><br><span class="line">  xhr.send(JSON.stringify(getParams(obj)));</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>以上实现还有优化空间，比如请求接口失败处理等，但这非本文重点，读者有兴趣可自己完善。</p><p><a href="https://github.com/hello-astar/js/blob/master/cross-domain/iframe/a.html">示例代码 - a.html</a></p><p><a href="https://github.com/hello-astar/js/blob/master/cross-domain/iframe/b.html">示例代码 - b.html</a></p><h4 id="方法二-iframe-window-name"><a href="#方法二-iframe-window-name" class="headerlink" title="方法二 iframe + window.name"></a>方法二 iframe + window.name</h4><p>原理：</p><ol><li>iframe之间共享window.name变量。</li><li>iframe与父页面同源时，通过<code>window.parent[functionName]()</code>可访问父页面的函数。<br>假设c.html跨域请求数据，我们可以在页面c.html内嵌一个iframe（d.html-可与服务器通信），设置其display为none，由能正常请求数据的d.html请求接口，获取接口返回值后存入window.name变量，再在d.html中打开e.html（e.html与c.html同源），此时e.html可以访问window.name数据，再通过window.parent调用c.html的回调函数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; c.html &#x2F;&#x2F; 在a.html基础上稍作修改</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  * 通过iframe通信</span><br><span class="line">  * @author astar</span><br><span class="line">  * @date 2021-07-03 12:47</span><br><span class="line">  *&#x2F;</span><br><span class="line">  function iframeCommunicate(url, cb) &#123;</span><br><span class="line">    let iframe &#x3D; document.createElement(&#39;iframe&#39;);</span><br><span class="line">    let key &#x3D; &#96;callbackName_$&#123;new Date().getTime()&#125;&#96;;</span><br><span class="line">    iframe.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">    iframe.name &#x3D; key;</span><br><span class="line">    iframe.src &#x3D; url + &#96;&amp;key&#x3D;$&#123;key&#125;&#96;; &#x2F;&#x2F; 增加请求唯一标识</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">    window[key] &#x3D; function (data) &#123;</span><br><span class="line">      cb(data)</span><br><span class="line">      delete window[key];</span><br><span class="line">      document.body.removeChild(iframe);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  iframeCommunicate(&#96;http:&#x2F;&#x2F;localhost:3000&#x2F;d.html?type&#x3D;GET&amp;queryUrl&#x3D;$&#123;encodeURIComponent(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;tool&#x2F;test?keyword&#x3D;888&amp;callback&#x3D;test&#39;)&#125;&#96;, function (params) &#123;</span><br><span class="line">    console.log(&#39;接口1返回&#39;, params)</span><br><span class="line">  &#125;);</span><br><span class="line">  iframeCommunicate(&#96;http:&#x2F;&#x2F;localhost:3000&#x2F;d.html?type&#x3D;POST&amp;queryUrl&#x3D;$&#123;encodeURIComponent(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;tool&#x2F;test&#39;)&#125;&amp;keyword&#x3D;999&amp;callback&#x3D;test&#96;, function(params) &#123;</span><br><span class="line">    console.log(&#39;接口2返回&#39;, params)</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; d.html &#x2F;&#x2F; 在b.html基础上稍作修改</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  * 解析url,获取接口url,请求方式和参数</span><br><span class="line">  * @author astar</span><br><span class="line">  * @date 2021-07-03 17:37</span><br><span class="line">  *&#x2F;</span><br><span class="line">  function parseSearch() &#123;</span><br><span class="line">    let search &#x3D; location.search.slice(1);</span><br><span class="line">    let keyValuePairArr &#x3D; search.split(&#39;&amp;&#39;);</span><br><span class="line">    let obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    keyValuePairArr.forEach(pair &#x3D;&gt; &#123;</span><br><span class="line">      let [key, value] &#x3D; pair.split(&#39;&#x3D;&#39;);</span><br><span class="line">      obj[decodeURIComponent(key)] &#x3D; decodeURIComponent(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  * 获取接口参数</span><br><span class="line">  * @author astar</span><br><span class="line">  * @date 2021-07-03 17:38</span><br><span class="line">  *&#x2F;</span><br><span class="line">  function getParams(obj) &#123;</span><br><span class="line">    delete obj.type;</span><br><span class="line">    delete obj.queryUrl;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  let obj &#x3D; parseSearch();</span><br><span class="line">  let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">    if (xhr.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">      if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D;&#x3D; 304) &#123;</span><br><span class="line">        window.name &#x3D; JSON.stringify(&#123; data: xhr.responseText, key: obj.key &#125;);</span><br><span class="line">        location.href &#x3D; &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;e.html&#39;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(&quot;Request was unsuccessful:&quot; + xhr.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.open(obj.type, obj.queryUrl);</span><br><span class="line">  xhr.send(JSON.stringify(getParams(obj)));</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; e.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let &#123; key, data &#125; &#x3D; JSON.parse(window.name);</span><br><span class="line">  window.parent[key](data);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/hello-astar/js/blob/master/cross-domain/iframe/c.html">示例代码 - c.html</a></p><p><a href="https://github.com/hello-astar/js/blob/master/cross-domain/iframe/d.html">示例代码 - d.html</a></p><p><a href="https://github.com/hello-astar/js/blob/master/cross-domain/iframe/e.html">示例代码 - e.html</a></p><p>其他iframe解决跨域的方案有<code>document.domain</code>、<code>location.hash</code>等，篇幅限制，不再赘述。</p><p>【参考】</p><p><a href="https://zhuanlan.zhihu.com/p/111669476">JSONP和图像ping跨域过程</a></p><p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享CORS详解-阮一峰</a></p><p><a href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）</a></p><p><a href="https://zhuanlan.zhihu.com/p/46618196">javascript 跨域方法总结</a></p><p><a href="https://segmentfault.com/a/1190000012469713#articleHeader11">ajax跨域，这应该是最全的解决方案了</a></p><p><a href="https://cloud.tencent.com/developer/article/1418457">终于有人把正向代理和反向代理解释的明明白白了！</a></p><p><a href="https://www.cnblogs.com/Anker/p/6056540.html">正向代理与反向代理【总结】</a></p><p><a href="https://segmentfault.com/a/1190000013536703">iframe解决跨域ajax请求的方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么会有跨域？&quot;&gt;&lt;a href=&quot;#为什么会有跨域？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有跨域？&quot;&gt;&lt;/a&gt;为什么会有跨域？&lt;/h2&gt;&lt;p&gt;&lt;code&gt;出于安全性考虑&lt;/code&gt;，浏览器限制脚本内发起的跨源HTTP请求。例如，XM</summary>
      
    
    
    
    <category term="浏览器和计算机网络" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="跨域" scheme="http://example.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli3兼容ie11</title>
    <link href="http://example.com/2021/01/05/vue-cli3%E5%85%BC%E5%AE%B9ie11/"/>
    <id>http://example.com/2021/01/05/vue-cli3%E5%85%BC%E5%AE%B9ie11/</id>
    <published>2021-01-05T08:33:50.000Z</published>
    <updated>2022-03-17T09:26:56.967Z</updated>
    
    <content type="html"><![CDATA[<p>在ie11下打开vue-cli3的项目，发现页面空白，使用babel-polyfill可兼容ie</p><h3 id="安装babel-polyfill"><a href="#安装babel-polyfill" class="headerlink" title="安装babel-polyfill"></a>安装babel-polyfill</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-polyfill</span><br></pre></td></tr></table></figure><h3 id="修改vue-config-js文件，在入口处引入babel-polyfill"><a href="#修改vue-config-js文件，在入口处引入babel-polyfill" class="headerlink" title="修改vue.config.js文件，在入口处引入babel-polyfill"></a>修改vue.config.js文件，在入口处引入babel-polyfill</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: (config) &#x3D;&gt; &#123;</span><br><span class="line">  config.entry.app &#x3D; [&#39;babel-polyfill&#39;, &#39;.&#x2F;src&#x2F;main.js&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【参考】<br><a href="https://segmentfault.com/a/1190000019525892?utm_source=sf-related">vue-cli3下，配置IE浏览器兼容性</a><br><a href="https://segmentfault.com/a/1190000022217565">前端开发中在IE11下出现的一些兼容性问题（持续汇总）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在ie11下打开vue-cli3的项目，发现页面空白，使用babel-polyfill可兼容ie&lt;/p&gt;
&lt;h3 id=&quot;安装babel-polyfill&quot;&gt;&lt;a href=&quot;#安装babel-polyfill&quot; class=&quot;headerlink&quot; title=&quot;安装ba</summary>
      
    
    
    
    <category term="前端框架" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="兼容ie" scheme="http://example.com/tags/%E5%85%BC%E5%AE%B9ie/"/>
    
  </entry>
  
</feed>
